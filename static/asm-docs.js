var tokens = { 
    "PSLLDQ": {"html": "<p>Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The source and destination operands are the same. Bits (VLMAX-1:128) of the corre-sponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The source and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The count operand applies to both the low and high 128-bit lanes.</p><p>Note: VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSLLDQ.html", "tooltip": "Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate."},
    "VFMSUBADD132PD": {"html": "<p>VFMSUBADD132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMSUBADD213PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFMSUBADD231PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMSUBADD132PD:VFMSUBADD213PD:VFMSUBADD231PD.html", "tooltip": "VFMSUBADD132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand)."},
    "PACKSSWB": {"html": "<p>Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow condi-tions. See Figure 4-2 for an example of the packing operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 484777.980010 379.199990 94.020000' height='141.03'><text y='484794.002844' x='225.06' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='36.415134'>64-Bit SRC</text><text y='484795.502244' x='335.0996' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='41.26458'>64-Bit DEST</text><text y='484865.187972' x='278.76' style='font-size:8.019600pt' lengthAdjust='spacingAndGlyphs' textLength='44.4045252'>64-Bit DEST</text><rect y='484798.56' x='210.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='484838.04' x='262.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='484799.52' x='319.08' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><path style='stroke:black' d='M230.100000,484815.780000 L229.920000,484815.720000 L229.740000,484816.140000 L229.920000,484816.200000 '></path><path style='stroke:black' d='M230.100000,484815.780000 L229.920000,484816.200000 L265.500000,484832.640000 L265.680000,484832.220000 '></path><path style='stroke:black' d='M265.200000,484816.800000 L265.020000,484816.680000 L264.720000,484817.040000 L264.900000,484817.160000 '></path><path style='stroke:black' d='M265.200000,484816.800000 L264.900000,484817.160000 L284.280000,484831.140000 L284.580000,484830.780000 '></path><path style='stroke:black' d='M336.660000,484817.700000 L336.840000,484817.580000 L336.540000,484817.160000 L336.360000,484817.280000 '></path><path style='stroke:black' d='M336.660000,484817.700000 L336.360000,484817.280000 L316.440000,484830.960000 L316.740000,484831.380000 '></path><path style='stroke:black' d='M372.120000,484818.240000 L372.300000,484818.180000 L372.120000,484817.760000 L371.940000,484817.820000 '></path><path style='stroke:black' d='M372.120000,484818.240000 L371.940000,484817.820000 L335.400000,484832.580000 L335.580000,484833.000000 '></path><path style='stroke:black' d='M284.880000,484831.560000 L285.360000,484829.700000 L285.540000,484828.680000 L286.260000,484829.520000 L290.340000,484834.680000 L291.420000,484836.060000 L289.800000,484835.460000 L283.620000,484833.240000 L282.600000,484832.880000 L283.440000,484832.340000 L283.920000,484832.280000 L290.100000,484834.500000 L289.800000,484835.460000 L289.560000,484835.280000 L285.480000,484830.120000 L286.260000,484829.520000 L286.320000,484829.940000 L285.840000,484831.800000 '></path><path style='stroke:black' d='M315.900000,484831.380000 L317.460000,484832.520000 L318.360000,484833.060000 L317.280000,484833.420000 L311.040000,484835.520000 L309.360000,484836.120000 L310.500000,484834.740000 L314.700000,484829.640000 L315.360000,484828.800000 L315.600000,484829.820000 L315.480000,484830.240000 L311.280000,484835.340000 L310.500000,484834.740000 L310.740000,484834.560000 L316.980000,484832.460000 L317.280000,484833.420000 L316.860000,484833.360000 L315.300000,484832.220000 '></path><path style='stroke:black' d='M285.360000,484831.680000 L285.840000,484829.820000 L289.920000,484834.980000 L283.740000,484832.760000 '></path><path style='stroke:black' d='M315.600000,484829.820000 L316.080000,484831.680000 L315.300000,484832.220000 L315.180000,484832.100000 L315.120000,484831.920000 L314.640000,484830.060000 '></path><path style='stroke:black' d='M266.100000,484832.820000 L266.220000,484830.900000 L266.340000,484829.880000 L267.120000,484830.600000 L272.100000,484834.920000 L273.420000,484836.060000 L271.680000,484835.820000 L265.200000,484834.800000 L264.180000,484834.620000 L264.900000,484833.900000 L265.380000,484833.780000 L271.860000,484834.800000 L271.680000,484835.820000 L271.440000,484835.640000 L266.460000,484831.320000 L267.120000,484830.600000 L267.300000,484831.020000 L267.180000,484832.940000 '></path><path style='stroke:black' d='M315.600000,484831.800000 L317.160000,484832.940000 L310.920000,484835.040000 L315.120000,484829.940000 '></path><path style='stroke:black' d='M334.740000,484832.880000 L336.000000,484834.320000 L336.720000,484835.100000 L335.640000,484835.220000 L329.100000,484835.880000 L327.300000,484836.060000 L328.740000,484834.980000 L333.960000,484830.960000 L334.800000,484830.300000 L334.860000,484831.320000 L334.620000,484831.740000 L329.400000,484835.760000 L328.740000,484834.980000 L329.040000,484834.860000 L335.580000,484834.200000 L335.640000,484835.220000 L335.280000,484835.040000 L334.020000,484833.600000 '></path><path style='stroke:black' d='M284.520000,484830.780000 L284.280000,484831.140000 L285.240000,484831.860000 L285.480000,484831.500000 '></path><path style='stroke:black' d='M284.580000,484830.780000 L284.760000,484830.900000 L284.460000,484831.260000 L284.280000,484831.140000 '></path><path style='stroke:black' d='M266.640000,484832.880000 L266.760000,484830.960000 L271.740000,484835.280000 L265.260000,484834.260000 '></path><path style='stroke:black' d='M316.680000,484831.320000 L316.440000,484830.960000 L315.480000,484831.620000 L315.720000,484831.980000 '></path><path style='stroke:black' d='M316.740000,484831.380000 L316.560000,484831.500000 L316.260000,484831.080000 L316.440000,484830.960000 '></path><path style='stroke:black' d='M283.440000,484832.340000 L285.060000,484831.260000 L285.840000,484831.800000 L285.780000,484831.980000 L285.660000,484832.100000 L284.040000,484833.180000 '></path><path style='stroke:black' d='M334.380000,484833.240000 L335.640000,484834.680000 L329.100000,484835.340000 L334.320000,484831.320000 '></path><path style='stroke:black' d='M334.860000,484831.320000 L334.920000,484833.240000 L334.020000,484833.600000 L333.900000,484833.420000 L333.840000,484833.240000 L333.780000,484831.320000 '></path><path style='stroke:black' d='M265.680000,484832.160000 L265.440000,484832.640000 L266.520000,484833.120000 L266.760000,484832.640000 '></path><path style='stroke:black' d='M265.680000,484832.220000 L265.860000,484832.280000 L265.680000,484832.700000 L265.500000,484832.640000 '></path><path style='stroke:black' d='M264.900000,484833.900000 L266.280000,484832.520000 L267.180000,484832.940000 L267.120000,484833.120000 L265.620000,484834.620000 '></path><path style='stroke:black' d='M335.580000,484833.000000 L335.340000,484832.520000 L334.320000,484833.000000 L334.500000,484833.480000 '></path><path style='stroke:black' d='M335.580000,484833.000000 L335.400000,484833.060000 L335.220000,484832.640000 L335.400000,484832.580000 '></path><text y='484810.082844' x='261.6002' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.1895'>C</text><text y='484810.382844' x='227.22' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.9077'>D</text><text y='484849.322644' x='303.9002' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='6.093528'>B’</text><text y='484849.622644' x='286.4399' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.613132'>C’</text><text y='484849.862844' x='267.9' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='6.270684'>D’</text><text y='484850.102244' x='321.8999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='6.091932'>A’</text><text y='484810.322844' x='333.06' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.71618'>B</text><text y='484811.582844' x='370.5596' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.97154'>A</text></svg><h3>Figure 4-2.  Operation of the PACKSSDW Instruction Using 64-bit Operands</h3><p>The (V)PACKSSWB instruction converts 4, 8 or 16 signed word integers from the destination operand (first operand) and 4, 8 or 16 signed word integers from the source operand (second operand) into 8, 16 or 32 signed byte integers and stores the result in the destination operand. If a signed word integer value is beyond the range of a signed byte integer (that is, greater than 7FH for a positive integer or greater than 80H for a negative integer), the saturated signed byte integer value of 7FH or 80H, respectively, is stored in the destination.</p><p>The (V)PACKSSDW instruction packs 2, 4 or 8 signed doublewords from the destination operand (first operand) and 2, 4 or 8 signed doublewords from the source operand (second operand) into 4, 8 or 16 signed words in the desti-nation operand (see Figure 4-2). If a signed doubleword integer value is beyond the range of a signed word (that is, greater than 7FFFH for a positive integer or greater than 8000H for a negative integer), the saturated signed word integer value of 7FFFH or 8000H, respectively, is stored into the destination.</p><p>The (V)PACKSSWB and (V)PACKSSDW instructions operate on either 64-bit, 128-bit operands or 256-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PACKSSWB:PACKSSDW.html", "tooltip": "Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow condi-tions. See Figure 4-2 for an example of the packing operation."},
    "INC": {"html": "<p>Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.</p></span>", "url": "INC.html", "tooltip": "Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)"},
    "DPPD": {"html": "<p>Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand) with the packed double-precision floating-point values in the source (second operand) depending on a mask extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corre-sponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The two resulting double-precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.</p><p>If a broadcast mask bit is '1', the intermediate result is copied to the corresponding qword element in the destina-tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.</p><p>DPPD follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4.7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-ated NaNs will have at least one NaN propagated to the destination.</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>If VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "DPPD.html", "tooltip": "Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand) with the packed double-precision floating-point values in the source (second operand) depending on a mask extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corre-sponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>."},
    "CPUID": {"html": "<p>The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction oper-ates the same in non-64-bit modes and 64-bit mode.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.<sup>1</sup> The instruction’s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well). For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers:</p><p>MOV EAX, 00H</p><p>CPUID</p><p>Table 3-17 shows information returned, depending on the initial value loaded into the EAX register. Table 3-18 shows the maximum CPUID input value recognized for each family of IA-32 processors on which CPUID is imple-mented.</p><p>Two types of information are returned: basic and extended function information. If a value entered for CPUID.EAX is higher than the maximum input value for basic or extended function for that processor then the data for the highest basic information leaf is returned. For example, using the Intel Core i7 processor, the following is true:</p><p>CPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *)</p><p>CPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *)</p><p>CPUID.EAX = 0BH (* Returns Extended Topology Enumeration leaf. *)</p><p>CPUID.EAX = 0CH (* INVALID: Returns the same information as CPUID.EAX = 0BH. *)</p><p>CPUID.EAX = 80000008H (* Returns linear/physical address size data. *)</p><p>CPUID.EAX = 8000000AH (* INVALID: Returns same information as CPUID.EAX = 0BH. *)</p><p>If a value entered for CPUID.EAX is less than or equal to the maximum input value and the leaf is not supported on that processor then 0 is returned in all the registers. For example, using the Intel Core i7 processor, the following is true:</p><p>CPUID.EAX = 07H (*Returns EAX=EBX=ECX=EDX=0. *)</p><p>When CPUID returns the highest basic leaf information as a result of an invalid input EAX value, any dependence on input ECX value in the basic leaf is honored.</p><p>CPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed.</p><p><strong>See also:</strong></p><p>'Serializing Instructions” in Chapter 8, 'Multiple-Processor Management,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p><p>1.</p><p>On Intel 64 processors, CPUID clears the high 32 bits of the RAX/RBX/RCX/RDX registers in all modes.</p><p>'Caching Translation Information” in Chapter 4, 'Paging,” in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 3A</em>.</p><h3>Table 3-17.  Information Returned by CPUID Instruction</h3><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p><p><strong>Information Provided about the Processor</strong></p><p><em>Basic CPUID Information</em></p><p>0H</p><p>EAX</p><p>Maximum Input Value for Basic CPUID Information (see Table 3-18)</p><p>EBX</p><p>'Genu”</p><p>ECX</p><p>'ntel”</p><p>EDX</p><p>'ineI”</p><p>01H</p><p>EAX</p><p>Version Information: Type, Family, Model, and Stepping ID (see Figure 3-5)</p><p>EBX</p><p>Bits 07-00: Brand Index Bits 15-08: CLFLUSH line size (Value ∗ 8 = cache line size in bytes) Bits 23-16: Maximum number of addressable IDs for logical processors in this physical package*. Bits 31-24: Initial APIC ID</p><p>ECX</p><p>Feature Information (see Figure 3-6 and Table 3-20)</p><p>EDX</p><p>Feature Information (see Figure 3-7 and Table 3-21)</p><p><strong>NOTES:</strong></p><p>*</p><p>The nearest power-of-2 integer that is not smaller than EBX[23:16] is the number of unique initial APIC IDs reserved for addressing different logical processors in a physical package. This field is only valid if CPUID.1.EDX.HTT[bit 28]= 1.</p><p>02H</p><p>EAX</p><p>Cache and TLB Information (see Table 3-22)</p><p>EBX</p><p>Cache and TLB Information</p><p>ECX</p><p>Cache and TLB Information</p><p>EDX</p><p>Cache and TLB Information</p><p>03H</p><p>EAX</p><p>Reserved.</p><p>EBX</p><p>Reserved.</p><p>ECX</p><p>Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</p><p>EDX</p><p>Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)</p><p><strong>NOTES:</strong></p><p>Processor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature.</p><p>See AP-485, <em>Intel Processor Identification and the CPUID Instruction</em> (Order Number 241618) for more information on PSN.</p><p>CPUID leaves &gt; 3 &lt; 80000000 are visible only when IA32_MISC_ENABLE.BOOT_NT4[bit 22] = 0 (default).</p><p><em>Deterministic Cache Parameters Leaf</em></p><p><strong>NOTES:</strong></p><p>04H</p><p>Leaf 04H output depends on the initial value in ECX.*</p><p>See also: 'INPUT EAX = 4: Returns Deterministic Cache Parameters for each level on page 3-182.</p><p>EAX</p><p>Bits 04-00: Cache Type Field</p><p>0 = Null - No more caches 1 = Data Cache 2 = Instruction Cache 3 = Unified Cache 4-31 = Reserved</p><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td></td><td><p>Bits 07-05: Cache Level (starts at 1) Bit 08: Self Initializing cache level (does not need SW initialization) Bit 09: Fully Associative cache</p><p>Bits 13-10: Reserved Bits 25-14: Maximum number of addressable IDs for logical processors sharing this cache**,</p><p>***</p><p>Bits 31-26: Maximum number of addressable IDs for processor cores in the physical package**,</p><p>****,</p><p>*****</p><p>EBX</p><p>Bits 11-00: L = System Coherency Line Size** Bits 21-12: P = Physical Line partitions** Bits 31-22: W = Ways of associativity**</p><p>ECX</p><p>Bits 31-00: S = Number of Sets**</p><p>EDX</p><p>Bit 0: Write-Back Invalidate/Invalidate</p><p>0 = WBINVD/INVD from threads sharing this cache acts upon lower level caches for threads sharing this cache. 1 = WBINVD/INVD is not guaranteed to act upon lower level caches of non-originating threads sharing this cache.</p><p>Bit 1: Cache Inclusiveness</p><p>0 = Cache is not inclusive of lower cache levels. 1 = Cache is inclusive of lower cache levels.</p><p>Bit 2: Complex Cache Indexing</p><p>0 = Direct mapped cache. 1 = A complex function is used to index the cache, potentially using all address bits.</p><p>Bits 31-03: Reserved = 0</p></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></table><p><strong>NOTES:</strong></p><p>* If ECX contains an invalid sub leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n+1 is invalid if sub-</p><p>leaf n returns EAX[4:0] as 0.</p><p>** Add one to the return value to get the result.</p><p>***The nearest power-of-2 integer that is not smaller than (1 + EAX[25:14]) is the number of unique ini-</p><p>tial APIC IDs reserved for addressing different logical processors sharing this cache</p><p>**** The nearest power-of-2 integer that is not smaller than (1 + EAX[31:26]) is the number of unique</p><p>Core_IDs reserved for addressing different processor cores in a physical package. Core ID is a subset of bits of the initial APIC ID.</p><p>***** The returned value is constant for valid initial values in ECX. Valid ECX values start from 0.</p><p><em>MONITOR/MWAIT Leaf</em></p><p>05H</p><p>EAX</p><p>Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity) Bits 31-16: Reserved = 0</p><p>EBX</p><p>Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity) Bits 31-16: Reserved = 0</p><p>ECX</p><p>Bit 00: Enumeration of Monitor-Mwait extensions (beyond EAX and EBX registers) supported</p><p>Bit 01: Supports treating interrupts as break-event for MWAIT, even when interrupts disabled</p><p>Bits 31 - 02: Reserved</p><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td></td><td><p>EDX</p><p>Bits 03 - 00: Number of C0* sub C-states supported using MWAIT Bits 07 - 04: Number of C1* sub C-states supported using MWAIT Bits 11 - 08: Number of C2* sub C-states supported using MWAIT Bits 15 - 12: Number of C3* sub C-states supported using MWAIT Bits 19 - 16: Number of C4* sub C-states supported using MWAIT Bits 23 - 20: Number of C5* sub C-states supported using MWAIT Bits 27 - 24: Number of C6* sub C-states supported using MWAIT Bits 31 - 28: Number of C7* sub C-states supported using MWAIT</p><p><strong>NOTE:</strong></p><p>*  The definition of C0 through C7 states for MWAIT extension are processor-specific C-states, not ACPI C-</p><p>states.</p></td></tr><tr><td></td><td><em>Thermal and Power Management Leaf</em></td></tr><tr><td>06H</td><td><p>EAX</p><p>Bit 00: Digital temperature sensor is supported if set Bit 01: Intel Turbo Boost Technology Available (see description of IA32_MISC_ENABLE[38]). Bit 02: ARAT. APIC-Timer-always-running feature is supported if set. Bit 03: Reserved Bit 04: PLN. Power limit notification controls are supported if set. Bit 05: ECMD. Clock modulation duty cycle extension is supported if set. Bit 06: PTM. Package thermal management is supported if set. Bit 07: HWP. HWP base registers (IA32_PM_ENALBE[bit 0], IA32_HWP_CAPABILITIES, IA32_HWP_REQUEST, IA32_HWP_STATUS) are supported if set. Bit 08: HWP_Notification. IA32_HWP_INTERRUPT MSR is supported if set. Bit 09: HWP_Activity_Window. IA32_HWP_REQUEST[bits 41:32] is supported if set. Bit 10: HWP_Energy_Performance_Preference. IA32_HWP_REQUEST[bits 31:24] is supported if set. Bit 11: HWP_Package_Level_Request. IA32_HWP_REQUEST_PKG MSR is supported if set. Bit 12: Reserved. Bit 13: HDC. HDC base registers IA32_PKG_HDC_CTL, IA32_PM_CTL1, IA32_THREAD_STALL MSRs are supported if set. Bits 31 - 15: Reserved</p><p>EBX</p><p>Bits 03 - 00: Number of Interrupt Thresholds in Digital Thermal Sensor Bits 31 - 04: Reserved</p><p>ECX</p><p>Bit 00: Hardware Coordination Feedback Capability (Presence of IA32_MPERF and IA32_APERF). The capability to provide a measure of delivered processor performance (since last reset of the counters), as a percentage of the expected processor performance when running at the TSC frequency. Bits 02 - 01: Reserved = 0 Bit 03: The processor supports performance-energy bias preference if CPUID.06H:ECX.SETBH[bit 3] is set and it also implies the presence of a new architectural MSR called IA32_ENERGY_PERF_BIAS (1B0H). Bits 31 - 04: Reserved = 0</p><p>EDX</p><p>Reserved = 0</p></td></tr><tr><td></td><td><em>Structured Extended Feature Flags Enumeration Leaf (Output depends on ECX input value)</em></td></tr><tr><td>07H</td><td><p>Sub-leaf 0 (Input ECX = 0). *</p><p>EAX</p><p>Bits 31-00: Reports the maximum input value for supported leaf 7 sub-leaves.</p></td></tr></table><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td></td><td><p>EBX</p><p>Bit 00: FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1. Bit 01: IA32_TSC_ADJUST MSR is supported if 1. Bit 02: Reserved Bit 03: BMI1 Bit 04: HLE Bit 05: AVX2 Bit 06: Reserved Bit 07: SMEP. Supports Supervisor-Mode Execution Prevention if 1. Bit 08: BMI2 Bit 09: Supports Enhanced REP MOVSB/STOSB if 1. Bit 10: INVPCID. If 1, supports INVPCID instruction for system software that manages process-context identifiers. Bit 11: RTM Bit 12: Supports Platform Quality of Service Monitoring (PQM) capability if 1. Bit 13: Deprecates FPU CS and FPU DS values if 1. Bit 14: Reserved. Bit 15: Supports Platform Quality of Service Enforcement (PQE) capability if 1. Bits 17:16: Reserved Bit 18: RDSEED Bit 19: ADX Bit 20: SMAP Bits 31:21: Reserved</p><p>ECX</p><p>Bit 00: PREFETCHWT1 Bit 31-01: Reserved</p><p>EDX</p><p>Reserved</p><p><strong>NOTE:</strong></p><p>* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf index n is invalid if n</p><p>exceeds the value that sub-leaf 0 returns in EAX.</p></td></tr><tr><td></td><td><em>Direct Cache Access Information Leaf</em></td></tr><tr><td>09H</td><td><p>Value of bits [31:0] of IA32_PLATFORM_DCA_CAP MSR (address 1F8H)</p><p>EAX</p><p>Reserved</p><p>EBX</p><p>Reserved</p><p>ECX</p><p>Reserved</p><p>EDX</p></td></tr><tr><td></td><td><em>Architectural Performance Monitoring Leaf</em></td></tr><tr><td>0AH</td><td><p>EAX</p><p>Bits 07 - 00: Version ID of architectural performance monitoring Bits 15- 08: Number of general-purpose performance monitoring counter per logical processor Bits 23 - 16: Bit width of general-purpose, performance monitoring counter Bits 31 - 24: Length of EBX bit vector to enumerate architectural performance monitoring events</p><p>EBX</p><p>Bit 00: Core cycle event not available if 1 Bit 01: Instruction retired event not available if 1 Bit 02: Reference cycles event not available if 1 Bit 03: Last-level cache reference event not available if 1 Bit 04: Last-level cache misses event not available if 1 Bit 05: Branch instruction retired event not available if 1 Bit 06: Branch mispredict retired event not available if 1 Bits 31- 07: Reserved = 0</p><p>ECX</p><p>Reserved = 0</p></td></tr></table><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td></td><td><p>EDX</p><p>Bits 04 - 00: Number of fixed-function performance counters (if Version ID &gt; 1) Bits 12- 05: Bit width of fixed-function performance counters (if Version ID &gt; 1) Reserved = 0</p></td></tr><tr><td></td><td><em>Extended Topology Enumeration Leaf</em></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></table><p><strong>NOTES:</strong></p><p>0BH</p><p>Most of Leaf 0BH output depends on the initial value in ECX.</p><p>The EDX output of leaf 0BH is always valid and does not vary with input value in ECX.</p><p>Output value in ECX[7:0] always equals input value in ECX[7:0].</p><p>For sub-leaves that return an invalid level-type of 0 in ECX[15:8]; EAX and EBX will return 0.</p><p>  If an input value n in ECX returns the invalid level-type of 0 in ECX[15:8], other input values with ECX &gt;</p><p>n also return 0 in ECX[15:8].</p><p>EAX</p><p>Bits 04-00: Number of bits to shift right on x2APIC ID to get a unique topology ID of the next level type*. All logical processors with the same next level ID share current level. Bits 31-05: Reserved.</p><p>EBX</p><p>Bits 15 - 00: Number of logical processors at this level type. The number reflects configuration as shipped by Intel**. Bits 31- 16: Reserved.</p><p>ECX</p><p>Bits 07 - 00: Level number. Same value in ECX input Bits 15 - 08: Level type***. Bits 31 - 16:: Reserved.</p><p>EDX</p><p>Bits 31- 00: x2APIC ID the current logical processor.</p><p><strong>NOTES: * Software should use this field (EAX[4:0]) to enumerate processor topology of the system.</strong></p><p>** Software must not use EBX[15:0] to enumerate processor topology of the system. This value in this field (EBX[15:0]) is only intended for display/diagnostic purposes. The actual number of logical processors available to BIOS/OS/Applications may be different from the value of EBX[15:0], depending on software and platform hardware configurations.</p><p>*** The value of the 'level type” field is not related to level numbers in any way, higher 'level type” val-ues do not mean higher levels. Level type field has the following encoding: 0 : invalid 1 : SMT 2 : Core 3-255 : Reserved</p><p><em>Processor Extended State Enumeration Main Leaf (EAX = 0DH, ECX = 0)</em></p><p><strong>NOTES:</strong></p><p>0DH</p><p>Leaf 0DH main leaf (ECX = 0).</p><p>EAX</p><p>Bits 31-00: Reports the valid bit fields of the lower 32 bits of XCR0. If a bit is 0, the corresponding bit field in XCR0 is reserved. Bit 00: legacy x87 Bit 01: 128-bit SSE Bit 02: 256-bit AVX Bits 31- 03: Reserved</p><p>EBX</p><p>Bits 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) required by enabled features in XCR0. May be different than ECX if some features at the end of the XSAVE save area are not enabled.</p><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td></td><td><p>ECX</p><p>Bit 31-00: Maximum size (bytes, from the beginning of the XSAVE/XRSTOR save area) of the XSAVE/XRSTOR save area required by all supported features in the processor, i.e all the valid bit fields in XCR0.</p><p>EDX</p><p>Bit 31-00: Reports the valid bit fields of the upper 32 bits of XCR0. If a bit is 0, the corresponding bit field in XCR0 is reserved.</p></td></tr><tr><td></td><td><em>Processor Extended State Enumeration Sub-leaf (EAX = 0DH, ECX = 1)</em></td></tr><tr><td>0DH</td><td><p>EAX</p><p>Bits 31-04: Reserved</p><p>Bit 00: XSAVEOPT is available</p><p>Bit 01: Supports XSAVEC and the compacted form of XRSTOR if set</p><p>Bit 02: Supports XGETBV with ECX = 1 if set</p><p>Bit 03: Supports XSAVES/XRSTORS and IA32_XSS if set</p><p>EBX</p><p>Bits 31-00: The size in bytes of the XSAVE area containing all states enabled by XCRO | IA32_XSS.</p><p>ECX</p><p>Bits 31-00: Reports the valid bit fields of the lower 32 bits of IA32_XSS. If a bit is 0, the corresponding bit field in IA32_XSS is reserved.</p><p>Bits 07-00: Reserved</p><p>Bit 08: IA32_XSS[bit 8] is supported if 1</p><p>Bits 31-09: Reserved</p><p>EDX</p><p>Bits 31-00: Reports the valid bit fields of the upper 32 bits of IA32_XSS. If a bit is 0, the corresponding bit field in IA32_XSS is reserved.</p><p>Bits 31-00: Reserved</p></td></tr><tr><td></td><td><em>Processor Extended State Enumeration Sub-leaves (EAX = 0DH, ECX = n, n &gt; 1)</em></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></table><p><strong>NOTES:</strong></p><p>0DH</p><p>Leaf 0DH output depends on the initial value in ECX.</p><p>Each valid sub-leaf index maps to a valid bit in either the XCR0 register or the IA32_XSS MSR starting at bit position 2.</p><p>* If ECX contains an invalid sub-leaf index, EAX/EBX/ECX/EDX return 0. Sub-leaf n (0 ≤ n ≤ 31) is invalid</p><p>if sub-leaf 0 returns 0 in EAX[n] and sub-leaf 1 returns 0 in ECX[n]. Sub-leaf n (32 ≤ n ≤ 63) is invalid if sub-leaf 0 returns 0 in EDX[n-32] and sub-leaf 1 returns 0 in EDX[n-32].</p><p>EAX</p><p>Bits 31-0: The size in bytes (from the offset specified in EBX) of the save area for an extended state fea-ture associated with a valid sub-leaf index, <em>n</em>.</p><p>EBX</p><p>Bits 31-0: The offset in bytes of this extended state component’s save area from the beginning of the XSAVE/XRSTOR area. This field reports 0 if the sub-leaf index, n, does not map to a valid bit in the XCR0 register*.</p><p>ECX</p><p>Bit 0 is set if the sub-leaf index, n, maps to a valid bit in the IA32_XSS MSR and bit 0 is clear if n maps to a valid bit in XCR0. Bits 31-1 are reserved. This field reports 0 if the sub-leaf index, n, is invalid*.</p><p>EDX</p><p>This field reports 0 if the sub-leaf index, <em>n</em>, is invalid*; otherwise it is reserved.</p><p><em>Platform QoS Monitoring Enumeration Sub-leaf (EAX = 0FH, ECX = 0)</em></p><p><strong>NOTES:</strong></p><p>0FH</p><p>Leaf 0FH output depends on the initial value in ECX.</p><p>Sub-leaf index 0 reports valid resource type starting at bit position 1 of EDX</p><p>EAX</p><p>Reserved.</p><p>EBX</p><p>Bits 31-0: Maximum range (zero-based) of RMID within this physical processor of all types.</p><p>ECX</p><p>Reserved.</p><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td></td><td><p>EDX</p><p>Bit 00: Reserved. Bit 01: Supports L3 Cache QoS Monitoring if 1. Bits 31:02: Reserved</p></td></tr><tr><td></td><td><em>L3 Cache QoS Monitoring Capability Enumeration Sub-leaf (EAX = 0FH, ECX = 1)</em></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></table><p><strong>NOTES:</strong></p><p>0FH</p><p>Leaf 0FH output depends on the initial value in ECX.</p><p>EAX</p><p>Reserved.</p><p>EBX</p><p>Bits 31-0: Conversion factor from reported IA32_QM_CTR value to occupancy metric (bytes).</p><p>ECX</p><p>Maximum range (zero-based) of RMID of this resource type.</p><p>EDX</p><p>Bit 00: Supports L3 occupancy monitoring if 1. Bits 31:01: Reserved</p><p><em>Platform QoS Enforcement Enumeration Sub-leaf (EAX = 10H, ECX = 0)</em></p><p><strong>NOTES:</strong></p><p>10H</p><p>Leaf 10H output depends on the initial value in ECX.</p><p>Sub-leaf index 0 reports valid resource identification (ResID) starting at bit position 1 of EDX</p><p>EAX</p><p>Reserved.</p><p>EBX</p><p>Bit 00: Reserved. Bit 01: Supports L3 Cache QoS Enforcement if 1. Bits 31:02: Reserved</p><p>ECX</p><p>Reserved.</p><p>EDX</p><p>Reserved.</p><p><em>L3 Cache QoS Enforcement Enumeration Sub-leaf (EAX = 10H, ECX = ResID =1)</em></p><p><strong>NOTES:</strong></p><p>10H</p><p>Leaf 10H output depends on the initial value in ECX.</p><p>EAX</p><p>Bits 4:0: Length of the capacity bit mask for the corresponding ResID. Bits 31:05: Reserved</p><p>EBX</p><p>Bits 31-0: Bit-granular map of isolation/contention of allocation units.</p><p>ECX</p><p>Bit 00: Reserved. Bit 01: Updates of COS should be infrequent if 1. Bits 31:02: Reserved</p><p>EDX</p><p>Bits 15:0: Highest COS number supported for this ResID. Bits 31:16: Reserved</p><p><em>Intel Processor Trace Enumeration Main Leaf (EAX = 14H, ECX = 0)</em></p><p><strong>NOTES:</strong></p><p>14H</p><p>Leaf 14H main leaf (ECX = 0).</p><p>EAX</p><p>Bits 31-0: Reports the maximum number sub-leaves that are supported in leaf 14H.</p><p>EBX</p><p>Bit 00: If 1, Indicates that IA32_RTIT_CTL.CR3Filter can be set to 1, and that IA32_RTIT_CR3_MATCH MSR can be accessed. Bits 31- 01: Reserved</p><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td></td><td><p>ECX</p><p>Bit 00: If 1, Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1, hence utilizing the ToPA output scheme; IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be accessed. Bit 01: If 1, ToPA tables can hold any number of output entries, up to the maximum allowed by the Mas-kOrTableOffset field of IA32_RTIT_OUTPUT_MASK_PTRS. Bit 30:02: Reserved Bit 31: If 1, Generated packets which contain IP payloads have LIP values, which include the CS base com-ponent.</p><p>EDX</p><p>Bits 31- 00: Reserved</p></td></tr><tr><td></td><td><em>Unimplemented CPUID Leaf Functions</em></td></tr><tr><td><p>40000000H</p><p>-</p><p>4FFFFFFFH</p></td><td>Invalid. No existing or future CPU will return processor identification or feature information if the initial EAX value is in the range 40000000H to 4FFFFFFFH.</td></tr><tr><td></td><td><em>Extended Function CPUID Information</em></td></tr><tr><td>80000000H</td><td><p>EAX</p><p>Maximum Input Value for Extended Function CPUID Information (see Table 3-18).</p><p>EBX</p><p>Reserved</p><p>ECX</p><p>Reserved</p><p>EDX</p><p>Reserved</p></td></tr><tr><td>80000001H</td><td><p>EAX</p><p>Extended Processor Signature and Feature Bits.</p><p>EBX</p><p>Reserved</p><p>ECX</p><p>Bit 00: LAHF/SAHF available in 64-bit mode Bits 04-01 Reserved Bit 05: LZCNT Bits 07-06 Reserved Bit 08: PREFETCHW Bits 31-09 Reserved</p><p>EDX</p><p>Bits 10-00: Reserved Bit 11: SYSCALL/SYSRET available in 64-bit mode Bits 19-12: Reserved = 0 Bit 20: Execute Disable Bit available Bits 25-21: Reserved = 0 Bit 26: 1-GByte pages are available if 1 Bit 27: RDTSCP and IA32_TSC_AUX are available if 1 Bits 28: Reserved = 0</p><p>Bit 29: Intel<em><sup>®</sup></em> 64 Architecture available if 1 Bits 31-30: Reserved = 0</p></td></tr><tr><td>80000002H</td><td><p>EAX</p><p>Processor Brand String</p><p>EBX</p><p>Processor Brand String Continued</p><p>ECX</p><p>Processor Brand String Continued</p><p>EDX</p><p>Processor Brand String Continued</p></td></tr><tr><td>80000003H</td><td><p>EAX</p><p>Processor Brand String Continued</p><p>EBX</p><p>Processor Brand String Continued</p><p>ECX</p><p>Processor Brand String Continued</p><p>EDX</p><p>Processor Brand String Continued</p></td></tr></table><h3>Table 3-17.  Information Returned by CPUID Instruction (Contd.)</h3><table><tr><td><p><strong>Initial EAX</strong></p><p><strong>Value</strong></p></td><th>Information Provided about the Processor</th></tr><tr><td>80000004H</td><td><p>EAX</p><p>Processor Brand String Continued</p><p>EBX</p><p>Processor Brand String Continued</p><p>ECX</p><p>Processor Brand String Continued</p><p>EDX</p><p>Processor Brand String Continued</p></td></tr><tr><td>80000005H</td><td><p>EAX</p><p>Reserved = 0</p><p>EBX</p><p>Reserved = 0</p><p>ECX</p><p>Reserved = 0</p><p>EDX</p><p>Reserved = 0</p></td></tr><tr><td>80000006H</td><td><p>EAX</p><p>Reserved = 0</p><p>EBX</p><p>Reserved = 0</p><p>ECX</p><p>Bits 07-00: Cache Line size in bytes Bits 11-08: Reserved Bits 15-12: L2 Associativity field * Bits 31-16: Cache size in 1K units</p><p>EDX</p><p>Reserved = 0</p></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></table><p><strong>NOTES:</strong></p><p>* L2 associativity field encodings:</p><p>00H - Disabled 01H - Direct mapped 02H - 2-way 04H - 4-way 06H - 8-way 08H - 16-way 0FH - Fully associative</p><p>80000007H</p><p>EAX</p><p>Reserved = 0</p><p>EBX</p><p>Reserved = 0</p><p>ECX</p><p>Reserved = 0</p><p>EDX</p><p>Bits 07-00: Reserved = 0 Bit 08: Invariant TSC available if 1 Bits 31-09: Reserved = 0</p><p>80000008H</p><p>EAX</p><p>Linear/Physical Address size Bits 07-00: #Physical Address Bits* Bits 15-8: #Linear Address Bits Bits 31-16: Reserved = 0</p><p>EBX</p><p>Reserved = 0</p><p>ECX</p><p>Reserved = 0</p><p>EDX</p><p>Reserved = 0</p><p><strong>NOTES:</strong></p><p>*</p><p>If CPUID.80000008H:EAX[7:0] is supported, the maximum physical address number supported should come from this field.</p></span>", "url": "CPUID.html", "tooltip": "The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction oper-ates the same in non-64-bit modes and 64-bit mode."},
    "MOVSD": {"html": "<p>MOVSD moves a scalar double-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 64-bit memory locations. This instruction can be used to move a double-precision floating-point value to and from the low quad-word of an XMM register and a 64-bit memory location, or to move a double-precision floating-point value between the low quadwords of two XMM registers. The instruction cannot be used to transfer data between memory loca-tions.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>For non-VEX encoded instruction syntax and when the source and destination operands are XMM registers, the high quadword of the destination operand remains unchanged. When the source operand is a memory location and destination operand is an XMM registers, the high quadword of the destination operand is cleared to all 0s.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: For the 'VMOVSD m64, xmm1” (memory store form) instruction version, VEX.vvvv is reserved and must be 1111b, otherwise instruction will #UD.</p><p>Note: For the 'VMOVSD xmm1, m64” (memory load form) instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.</p><p>VEX encoded instruction syntax supports two source operands and a destination operand if ModR/M.mod field is 11B. VEX.vvvv is used to encode the first source operand (the second operand). The low 128 bits of the destination operand stores the result of merging the low quadword of the second source operand with the quad word in bits 127:64 of the first source operand. The upper bits of the destination operand are cleared.</p></span>", "url": "MOVSD.html", "tooltip": "MOVSD moves a scalar double-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 64-bit memory locations. This instruction can be used to move a double-precision floating-point value to and from the low quad-word of an XMM register and a 64-bit memory location, or to move a double-precision floating-point value between the low quadwords of two XMM registers. The instruction cannot be used to transfer data between memory loca-tions."},
    "PSRLDQ": {"html": "<p>Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source and destination operands are the same. Bits (VLMAX-1:128) of the corre-sponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The source and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The count operand applies to both the low and high 128-bit lanes.</p><p>Note: VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSRLDQ.html", "tooltip": "Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate."},
    "ADD": {"html": "<p>Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer oper-ands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "ADD.html", "tooltip": "Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format."},
    "VPERMILPD": {"html": "<p>Permute double-precision floating-point values in the first source operand (second operand) using 8-bit control fields in the low bytes of the second source operand (third operand) and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>SRC1</p><p>X2..X3</p><p>X2..X3</p><p>X0..X1</p><p>DEST</p><h3>Figure 4-38.  VPERMILPD operation</h3><p>There is one control byte per destination double-precision element. Each control byte is aligned with the low 8 bits of the corresponding double-precision destination element. Each control byte contains a 1-bit select field (see Figure 4-39) that determines which of the source elements are selected. Source elements are restricted to lie in the same source 128-bit region as the destination.</p><p>Bit</p><p>66</p><p>1</p><p>194 193</p><p>65</p><p>2</p><p>127</p><p>255</p><p>63</p><p><strong>. . .</strong></p><p>d</p><p>d</p><p>d</p><p>ignored</p><p>ignored</p><p>ignored</p><p>sel</p><p>sel</p><p>sel</p><p>e</p><p>e</p><p>e</p><p>r</p><p>r</p><p>r</p><p>o</p><p>o</p><p>o</p><p>n</p><p>n</p><p>n</p><p>g</p><p>g</p><p>g</p><p>i</p><p>i</p><p>i</p><p>Control Field 4</p><p>Control Field 2</p><p>Control Field1</p><h3>Figure 4-39.  VPERMILPD Shuffle Control</h3><p>(immediate control version)</p><p>Permute double-precision floating-point values in the first source operand (second operand) using two, 1-bit control fields in the low 2 bits of the 8-bit immediate and store results in the destination operand (first operand). The source operand is a YMM register or 256-bit memory location and the destination operand is a YMM register.</p><p>Note: For the VEX.128.66.0F3A 05 instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruc-tion will #UD.</p><p>Note: For the VEX.256.66.0F3A 05 instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruc-tion will #UD.</p></span>", "url": "VPERMILPD.html", "tooltip": "Permute double-precision floating-point values in the first source operand (second operand) using 8-bit control fields in the low bytes of the second source operand (third operand) and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register."},
    "MOVNTQ": {"html": "<p>Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX tech-nology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The destination operand is a 64-bit memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see 'Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple proces-sors might use different memory types to read/write the destination memory locations.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "MOVNTQ.html", "tooltip": "Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX tech-nology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The destination operand is a 64-bit memory location."},
    "PUNPCKLBW": {"html": "<p>Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destina-tion operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-18 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='112.380000 672538.020010 379.199990 99.360000' height='149.04'><text y='672560.507684' x='128.5213' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.920792'>SRC</text><text y='672560.867584' x='456.3613' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='672623.387684' x='255.3012' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='672612.3' x='278.88' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.0'></rect><rect y='672549.6' x='310.08' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.0'></rect><rect y='672549.66' x='147.84' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.0'></rect><path style='stroke:black' d='M263.880000,672567.600000 L263.700000,672567.540000 L263.520000,672567.960000 L263.700000,672568.020000 '></path><path style='stroke:black' d='M263.880000,672567.600000 L263.700000,672568.020000 L352.140000,672609.240000 L352.320000,672608.820000 '></path><path style='stroke:black' d='M426.840000,672568.080000 L427.020000,672567.960000 L426.720000,672567.600000 L426.540000,672567.720000 '></path><path style='stroke:black' d='M445.020000,672568.080000 L445.140000,672567.900000 L444.780000,672567.600000 L444.660000,672567.780000 '></path><path style='stroke:black' d='M281.580000,672567.720000 L281.400000,672567.660000 L281.220000,672568.080000 L281.400000,672568.140000 '></path><path style='stroke:black' d='M281.580000,672567.720000 L281.400000,672568.140000 L388.860000,672609.720000 L389.040000,672609.300000 '></path><path style='stroke:black' d='M426.840000,672568.080000 L426.540000,672567.720000 L383.460000,672606.900000 L383.760000,672607.260000 '></path><path style='stroke:black' d='M445.020000,672568.080000 L444.660000,672567.780000 L417.060000,672605.880000 L417.420000,672606.180000 '></path><path style='stroke:black' d='M246.780000,672568.140000 L246.600000,672568.020000 L246.360000,672568.440000 L246.540000,672568.560000 '></path><path style='stroke:black' d='M229.680000,672568.260000 L229.500000,672568.140000 L229.200000,672568.500000 L229.380000,672568.620000 '></path><path style='stroke:black' d='M246.780000,672568.140000 L246.540000,672568.560000 L316.500000,672609.180000 L316.740000,672608.760000 '></path><path style='stroke:black' d='M389.280000,672568.680000 L389.460000,672568.560000 L389.220000,672568.140000 L389.040000,672568.260000 '></path><path style='stroke:black' d='M408.000000,672568.680000 L408.180000,672568.560000 L407.940000,672568.140000 L407.760000,672568.260000 '></path><path style='stroke:black' d='M229.680000,672568.260000 L229.380000,672568.620000 L281.100000,672607.800000 L281.400000,672607.440000 '></path><path style='stroke:black' d='M389.280000,672568.680000 L389.040000,672568.260000 L312.240000,672608.520000 L312.480000,672608.940000 '></path><path style='stroke:black' d='M408.000000,672568.680000 L407.760000,672568.260000 L347.760000,672607.860000 L348.000000,672608.280000 '></path><path style='stroke:black' d='M416.760000,672606.420000 L418.320000,672606.840000 L419.340000,672607.080000 L418.500000,672607.740000 L414.060000,672611.220000 L412.680000,672612.300000 L413.280000,672610.680000 L415.200000,672605.400000 L415.560000,672604.380000 L416.100000,672605.220000 L416.160000,672605.700000 L414.240000,672610.980000 L413.280000,672610.680000 L413.460000,672610.440000 L417.900000,672606.960000 L418.500000,672607.740000 L418.080000,672607.800000 L416.520000,672607.380000 '></path><path style='stroke:black' d='M383.040000,672607.320000 L385.440000,672608.520000 L384.420000,672609.000000 L379.440000,672611.520000 L377.940000,672612.240000 L378.780000,672610.800000 L381.720000,672606.000000 L382.320000,672605.100000 L382.680000,672606.060000 L382.620000,672606.540000 L379.680000,672611.340000 L378.780000,672610.800000 L379.020000,672610.620000 L384.000000,672608.100000 L384.420000,672609.000000 L384.000000,672609.000000 L382.560000,672608.280000 '></path><path style='stroke:black' d='M416.100000,672605.220000 L417.060000,672606.600000 L416.520000,672607.380000 L416.340000,672607.320000 L416.220000,672607.200000 L415.260000,672605.820000 '></path><path style='stroke:black' d='M281.580000,672608.100000 L282.060000,672606.540000 L282.360000,672605.520000 L282.960000,672606.360000 L286.320000,672610.860000 L287.400000,672612.300000 L285.780000,672611.640000 L280.560000,672609.600000 L279.540000,672609.240000 L280.380000,672608.700000 L280.860000,672608.640000 L286.080000,672610.680000 L285.780000,672611.640000 L285.540000,672611.460000 L282.180000,672606.960000 L282.960000,672606.360000 L283.020000,672606.780000 L282.540000,672608.340000 '></path><path style='stroke:black' d='M416.640000,672606.900000 L418.200000,672607.320000 L413.760000,672610.800000 L415.680000,672605.520000 '></path><path style='stroke:black' d='M347.280000,672608.160000 L348.600000,672609.180000 L349.440000,672609.780000 L348.420000,672610.080000 L343.080000,672611.700000 L341.340000,672612.300000 L342.540000,672610.920000 L346.200000,672606.720000 L346.920000,672605.880000 L347.100000,672606.900000 L346.980000,672607.380000 L343.320000,672611.580000 L342.540000,672610.920000 L342.780000,672610.740000 L348.120000,672609.120000 L348.420000,672610.080000 L348.000000,672610.020000 L346.680000,672609.000000 '></path><path style='stroke:black' d='M417.420000,672606.120000 L417.060000,672605.880000 L416.460000,672606.780000 L416.820000,672607.020000 '></path><path style='stroke:black' d='M417.420000,672606.180000 L417.300000,672606.360000 L416.940000,672606.060000 L417.060000,672605.880000 '></path><path style='stroke:black' d='M382.680000,672606.060000 L383.280000,672607.620000 L382.560000,672608.280000 L382.380000,672608.160000 L382.320000,672607.980000 L381.720000,672606.420000 '></path><path style='stroke:black' d='M382.800000,672607.800000 L384.240000,672608.520000 L379.260000,672611.040000 L382.200000,672606.240000 '></path><path style='stroke:black' d='M311.820000,672608.820000 L313.020000,672609.900000 L313.800000,672610.560000 L312.720000,672610.740000 L307.260000,672611.880000 L305.580000,672612.240000 L306.840000,672611.040000 L310.860000,672607.200000 L311.580000,672606.480000 L311.700000,672607.500000 L311.520000,672607.920000 L307.500000,672611.760000 L306.840000,672611.040000 L307.080000,672610.920000 L312.540000,672609.780000 L312.720000,672610.740000 L312.300000,672610.620000 L311.100000,672609.540000 '></path><path style='stroke:black' d='M282.060000,672608.220000 L282.540000,672606.660000 L285.900000,672611.160000 L280.680000,672609.120000 '></path><path style='stroke:black' d='M352.620000,672609.360000 L352.740000,672607.740000 L352.860000,672606.720000 L353.640000,672607.440000 L357.840000,672611.100000 L359.100000,672612.240000 L357.420000,672612.000000 L351.900000,672611.160000 L350.880000,672610.980000 L351.600000,672610.260000 L352.080000,672610.140000 L357.600000,672610.980000 L357.420000,672612.000000 L357.180000,672611.820000 L352.980000,672608.160000 L353.640000,672607.440000 L353.820000,672607.860000 L353.700000,672609.480000 '></path><path style='stroke:black' d='M317.040000,672609.420000 L317.340000,672607.800000 L317.460000,672606.780000 L318.240000,672607.560000 L322.080000,672611.580000 L323.280000,672612.840000 L321.600000,672612.360000 L316.200000,672610.980000 L315.120000,672610.740000 L315.960000,672610.080000 L316.380000,672610.020000 L321.780000,672611.400000 L321.600000,672612.360000 L321.300000,672612.240000 L317.460000,672608.220000 L318.240000,672607.560000 L318.300000,672607.920000 L318.000000,672609.540000 '></path><path style='stroke:black' d='M347.100000,672606.900000 L347.460000,672608.460000 L346.680000,672609.000000 L346.500000,672608.880000 L346.500000,672608.700000 L346.140000,672607.140000 '></path><path style='stroke:black' d='M383.760000,672607.260000 L383.400000,672606.900000 L382.620000,672607.620000 L382.980000,672607.980000 '></path><path style='stroke:black' d='M383.760000,672607.260000 L383.580000,672607.380000 L383.280000,672607.020000 L383.460000,672606.900000 '></path><path style='stroke:black' d='M346.980000,672608.580000 L348.300000,672609.600000 L342.960000,672611.220000 L346.620000,672607.020000 '></path><path style='stroke:black' d='M389.400000,672609.840000 L389.400000,672607.140000 L390.300000,672607.860000 L394.800000,672611.220000 L396.120000,672612.240000 L394.440000,672612.120000 L388.860000,672611.640000 L387.780000,672611.520000 L388.500000,672610.740000 L388.920000,672610.620000 L394.500000,672611.100000 L394.440000,672612.120000 L394.140000,672612.000000 L389.640000,672608.640000 L390.300000,672607.860000 L390.480000,672608.220000 L390.480000,672609.840000 '></path><path style='stroke:black' d='M281.340000,672607.440000 L281.100000,672607.800000 L281.940000,672608.400000 L282.180000,672608.040000 '></path><path style='stroke:black' d='M281.400000,672607.440000 L281.580000,672607.560000 L281.280000,672607.920000 L281.100000,672607.800000 '></path><path style='stroke:black' d='M311.700000,672607.500000 L311.940000,672609.120000 L311.100000,672609.540000 L310.980000,672609.420000 L310.980000,672609.240000 L310.740000,672607.620000 '></path><path style='stroke:black' d='M311.460000,672609.180000 L312.660000,672610.260000 L307.200000,672611.400000 L311.220000,672607.560000 '></path><path style='stroke:black' d='M280.380000,672608.700000 L281.760000,672607.800000 L282.540000,672608.340000 L282.480000,672608.520000 L282.360000,672608.640000 L280.980000,672609.540000 '></path><path style='stroke:black' d='M353.160000,672609.420000 L353.280000,672607.800000 L357.480000,672611.460000 L351.960000,672610.620000 '></path><path style='stroke:black' d='M317.520000,672609.480000 L317.820000,672607.860000 L321.660000,672611.880000 L316.260000,672610.500000 '></path><path style='stroke:black' d='M348.000000,672608.220000 L347.760000,672607.860000 L346.860000,672608.400000 L347.100000,672608.760000 '></path><path style='stroke:black' d='M348.000000,672608.280000 L347.820000,672608.400000 L347.580000,672607.980000 L347.760000,672607.860000 '></path><path style='stroke:black' d='M389.940000,672609.840000 L389.940000,672608.220000 L394.440000,672611.580000 L388.860000,672611.100000 '></path><path style='stroke:black' d='M312.480000,672608.940000 L312.240000,672608.460000 L311.340000,672608.940000 L311.580000,672609.420000 '></path><path style='stroke:black' d='M312.480000,672608.940000 L312.300000,672609.060000 L312.060000,672608.640000 L312.240000,672608.520000 '></path><path style='stroke:black' d='M316.740000,672608.760000 L316.500000,672609.120000 L317.400000,672609.660000 L317.640000,672609.300000 '></path><path style='stroke:black' d='M316.740000,672608.760000 L316.920000,672608.880000 L316.680000,672609.300000 L316.500000,672609.180000 '></path><path style='stroke:black' d='M352.320000,672608.760000 L352.080000,672609.240000 L353.040000,672609.660000 L353.280000,672609.180000 '></path><path style='stroke:black' d='M352.320000,672608.820000 L352.500000,672608.880000 L352.320000,672609.300000 L352.140000,672609.240000 '></path><path style='stroke:black' d='M315.960000,672610.080000 L317.220000,672609.060000 L318.000000,672609.540000 L318.000000,672609.780000 L317.820000,672609.900000 L316.560000,672610.920000 '></path><path style='stroke:black' d='M351.600000,672610.260000 L352.800000,672609.060000 L353.700000,672609.480000 L353.640000,672609.660000 L352.320000,672610.980000 '></path><path style='stroke:black' d='M388.980000,672609.240000 L388.860000,672609.720000 L389.880000,672610.080000 L390.000000,672609.600000 '></path><path style='stroke:black' d='M389.040000,672609.300000 L389.220000,672609.360000 L389.040000,672609.780000 L388.860000,672609.720000 '></path><path style='stroke:black' d='M388.500000,672610.740000 L389.580000,672609.480000 L390.480000,672609.840000 L390.420000,672610.020000 L390.300000,672610.200000 L389.220000,672611.460000 '></path><text y='672623.147484' x='283.1402' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='672623.147484' x='300.8403' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X3</text><text y='672623.147484' x='318.478832' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='672623.147484' x='337.256232' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>X2</text><text y='672623.147484' x='354.296264' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='672623.147484' x='372.539004' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>X1</text><text y='672623.147484' x='389.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text><text y='672623.147484' x='408.84' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='672560.807684' x='314.8815' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X7</text><text y='672560.807684' x='331.977852' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>X6</text><text y='672560.807684' x='351.244764' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X5</text><text y='672560.807684' x='368.2812' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X4</text><text y='672560.867584' x='386.1604' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='672560.867584' x='403.256752' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='672560.867584' x='422.515684' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='672560.867584' x='439.5602' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='672561.467684' x='151.9817' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>Y7</text><text y='672561.467684' x='169.078052' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y6</text><text y='672561.467684' x='188.344964' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>Y5</text><text y='672561.467684' x='205.3815' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y4</text><text y='672562.067784' x='223.8009' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='672562.067784' x='240.897252' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='672562.067784' x='260.156184' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.713256'>Y1</text><text y='672562.067784' x='277.2007' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text></svg><h3>Figure 4-18.  PUNPCKLBW Instruction Operation Using 64-bit Operands</h3><p>31</p><p>0</p><p>255</p><p>255</p><p>31</p><p>0</p><table class='exception-table'><tr><td>X7</td><td>X6</td><td>X5</td><td>X4</td><td>X3</td><td>X2</td><td>X1</td><td>X0</td></tr></table><table class='exception-table'><tr><td>Y7</td><td>Y6</td><td>Y5</td><td>Y4</td><td>Y3</td><td>Y2</td><td>Y1</td><td>Y0</td></tr></table><p>SRC</p><p>255</p><p>0</p><table class='exception-table'><tr><td>Y5</td><td>X5</td><td>Y4</td><td>X4</td><td>Y1</td><td>X1</td><td>Y0</td><td>X0</td></tr></table><p>DEST</p><h3>Figure 4-19.  256-bit VPUNPCKLDQ Instruction Operation</h3><p>When the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.</p><p>The (V)PUNPCKLBW instruction interleaves the low-order bytes of the source and destination operands, the (V)PUNPCKLWD instruction interleaves the low-order words of the source and destination operands, the (V)PUNPCKLDQ instruction interleaves the low-order doubleword (or doublewords) of the source and destination operands, and the (V)PUNPCKLQDQ instruction interleaves the low-order quadwords of the source and destination operands.</p><p>These instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the (V)PUNPCKLBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKLWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE versions: The source operand can be an MMX technology register or a 32-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html", "tooltip": "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destina-tion operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-18 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored."},
    "CMPXCHG8B": {"html": "<p>Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)</p><p>In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the beginning of this section for encoding data and limits. For information on the CPUID flag that indicates CMPXCHG16B, see page 3-175.</p></span>", "url": "CMPXCHG8B:CMPXCHG16B.html", "tooltip": "Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value."},
    "PSIGNB": {"html": "<p>(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corre-sponding data element in the destination operand is set to zero.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><p>Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access addi-tional registers.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.</p><p>VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location.</p></span>", "url": "PSIGNB:PSIGNW:PSIGND.html", "tooltip": "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corre-sponding data element in the destination operand is set to zero."},
    "FLDENV": {"html": "<p>Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand spec-ifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, show the layout in memory of the loaded environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.</p><p>The FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.</p><p>If one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled 'Software Exception Handling” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>). To avoid generating exceptions when loading a new environment, clear all the exception flags in the FPU status word that is being loaded.</p><p>If a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by the fault handler may be different than the state being loaded from memory. In such situations, the fault handler should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then complete the loading of the x87 FPU registers with no resulting context inconsistency.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FLDENV.html", "tooltip": "Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand spec-ifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction."},
    "FABS": {"html": "<p>Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results obtained when creating the absolute value of various classes of numbers.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-27.  Results Obtained from FABS</h3><table><tr><th>ST(0) SRC</th><th>ST(0) DEST</th></tr><tr><td>− ∞</td><td>+ ∞</td></tr><tr><td>− F</td><td>+ F</td></tr><tr><td>− 0</td><td>+ 0</td></tr><tr><td>+ 0</td><td>+ 0</td></tr><tr><td>+ F</td><td>+ F</td></tr><tr><td>+ ∞</td><td>+ ∞</td></tr><tr><td>NaN</td><td>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FABS.html", "tooltip": "Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results obtained when creating the absolute value of various classes of numbers."},
    "FSUB": {"html": "<p>Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.</p><p>The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtrac-tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.</p><p>The FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.</p><p>Table 3-48 shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST − SRC = result).</p><p>When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.</p><p>When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.</p><h3>Table 3-48.  FSUB/FSUBP/FISUB Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>SRC</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>− F or − I</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ F or + I</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− F</td><td colspan='2'>+ ∞</td><td colspan='2'>±F or ±0</td><td colspan='2'>DEST</td><td colspan='2'>DEST</td><td colspan='2'>− F</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>DEST</th><td colspan='2'>− 0</td><td colspan='2'>+ ∞</td><td colspan='2'>−SRC</td><td colspan='2'>±0</td><td colspan='2'>− 0</td><td colspan='2'>− SRC</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ 0</td><td colspan='2'>+ ∞</td><td colspan='2'>−SRC</td><td colspan='2'>+ 0</td><td colspan='2'>±0</td><td colspan='2'>− SRC</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>+ F</td><td colspan='2'>DEST</td><td colspan='2'>DEST</td><td colspan='2'>±F or ±0</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>I</p><p>Means integer.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSUB:FSUBP:FISUB.html", "tooltip": "Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format."},
    "FMUL": {"html": "<p>Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating point or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the desti-nation operand).</p><p>The FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.</p><p>The FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.</p><p>The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multi-plied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.</p><p>The following table shows the results obtained when multiplying various classes of numbers, assuming that neither overflow nor underflow occurs.</p><h3>Table 3-39.  FMUL/FMULP/FIMUL Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>DEST</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− F</td><td colspan='2'>+ ∞</td><td colspan='2'>+ F</td><td colspan='2'>+ 0</td><td colspan='2'>− 0</td><td colspan='2'>− F</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− I</td><td colspan='2'>+ ∞</td><td colspan='2'>+ F</td><td colspan='2'>+ 0</td><td colspan='2'>− 0</td><td colspan='2'>− F</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>SRC</th><td colspan='2'>− 0</td><td colspan='2'>*</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ 0</td><td colspan='2'>*</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ I</td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ F</td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>I</p><p>Means Integer.</p><p>*</p><p>Indicates invalid-arithmetic-operand (#IA) exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FMUL:FMULP:FIMUL.html", "tooltip": "Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format."},
    "COMISS": {"html": "<p>Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unor-dered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unor-dered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Operand 1 is an XMM register; Operand 2 can be an XMM register or a 32 bit memory location.</p><p>The COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid opera-tion exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid numeric exception only if a source operand is an SNaN.</p><p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "COMISS.html", "tooltip": "Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unor-dered, greater than, less than, or equal). The OF, SF, and AF flags in the EFLAGS register are set to 0. The unor-dered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "VPERM2I128": {"html": "<p>Permute 128 bit integer data from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Y1</p><p>Y0</p><p>SRC2</p><p>X1</p><p>X0</p><p>SRC1</p><p>X0, X1, Y0, or Y1</p><p>DEST</p><p>X0, X1, Y0, or Y1</p><h3>Figure 4-37.  VPERM2I128 Operation</h3><p>Imm8[1:0] select the source for the first destination 128-bit field, imm8[5:4] select the source for the second destination field. If imm8[3] is set, the low 128-bit field is zeroed. If imm8[7] is set, the high 128-bit field is zeroed.</p><p>VEX.L must be 1, otherwise the instruction will #UD.</p></span>", "url": "VPERM2I128.html", "tooltip": "Permute 128 bit integer data from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register."},
    "PMULHUW": {"html": "<p>Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand. (Figure 4-8 shows this operation when using 64-bit operands.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><svg width='568.799985' viewBox='112.380000 596449.980010 379.199990 118.919970' height='178.379955'><text y='596470.907584' x='202.8627' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='596497.667684' x='202.8627' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='596527.307784' x='397.792556' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.142688'>Z0 = X0 ∗ Y0</text><text y='596528.087784' x='144.5998' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='22.189986'>TEMP</text><text y='596552.987384' x='203.9424' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='596460.6' x='277.98' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596460.6' x='314.34' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596460.6' x='350.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596486.82' x='241.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596543.04' x='241.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596543.04' x='314.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596543.04' x='350.64' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596460.6' x='241.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='596543.04' x='277.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='596516.64' x='170.58' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='596516.64' x='314.58' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='596516.64' x='242.58' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><path style='stroke:black' d='M170.340000,596516.400000 L170.340000,596534.640000 L170.820000,596534.640000 L170.820000,596516.400000 '></path><path style='stroke:black' d='M242.340000,596516.400000 L242.340000,596534.640000 L242.820000,596534.640000 L242.820000,596516.400000 '></path><path style='stroke:black' d='M314.340000,596516.400000 L314.340000,596534.640000 L314.820010,596534.640000 L314.820010,596516.400000 '></path><path style='stroke:black' d='M386.340000,596516.400000 L386.340000,596534.640000 L386.820010,596534.640000 L386.820010,596516.400000 '></path><path style='stroke:black' d='M170.580000,596516.400020 L170.580000,596516.880000 L242.820000,596516.880000 L242.820000,596516.400020 '></path><path style='stroke:black' d='M242.580000,596516.400020 L242.580000,596516.880000 L314.820000,596516.880000 L314.820000,596516.400020 '></path><path style='stroke:black' d='M314.580000,596516.400020 L314.580000,596516.880000 L386.820000,596516.880000 L386.820000,596516.400020 '></path><path style='stroke:black' d='M386.580000,596516.400020 L386.580000,596516.880000 L458.820000,596516.880000 L458.820000,596516.400020 '></path><path style='stroke:black' d='M242.340000,596516.640000 L242.340000,596534.880000 L242.820000,596534.880000 L242.820000,596516.640000 '></path><path style='stroke:black' d='M314.340000,596516.640000 L314.340000,596534.880000 L314.820010,596534.880000 L314.820010,596516.640000 '></path><path style='stroke:black' d='M386.340000,596516.640000 L386.340000,596534.880000 L386.820010,596534.880000 L386.820010,596516.640000 '></path><path style='stroke:black' d='M386.580000,596516.640000 L458.580000,596516.640000 L458.580000,596534.640000 L386.580000,596534.640000 '></path><path style='stroke:black' d='M458.340000,596516.640000 L458.340000,596534.880000 L458.820010,596534.880000 L458.820010,596516.640000 '></path><path style='stroke:black' d='M170.340000,596534.399960 L170.340000,596534.880000 L242.580000,596534.880000 L242.580000,596534.399960 '></path><path style='stroke:black' d='M242.340000,596534.399960 L242.340000,596534.880000 L314.580000,596534.880000 L314.580000,596534.399960 '></path><path style='stroke:black' d='M314.340000,596534.399960 L314.340000,596534.880000 L386.580000,596534.880000 L386.580000,596534.399960 '></path><path style='stroke:black' d='M386.340000,596534.399960 L386.340000,596534.880000 L458.580000,596534.880000 L458.580000,596534.399960 '></path><text y='596471.567484' x='288.658032' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='596471.567484' x='325.680444' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='596471.567484' x='362.096376' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='596498.867384' x='256.26' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='596555.365488' x='245.52' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='30.092256'>Z3[31:16]</text><text y='596555.365488' x='318.110016' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='30.092256'>Z1[31:16]</text><text y='596555.365488' x='354.526824' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='30.092256'>Z0[31:16]</text><text y='596471.567484' x='253.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='596555.365488' x='281.094648' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='30.092256'>Z2[31:16]</text><text y='596527.307784' x='182.3397' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.209004'>Z3 = X3 ∗ Y3</text><text y='596527.307784' x='328.800656' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.126008'>Z1 = X1 ∗ Y1</text><text y='596527.307784' x='255.488386' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.193038'>Z2 = X2 ∗ Y2</text></svg><svg width='218.25' viewBox='241.560005 596486.819980 145.500000 18.000030' height='27.000045'><rect y='596486.82' x='277.92' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='596486.82' x='314.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='596486.82' x='350.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><text y='596498.867384' x='291.838032' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='596498.867384' x='328.860444' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='596498.867384' x='365.276376' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text></svg><h3>Figure 4-8.  PMULHUW and PMULHW Instruction Operation Using 64-bit Operands</h3></span>", "url": "PMULHUW.html", "tooltip": "Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand. (Figure 4-8 shows this operation when using 64-bit operands.)"},
    "PACKUSWB": {"html": "<p>Converts 4, 8 or 16 signed word integers from the destination operand (first operand) and 4, 8 or 16 signed word integers from the source operand (second operand) into 8, 16 or 32 unsigned byte integers and stores the result in the destination operand. (See Figure 4-2 for an example of the packing operation.) If a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The PACKUSWB instruction operates on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit oper-ands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "PACKUSWB.html", "tooltip": "Converts 4, 8 or 16 signed word integers from the destination operand (first operand) and 4, 8 or 16 signed word integers from the source operand (second operand) into 8, 16 or 32 unsigned byte integers and stores the result in the destination operand. (See Figure 4-2 for an example of the packing operation.) If a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination."},
    "BSWAP": {"html": "<p>Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "BSWAP.html", "tooltip": "Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined."},
    "BTS": {"html": "<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>See also: <strong>Bit(BitBase, BitOffset) </strong>on page 3-10.</p><p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-tion with the displacement field of the memory operand. See 'BT—Bit Test” in this chapter for more information on this addressing mechanism.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "BTS.html", "tooltip": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:"},
    "HADDPD": {"html": "<p>Adds the double-precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Adds the double-precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>See Figure 3-15 for HADDPD; see Figure 3-16 for VHADDPD.</p><svg width='507.42' viewBox='132.900000 286366.740000 338.280000 209.220000' height='313.83'><text y='286384.013472' x='240.5523' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='104.3636447'>HADDPD xmm1, xmm2/m128</text><text y='286404.164672' x='430.6153' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='21.3930146'>xmm2</text><text y='286408.880372' x='212.2145' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='28.4035102'>[127:64]</text><text y='286408.880372' x='349.2125' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='19.6639686'>[63:0]</text><text y='286413.595872' x='430.6153' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='21.8409947'>/m128</text><text y='286456.404672' x='212.2145' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='28.4035102'>[127:64]</text><text y='286456.404672' x='349.2125' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='19.6639686'>[63:0]</text><text y='286456.404672' x='430.6153' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='21.3930146'>xmm1</text><text y='286509.160172' x='191.5837' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='69.6726945'>xmm2/m128[63:0] +</text><text y='286509.160272' x='430.6158' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4581416'>Result:</text><text y='286513.875772' x='309.1397' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='99.81311'>xmm1[63:0] + xmm1[127:64]</text><text y='286518.591372' x='190.6013' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='71.6375195'>xmm2/m128[127:64]</text><text y='286518.591372' x='430.6158' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='21.3930146'>xmm1</text><text y='286537.098572' x='212.2247' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='28.4035102'>[127:64]</text><text y='286537.098572' x='353.64337234' style='font-size:7.859300pt' lengthAdjust='spacingAndGlyphs' textLength='19.6639686'>[63:0]</text><text y='286567.4736' x='440.6362' style='font-size:5.894400pt' lengthAdjust='spacingAndGlyphs' textLength='25.8823104'>OM15993</text><rect y='286367.475' x='133.582' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='181.256' width='331.566'></rect><rect y='286367.475' x='133.582' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='181.256' width='331.566'></rect><rect y='286392.895' x='160.107' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286392.895' x='292.733' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286440.419' x='292.733' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286440.42' x='160.107' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286440.419' x='160.107' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286497.891' x='160.107' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286440.42' x='292.733' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286497.891' x='292.733' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286392.895' x='160.107' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286392.895' x='292.733' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286497.891' x='160.107' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect><rect y='286497.891' x='292.733' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.525' width='132.626'></rect></svg><h3>Figure 3-15.  HADDPD—Packed Double-FP Horizontal Add</h3><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>SRC1</p><p>Y3</p><p>Y2</p><p>Y1</p><p>Y0</p><p>SRC2</p><p>DEST</p><p>Y2 + Y3</p><p>X2 + X3</p><p>Y0 + Y1</p><p>X0 + X1</p><h3>Figure 3-16.  VHADDPD operation</h3><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "HADDPD.html", "tooltip": "Adds the double-precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand."},
    "SUBSS": {"html": "<p>Subtracts the low single-precision floating-point value in the source operand (second operand) from the low single-precision floating-point value in the destination operand (first operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "SUBSS.html", "tooltip": "Subtracts the low single-precision floating-point value in the source operand (second operand) from the low single-precision floating-point value in the destination operand (first operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation."},
    "REP": {"html": "<p>Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated until the count in register is decremented to 0. See Table 4-14.</p><h3>Table 4-14.  Repeat Prefixes</h3><table><tr><th>Repeat Prefix</th><th>Termination Condition 1*</th><th>Termination Condition 2</th></tr><tr><td><p>REP</p><p>REPE/REPZ</p><p>REPNE/REPNZ</p></td><td><p>RCX or (E)CX = 0</p><p>RCX or (E)CX = 0</p><p>RCX or (E)CX = 0</p></td><td><p>None</p><p>ZF = 0</p><p>ZF = 1</p></td></tr></table><p><strong>NOTES:</strong></p><p>*</p><p>Count register is CX, ECX or RCX by default, depending on attributes of the operating modes.</p><p>The REPE, REPNE, REPZ, and REPNZ prefixes also check the state of the ZF flag after each iteration and terminate the repeat loop if the ZF flag is not in the specified state. When both termination conditions are tested, the cause of a repeat termination can be determined either by testing the count register with a JECXZ instruction or by testing the ZF flag (with a JZ, JNZ, or JNE instruction).</p><p>When the REPE/REPZ and REPNE/REPNZ prefixes are used, the ZF flag does not require initialization because both the CMPS and SCAS instructions affect the ZF flag according to the results of the comparisons they make.</p><p>A repeating string operation can be suspended by an exception or interrupt. When this happens, the state of the registers is preserved to allow the string operation to be resumed upon a return from the exception or interrupt handler. The source and destination registers point to the next string elements to be operated on, the EIP register points to the string instruction, and the ECX register has the value it held following the last successful iteration of the instruction. This mechanism allows long string operations to proceed without affecting the interrupt response time of the system.</p><p>When a fault occurs during the execution of a CMPS or SCAS instruction that is prefixed with REPE or REPNE, the EFLAGS value is restored to the state prior to the execution of the instruction. Since the SCAS and CMPS instruc-tions do not use EFLAGS as an input, the processor can resume the instruction after the page fault handler.</p><p>Use the REP INS and REP OUTS instructions with caution. Not all I/O ports can handle the rate at which these instructions execute. Note that a REP STOS instruction is the fastest way to initialize a large block of memory.</p><p>In 64-bit mode, the operand size of the count register is associated with the address size attribute. Thus the default count register is RCX; REX.W has no effect on the address size and the count register. In 64-bit mode, if 67H is used to override address size attribute, the count register is ECX and any implicit source/destination operand will use the corresponding 32-bit index register. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "REP:REPE:REPZ:REPNE:REPNZ.html", "tooltip": "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:"},
    "MOVHPS": {"html": "<p>This instruction cannot be used for register to register or memory to memory moves.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p><strong>128-bit Legacy SSE load:</strong></p><p>Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. The upper 128-bits of the corresponding YMM destination register are preserved.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p><strong>VEX.128 encoded load:</strong></p><p>Loads two single-precision floating-point values from the source 64-bit memory operand (third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from second XMM register (second operand) are stored in the lower 64-bits of the destination. The upper 128-bits of the destination YMM register are zeroed.</p><p><strong>128-bit store:</strong></p><p>Stores two packed single-precision floating-point values from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).</p><p>Note: VMOVHPS (store) (VEX.NDS.128.0F 17 /r) is legal and has the same behavior as the existing 0F 17 store.</p><p>For VMOVHPS (store) (VEX.NDS.128.0F 17 /r) instruction version, VEX.vvvv is reserved and must be 1111b other-</p><p>wise instruction will #UD.</p><p>If VMOVHPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "MOVHPS.html", "tooltip": "This instruction cannot be used for register to register or memory to memory moves."},
    "MOVNTPD": {"html": "<p>Moves the packed double-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register or YMM register, which is assumed to contain packed double-precision, floating-pointing data. The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see 'Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple processors might use different memory types to read/write the destination memory locations.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instruc-tions will #UD.</p></span>", "url": "MOVNTPD.html", "tooltip": "Moves the packed double-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register or YMM register, which is assumed to contain packed double-precision, floating-pointing data. The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated."},
    "PCMPEQB": {"html": "<p>Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PCMPEQB:PCMPEQW:PCMPEQD.html", "tooltip": "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s."},
    "MOVQ": {"html": "<p>Copies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This instruction can be used to move a quadword between two MMX technology registers or between an MMX tech-nology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.</p><p>In 64-bit mode, use of the REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX.128.66.0F D6 instruction version, VEX.vvvv and VEX.L=1 are reserved and the former must be 1111b otherwise instructions will #UD.</p><p>Note: In VEX.128.F3.0F 7E version, VEX.vvvv and VEX.L=1 are reserved and the former must be 1111b, otherwise instructions will #UD.</p></span>", "url": "MOVQ.html", "tooltip": "Copies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This instruction can be used to move a quadword between two MMX technology registers or between an MMX tech-nology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations."},
    "SYSENTER": {"html": "<p>Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT. The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to operating system or executive procedures running at privilege level 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When executed in IA-32e mode, the SYSENTER instruction transitions the logical processor to 64-bit mode; other-wise, the logical processor remains in protected mode.</p><p>Prior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:</p><p>These MSRs can be read from and written to using RDMSR/WRMSR. The WRMSR instruction ensures that the IA32_SYSENTER_EIP and IA32_SYSENTER_ESP MSRs always contain canonical addresses.</p><p>While SYSENTER loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and SS descriptor caches are <strong>not</strong> loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSENTER instruction does not ensure this correspondence.</p><p>The SYSENTER instruction can be invoked from all operating modes except real-address mode.</p><p>The SYSENTER and SYSEXIT instructions are companion instructions, but they do not constitute a call/return pair. When executing a SYSENTER instruction, the processor does not save state information for the user code (e.g., the instruction pointer), and neither the SYSENTER nor the SYSEXIT instruction supports passing parameters on the stack.</p><p>To use the SYSENTER and SYSEXIT instructions as companion instructions for transitions between privilege level 3 code and privilege level 0 operating system procedures, the following conventions must be followed:</p><p>The SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor. The availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present. For example:</p><p>IF CPUID SEP bit is set</p><p>THEN IF (Family = 6) and (Model &lt; 3) and (Stepping &lt; 3)</p><p>THEN</p><p>SYSENTER/SYSEXIT_Not_Supported; FI;</p><p>ELSE</p><p>SYSENTER/SYSEXIT_Supported; FI;</p><p>FI;</p><p>When the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.</p></span>", "url": "SYSENTER.html", "tooltip": "Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT. The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to operating system or executive procedures running at privilege level 0."},
    "FSTSW": {"html": "<p>Stores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on the state of the FPU condition code flags. (See the section titled 'Branching and Conditional Moves on FPU Condi-tion Codes” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.) This instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the completion of the prior FPU instruction.</p><p>The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSTSW:FNSTSW.html", "tooltip": "Stores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not."},
    "CMPPS": {"html": "<p>Performs a SIMD compare of the packed single-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of the pairs of packed values. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. The comparison predicate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed (see Table 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand.</p><p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.</p><p>A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p><p>Note that processors with 'CPUID.1H:ECX.AVX =0” do not implement the 'greater-than”, 'greater-than-or-equal”, 'not-greater than”, and 'not-greater-than-or-equal relations” predicates. These comparisons can be made either by using the inverse relationship (that is, use the 'not-less-than-or-equal” to make a 'greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in Table 3-7 under the heading Emulation.</p><p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPS instruction, for processors with 'CPUID.1H:ECX.AVX =0”. See Table 3-11. Compiler should treat reserved Imm8 values as illegal syntax.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><h3>Table 3-11.  Pseudo-Ops and CMPPS</h3><table><tr><th>Pseudo-Op</th><th>Implementation</th></tr><tr><td>CMPEQPS <em>xmm1, xmm2</em></td><td>CMPPS <em>xmm1, xmm2, 0</em></td></tr><tr><td>CMPLTPS<em> xmm1, xmm2</em></td><td>CMPPS <em>xmm1, xmm2, 1</em></td></tr><tr><td>CMPLEPS <em>xmm1, xmm2</em></td><td>CMPPS <em>xmm1, xmm2, 2</em></td></tr><tr><td>CMPUNORDPS <em>xmm1, xmm2</em></td><td>CMPPS <em>xmm1, xmm2, 3</em></td></tr><tr><td>CMPNEQPS <em>xmm1, xmm2</em></td><td>CMPPS <em>xmm1, xmm2, 4</em></td></tr><tr><td>CMPNLTPS <em>xmm1, xmm2</em></td><td>CMPPS <em>xmm1, xmm2, 5</em></td></tr><tr><td>CMPNLEPS<em> xmm1, xmm2</em></td><td>CMPPS<em> xmm1, xmm2, 6</em></td></tr><tr><td>CMPORDPS <em>xmm1, xmm2</em></td><td>CMPPS <em>xmm1, xmm2, 7</em></td></tr></table><p>The greater-than relations not implemented by processor require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p><p><strong>Enhanced Comparison Predicate for VEX-Encoded VCMPPS</strong></p><p>VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destina-tion YMM register are zeroed. Four comparisons are performed with results written to bits 127:0 of the destination operand.</p><p>VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Eight comparisons are performed with results written to the destination operand.</p><p>The comparison predicate operand is an 8-bit immediate:</p><p>Processors with 'CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-9, soft-ware emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPPS instruction. See Table 3-12, where the notation of reg1 and reg2 represent either XMM registers or YMM registers. Compiler should treat reserved Imm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic inter-face.</p><h3>Table 3-12.  Pseudo-Op and VCMPPS Implementation</h3><p>:</p><table><tr><th>Pseudo-Op</th><th>CMPPS Implementation</th></tr><tr><td>VCMPEQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 0</em></td></tr><tr><td>VCMPLTPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 1</em></td></tr><tr><td>VCMPLEPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 2</em></td></tr><tr><td>VCMPUNORDPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 3</em></td></tr><tr><td>VCMPNEQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 4</em></td></tr><tr><td>VCMPNLTPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 5</em></td></tr><tr><td>VCMPNLEPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 6</em></td></tr><tr><td>VCMPORDPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 7</em></td></tr><tr><td>VCMPEQ_UQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 8</em></td></tr><tr><td>VCMPNGEPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 9</em></td></tr><tr><td>VCMPNGTPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 0AH</em></td></tr><tr><td>VCMPFALSEPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 0BH</em></td></tr></table><h3>Table 3-12.  Pseudo-Op and VCMPPS Implementation</h3><table><tr><th>Pseudo-Op</th><th>CMPPS Implementation</th></tr><tr><td>VCMPNEQ_OQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 0CH</em></td></tr><tr><td>VCMPGEPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 0DH</em></td></tr><tr><td>VCMPGTPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 0EH</em></td></tr><tr><td>VCMPTRUEPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 0FH</em></td></tr><tr><td>VCMPEQ_OSPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 10H</em></td></tr><tr><td>VCMPLT_OQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 11H</em></td></tr><tr><td>VCMPLE_OQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 12H</em></td></tr><tr><td>VCMPUNORD_SPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 13H</em></td></tr><tr><td>VCMPNEQ_USPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 14H</em></td></tr><tr><td>VCMPNLT_UQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 15H</em></td></tr><tr><td>VCMPNLE_UQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 16H</em></td></tr><tr><td>VCMPORD_SPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 17H</em></td></tr><tr><td>VCMPEQ_USPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 18H</em></td></tr><tr><td>VCMPNGE_UQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 19H</em></td></tr><tr><td>VCMPNGT_UQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 1AH</em></td></tr><tr><td>VCMPFALSE_OSPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 1BH</em></td></tr><tr><td>VCMPNEQ_OSPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 1CH</em></td></tr><tr><td>VCMPGE_OQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 1DH</em></td></tr><tr><td>VCMPGT_OQPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 1EH</em></td></tr><tr><td>VCMPTRUE_USPS r<em>eg1, reg2, reg3</em></td><td>VCMPPS r<em>eg1, reg2, reg3, 1FH</em></td></tr></table></span>", "url": "CMPPS.html", "tooltip": "Performs a SIMD compare of the packed single-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of the pairs of packed values. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "VFNMADD132SD": {"html": "<p>VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand, adds the negated infinite preci-sion intermediate result to the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFNMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand, adds the negated infinite preci-sion intermediate result to the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VFNMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 64-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMADD132SD:VFNMADD213SD:VFNMADD231SD.html", "tooltip": "VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand, adds the negated infinite preci-sion intermediate result to the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand)."},
    "ROUNDSS": {"html": "<p>Round the single-precision floating-point value in the lowest dword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a single-precision floating-point input to an integer value and returns the result as a single-precision floating-point value in the lowest position. The upper three single-precision floating-point values in the destination are retained.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-15 lists the encoded values for rounding-mode field).</p><p>The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "ROUNDSS.html", "tooltip": "Round the single-precision floating-point value in the lowest dword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a single-precision floating-point input to an integer value and returns the result as a single-precision floating-point value in the lowest position. The upper three single-precision floating-point values in the destination are retained."},
    "FNOP": {"html": "<p>Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FNOP.html", "tooltip": "Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register."},
    "FFREE": {"html": "<p>Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FFREE.html", "tooltip": "Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected."},
    "PEXTRW": {"html": "<p>Copies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register. The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-signifi-cant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the loca-tion. The content of the destination register above bit 16 is cleared (set to all 0s).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits in 64-bit mode.</p><p>Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRW is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.</p></span>", "url": "PEXTRW.html", "tooltip": "Copies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register. The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-signifi-cant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the loca-tion. The content of the destination register above bit 16 is cleared (set to all 0s)."},
    "SWAPGS": {"html": "<p>SWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS instruction is a privileged instruction intended for use by system soft-ware.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When using SYSCALL to implement system calls, there is no kernel stack at the OS entry point. Neither is there a straightforward method to obtain a pointer to kernel structures from which the kernel stack pointer could be read. Thus, the kernel cannot save general purpose registers or reference memory.</p><p>By design, SWAPGS does not require any general purpose registers or memory operands. No registers need to be saved before using the instruction. SWAPGS exchanges the CPL 0 data pointer from the IA32_KERNEL_GS_BASE MSR with the GS base register. The kernel can then use the GS prefix on normal memory references to access kernel data structures. Similarly, when the OS kernel is entered using an interrupt or exception (where the kernel stack is already set up), SWAPGS can be used to quickly get a pointer to the kernel data structures.</p><p>The IA32_KERNEL_GS_BASE MSR itself is only accessible using RDMSR/WRMSR instructions. Those instructions are only accessible at privilege level 0. The WRMSR instruction ensures that the IA32_KERNEL_GS_BASE MSR contains a canonical address.</p></span>", "url": "SWAPGS.html", "tooltip": "SWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS instruction is a privileged instruction intended for use by system soft-ware."},
    "FADD": {"html": "<p>Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:</p><p>FADD ST(0), ST(0);</p><p>The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)</p><p>The FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.</p><p>The table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.</p><p>When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.</p><p>When both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infini-ties of opposite signs, an invalid-operation exception is generated. See Table 3-28.</p><h3>Table 3-28.  FADD/FADDP/FIADD Results</h3><p><strong>DEST</strong></p><p>− ∞</p><p>− F</p><p>− 0</p><p>+ 0</p><p>+ F</p><p>+ ∞</p><p>NaN</p><p>− ∞</p><p>− ∞</p><p>− ∞</p><p>− ∞</p><p>− ∞</p><p>− ∞</p><p>*</p><p>NaN</p><p>− F or − I</p><p>− ∞</p><p>− F</p><p>± F or ± 0</p><p>+ ∞</p><p>SRC</p><p>SRC</p><p>NaN</p><p>−0</p><p>− ∞</p><p>− 0</p><p>± 0</p><p>+ ∞</p><p><strong>SRC</strong></p><p>DEST</p><p>DEST</p><p>NaN</p><p>+ 0</p><p>− ∞</p><p>± 0</p><p>+ 0</p><p>+ ∞</p><p>DEST</p><p>DEST</p><p>NaN</p><p>+ F or + I</p><p>− ∞</p><p>± F or ± 0</p><p>+ F</p><p>+ ∞</p><p>SRC</p><p>SRC</p><p>NaN</p><p>+ ∞</p><p>+ ∞</p><p>+ ∞</p><p>+ ∞</p><p>+ ∞</p><p>+ ∞</p><p>*</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>I</p><p>Means integer.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FADD:FADDP:FIADD.html", "tooltip": "Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format."},
    "SHUFPD": {"html": "<p>Moves either of the two packed double-precision floating-point values from destination operand (first operand) into the low quadword of the destination operand; moves either of the two packed double-precision floating-point values from the source operand into to the high quadword of the destination operand (see Figure 4-21). The select operand (third operand) determines which values are moved to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><svg width='568.799985' viewBox='111.840000 751342.020010 379.199990 146.999985' height='220.4999775'><text y='751367.927684' x='143.2201' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='751411.427484' x='147.72' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='751474.907584' x='143.2201' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='751463.7' x='315.6' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='141.0'></rect><rect y='751355.7' x='315.6' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='141.66'></rect><rect y='751400.7' x='315.6' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='141.66'></rect><rect y='751355.7' x='169.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='146.34'></rect><rect y='751400.7' x='169.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='146.34'></rect><rect y='751463.7' x='168.6' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='147.0'></rect><path style='stroke:black' d='M169.020000,751355.460000 L169.020000,751373.700000 L169.500010,751373.700000 L169.500010,751355.460000 '></path><path style='stroke:black' d='M169.260000,751355.460000 L169.260000,751355.940000 L315.840000,751355.940000 L315.840000,751355.460000 '></path><path style='stroke:black' d='M315.360000,751355.460000 L315.360000,751373.700000 L315.839980,751373.700000 L315.839980,751355.460000 '></path><path style='stroke:black' d='M315.600000,751355.460000 L315.600000,751355.940000 L457.500000,751355.940000 L457.500000,751355.460000 '></path><path style='stroke:black' d='M315.360000,751355.700000 L315.360000,751373.940000 L315.839980,751373.940000 L315.839980,751355.700000 '></path><path style='stroke:black' d='M457.020000,751355.700000 L457.020000,751373.940000 L457.500010,751373.940000 L457.500010,751355.700000 '></path><path style='stroke:black' d='M169.020000,751373.460000 L169.020000,751373.940000 L315.600000,751373.940000 L315.600000,751373.460000 '></path><path style='stroke:black' d='M315.360000,751373.460000 L315.360000,751373.940000 L457.260000,751373.940000 L457.260000,751373.460000 '></path><path style='stroke:black' d='M169.020000,751400.460000 L169.020000,751418.700000 L169.500010,751418.700000 L169.500010,751400.460000 '></path><path style='stroke:black' d='M169.260000,751400.460000 L169.260000,751400.940000 L315.840000,751400.940000 L315.840000,751400.460000 '></path><path style='stroke:black' d='M315.360000,751400.460000 L315.360000,751418.700000 L315.839980,751418.700000 L315.839980,751400.460000 '></path><path style='stroke:black' d='M315.600000,751400.460000 L315.600000,751400.940000 L457.500000,751400.940000 L457.500000,751400.460000 '></path><path style='stroke:black' d='M315.360000,751400.700000 L315.360000,751418.940000 L315.839980,751418.940000 L315.839980,751400.700000 '></path><path style='stroke:black' d='M457.020000,751400.700000 L457.020000,751418.940000 L457.500010,751418.940000 L457.500010,751400.700000 '></path><path style='stroke:black' d='M169.020000,751418.459990 L169.020000,751418.940000 L315.600000,751418.940000 L315.600000,751418.459990 '></path><path style='stroke:black' d='M315.360000,751418.459990 L315.360000,751418.940000 L457.260000,751418.940000 L457.260000,751418.459990 '></path><text y='751475.567184' x='369.78' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='31.089282'>X1 or X0</text><text y='751364.387384' x='378.602172' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='751409.387384' x='378.602172' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text><text y='751364.387384' x='231.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='751409.387384' x='231.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='751474.847384' x='224.22' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='31.123596'>Y1 or Y0</text></svg><h3>Figure 4-21.  SHUFPD Shuffle Operation</h3><p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The select operand is an 8-bit immediate: bit 0 selects which value is moved from the destination operand to the result (where 0 selects the low quadword and 1 selects the high quadword) and bit 1 selects which value is moved from the source operand to the result. Bits 2 through 7 of the select operand are reserved and must be set to 0.</p></span>", "url": "SHUFPD.html", "tooltip": "Moves either of the two packed double-precision floating-point values from destination operand (first operand) into the low quadword of the destination operand; moves either of the two packed double-precision floating-point values from the source operand into to the high quadword of the destination operand (see Figure 4-21). The select operand (third operand) determines which values are moved to the destination operand."},
    "PMINSD": {"html": "<p>Compares packed signed dword integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMINSD.html", "tooltip": "Compares packed signed dword integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand."},
    "MOVUPS": {"html": "<p>128-bit versions: Moves a double quadword containing four packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, store the contents of an XMM register into a 128-bit memory location, or move data between two XMM registers.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>When the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte boundary without causing a general-protection exception (#GP) to be generated.<sup>1</sup></p><p>To move packed single-precision floating-point values to and from memory locations that are known to be aligned on 16-byte boundaries, use the MOVAPS instruction.</p><p>While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the segment may or may not wrap around to the beginning of the segment.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: Moves 256 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>1.</p><p>If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an alignment-check exception (#AC) may or may not be generated (depending on processor implementation) when the operand is not aligned on an 8-byte boundary.</p></span>", "url": "MOVUPS.html", "tooltip": "128-bit versions: Moves a double quadword containing four packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, store the contents of an XMM register into a 128-bit memory location, or move data between two XMM registers."},
    "INVD": {"html": "<p>Invalidates (flushes) the processor’s internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>After executing this instruction, the processor does not wait for the external caches to complete their flushing oper-ation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.</p><p>The INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.</p><p>The INVD instruction may be used when the cache is used as temporary memory and the cache contents need to be invalidated rather than written back to memory. When the cache is used as temporary memory, no external device should be actively writing data to main memory.</p><p>Use this instruction with care. Data cached internally and not written back to main memory will be lost. Note that any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "INVD.html", "tooltip": "Invalidates (flushes) the processor’s internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory."},
    "XRSTOR": {"html": "<p>Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The format of the XSAVE area is detailed in Section 13.4, 'XSAVE Area,” of <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>.</p><p>Section 13.7, 'Operation of XRSTOR,” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em> provides a detailed description of the operation of the XRSTOR instruction. The following items provide a high-level outline:</p><p>for which RFBM[<em>i</em>] = 0.</p><p><em>i</em></p><p>Use of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protec-tion (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</p></span>", "url": "XRSTOR.html", "tooltip": "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0."},
    "LFENCE": {"html": "<p>Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruc-tion. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruc-tion begins execution until LFENCE completes. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete <strong>before</strong> the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-ordered results and routines that consume that data.</p><p>Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the LFENCE instruction; data can be brought into the caches specula-tively just before, during, or after the execution of an LFENCE instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p><p>Specification of the instruction's opcode above indicates a ModR/M byte of E8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is in the range 8-F.</p></span>", "url": "LFENCE.html", "tooltip": "Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruc-tion. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruc-tion begins execution until LFENCE completes. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete <strong>before</strong> the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until the LFENCE completes."},
    "CMC": {"html": "<p>Complements the CF flag in the EFLAGS register. CMC operation is the same in non-64-bit modes and 64-bit mode.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "CMC.html", "tooltip": "Complements the CF flag in the EFLAGS register. CMC operation is the same in non-64-bit modes and 64-bit mode."},
    "ADOX": {"html": "<p>Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).</p><p>This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.</p><p>In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to addi-tional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.</p><p>ADOX executes normally either inside or outside a transaction region.</p><p>Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in <em>Intel<sup>®</sup> 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em>.</p></span>", "url": "ADOX.html", "tooltip": "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands."},
    "FCOMI": {"html": "<p>Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for compari-sons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-32.  FCOMI/FCOMIP/ FUCOMI/FUCOMIP Results</h3><table><tr><th>Comparison Results*</th><th>ZF</th><th>PF</th><th>CF</th></tr><tr><td>ST0 &gt; ST(i)</td><td>0</td><td>0</td><td>0</td></tr><tr><td>ST0 &lt; ST(i)</td><td>0</td><td>0</td><td>1</td></tr><tr><td>ST0 = ST(i)</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Unordered**</td><td>1</td><td>1</td><td>1</td></tr></table><p><strong>NOTES:</strong></p><p>*</p><p>See the IA-32 Architecture Compatibility section below.</p><p>** Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</p><p>An unordered comparison checks the class of the numbers being compared (see 'FXAM—Examine ModR/M” in this chapter). The FUCOMI/FUCOMIP instructions perform the same operations as the FCOMI/FCOMIP instructions. The only difference is that the FUCOMI/FUCOMIP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOMI/FCOMIP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsup-ported format.</p><p>If the operation results in an invalid-arithmetic-operand exception being raised, the status flags in the EFLAGS register are set only if the exception is masked.</p><p>The FCOMI/FCOMIP and FUCOMI/FUCOMIP instructions set the OF, SF and AF flags to zero in the EFLAGS register (regardless of whether an invalid-operation exception is detected).</p><p>The FCOMIP and FUCOMIP instructions also pop the register stack following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FCOMI:FCOMIP: FUCOMI:FUCOMIP.html", "tooltip": "Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for compari-sons, so that –0.0 is equal to +0.0."},
    "PMOVSX": {"html": "<p>Sign-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The destination register is YMM Register.</p><p>Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMOVSX.html", "tooltip": "Sign-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand)."},
    "PXOR": {"html": "<p>Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destina-tion operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corre-sponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-nation register remain unchanged.</p><p>VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PXOR.html", "tooltip": "Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destina-tion operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corre-sponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same."},
    "MULPS": {"html": "<p>Performs a SIMD multiply of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "MULPS.html", "tooltip": "Performs a SIMD multiply of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation."},
    "FDIVR": {"html": "<p>Divides the source operand by the destination operand and stores the result in the destination location. The desti-nation operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.</p><p>The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.</p><p>The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.</p><p>The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.</p><p>If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.</p><p>The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.</p><h3>Table 3-35.  FDIVR/FDIVRP/FIDIVR Results</h3><p><strong>DEST</strong></p><p>NaN</p><p>− ∞</p><p>− F</p><p>− 0</p><p>+ 0</p><p>+ F</p><p>+ ∞</p><p>*</p><p>*</p><p>NaN</p><p>− ∞</p><p>+ ∞</p><p>+ ∞</p><p>− ∞</p><p>− ∞</p><p>**</p><p>**</p><p>NaN</p><p>− F</p><p>+ 0</p><p>+ F</p><p>− F</p><p>− 0</p><p><strong>SRC</strong></p><p>**</p><p>**</p><p>NaN</p><p>− I</p><p>+ 0</p><p>+ F</p><p>− F</p><p>− 0</p><p>*</p><p>*</p><p>NaN</p><p>− 0</p><p>+ 0</p><p>+ 0</p><p>− 0</p><p>− 0</p><p>*</p><p>*</p><p>NaN</p><p>+ 0</p><p>− 0</p><p>− 0</p><p>+ 0</p><p>+ 0</p><p>**</p><p>**</p><p>NaN</p><p>+ I</p><p>− 0</p><p>− F</p><p>+ F</p><p>+ 0</p><p>**</p><p>**</p><p>NaN</p><p>+ F</p><p>− 0</p><p>− F</p><p>+ F</p><p>+ 0</p><p>*</p><p>*</p><p>NaN</p><p>+ ∞</p><p>− ∞</p><p>− ∞</p><p>+ ∞</p><p>+ ∞</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>I</p><p>Means integer.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>** Indicates floating-point zero-divide (#Z) exception.</p><p>When the source operand is an integer 0, it is treated as a +0. This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FDIVR:FDIVRP:FIDIVR.html", "tooltip": "Divides the source operand by the destination operand and stores the result in the destination location. The desti-nation operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format."},
    "SHUFPS": {"html": "<p>Moves two of the four packed single-precision floating-point values from the destination operand (first operand) into the low quadword of the destination operand; moves two of the four packed single-precision floating-point values from the source operand (second operand) into to the high quadword of the destination operand (see Figure 4-22). The select operand (third operand) determines which values are moved to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>determines which values are moved to the destination operand.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><svg width='568.799985' viewBox='112.380000 753734.039995 379.199990 150.960000' height='226.44'><text y='753761.687384' x='145.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='753806.687384' x='145.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='753870.647084' x='145.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='753870.707484' x='404.764062' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='30.655968'>X3 ... X0</text><rect y='753751.02' x='242.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753796.02' x='242.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753751.02' x='170.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753751.02' x='314.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753751.02' x='386.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753796.02' x='170.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753796.02' x='314.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753796.02' x='386.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753859.02' x='169.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753859.02' x='241.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='753859.02' x='313.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><path style='stroke:black' d='M170.040000,753750.780000 L170.040000,753769.020000 L170.520000,753769.020000 L170.520000,753750.780000 '></path><path style='stroke:black' d='M170.280000,753750.780000 L170.280000,753751.260000 L242.520000,753751.260000 L242.520000,753750.780000 '></path><path style='stroke:black' d='M242.040000,753750.780000 L242.040000,753769.020000 L242.520010,753769.020000 L242.520010,753750.780000 '></path><path style='stroke:black' d='M242.280000,753750.780000 L242.280000,753751.260000 L314.520000,753751.260000 L314.520000,753750.780000 '></path><path style='stroke:black' d='M314.040000,753750.780000 L314.040000,753769.020000 L314.519980,753769.020000 L314.519980,753750.780000 '></path><path style='stroke:black' d='M314.280000,753750.780000 L314.280000,753751.260000 L386.520000,753751.260000 L386.520000,753750.780000 '></path><path style='stroke:black' d='M386.040000,753750.780000 L386.040000,753769.020000 L386.519980,753769.020000 L386.519980,753750.780000 '></path><path style='stroke:black' d='M386.280000,753750.780000 L386.280000,753751.260000 L458.520000,753751.260000 L458.520000,753750.780000 '></path><path style='stroke:black' d='M242.040000,753751.020000 L242.040000,753769.260000 L242.520010,753769.260000 L242.520010,753751.020000 '></path><path style='stroke:black' d='M314.040000,753751.020000 L314.040000,753769.260000 L314.519980,753769.260000 L314.519980,753751.020000 '></path><path style='stroke:black' d='M386.040000,753751.020000 L386.040000,753769.260000 L386.519980,753769.260000 L386.519980,753751.020000 '></path><path style='stroke:black' d='M458.040000,753751.020000 L458.040000,753769.260000 L458.519980,753769.260000 L458.519980,753751.020000 '></path><path style='stroke:black' d='M170.040000,753768.780000 L170.040000,753769.260000 L242.280000,753769.260000 L242.280000,753768.780000 '></path><path style='stroke:black' d='M242.040000,753768.780000 L242.040000,753769.260000 L314.280000,753769.260000 L314.280000,753768.780000 '></path><path style='stroke:black' d='M314.040000,753768.780000 L314.040000,753769.260000 L386.280000,753769.260000 L386.280000,753768.780000 '></path><path style='stroke:black' d='M386.040000,753768.780000 L386.040000,753769.260000 L458.280000,753769.260000 L458.280000,753768.780000 '></path><path style='stroke:black' d='M170.040000,753795.780000 L170.040000,753814.020000 L170.520000,753814.020000 L170.520000,753795.780000 '></path><path style='stroke:black' d='M170.280000,753795.780000 L170.280000,753796.260000 L242.520000,753796.260000 L242.520000,753795.780000 '></path><path style='stroke:black' d='M242.040000,753795.780000 L242.040000,753814.020000 L242.520010,753814.020000 L242.520010,753795.780000 '></path><path style='stroke:black' d='M242.280000,753795.780000 L242.280000,753796.260000 L314.520000,753796.260000 L314.520000,753795.780000 '></path><path style='stroke:black' d='M314.040000,753795.780000 L314.040000,753814.020000 L314.519980,753814.020000 L314.519980,753795.780000 '></path><path style='stroke:black' d='M314.280000,753795.780000 L314.280000,753796.260000 L386.520000,753796.260000 L386.520000,753795.780000 '></path><path style='stroke:black' d='M386.040000,753795.780000 L386.040000,753814.020000 L386.519980,753814.020000 L386.519980,753795.780000 '></path><path style='stroke:black' d='M386.280000,753795.780000 L386.280000,753796.260000 L458.520000,753796.260000 L458.520000,753795.780000 '></path><path style='stroke:black' d='M242.040000,753796.020000 L242.040000,753814.260000 L242.520010,753814.260000 L242.520010,753796.020000 '></path><path style='stroke:black' d='M314.040000,753796.020000 L314.040000,753814.260000 L314.519980,753814.260000 L314.519980,753796.020000 '></path><path style='stroke:black' d='M386.040000,753796.020000 L386.040000,753814.260000 L386.519980,753814.260000 L386.519980,753796.020000 '></path><path style='stroke:black' d='M458.040000,753796.020000 L458.040000,753814.260000 L458.519980,753814.260000 L458.519980,753796.020000 '></path><path style='stroke:black' d='M170.040000,753813.780000 L170.040000,753814.260000 L242.280000,753814.260000 L242.280000,753813.780000 '></path><path style='stroke:black' d='M242.040000,753813.780000 L242.040000,753814.260000 L314.280000,753814.260000 L314.280000,753813.780000 '></path><path style='stroke:black' d='M314.040000,753813.780000 L314.040000,753814.260000 L386.280000,753814.260000 L386.280000,753813.780000 '></path><path style='stroke:black' d='M386.040000,753813.780000 L386.040000,753814.260000 L458.280000,753814.260000 L458.280000,753813.780000 '></path><path style='stroke:black' d='M169.620000,753858.779990 L169.620000,753859.260000 L241.860000,753859.260000 L241.860000,753858.779990 '></path><path style='stroke:black' d='M241.620000,753858.779990 L241.620000,753859.260000 L313.860000,753859.260000 L313.860000,753858.779990 '></path><path style='stroke:black' d='M313.620000,753858.779990 L313.620000,753859.260000 L385.860000,753859.260000 L385.860000,753858.779990 '></path><path style='stroke:black' d='M385.620000,753858.779990 L385.620000,753859.260000 L457.860000,753859.260000 L457.860000,753858.779990 '></path><path style='stroke:black' d='M169.380000,753858.780000 L169.380000,753877.020000 L169.860010,753877.020000 L169.860010,753858.780000 '></path><path style='stroke:black' d='M241.380000,753858.780000 L241.380000,753877.020000 L241.860010,753877.020000 L241.860010,753858.780000 '></path><path style='stroke:black' d='M313.380000,753858.780000 L313.380000,753877.020000 L313.860010,753877.020000 L313.860010,753858.780000 '></path><path style='stroke:black' d='M385.380000,753858.780000 L385.380000,753877.020000 L385.860010,753877.020000 L385.860010,753858.780000 '></path><path style='stroke:black' d='M241.380000,753859.020000 L241.380000,753877.260000 L241.860010,753877.260000 L241.860010,753859.020000 '></path><path style='stroke:black' d='M313.380000,753859.020000 L313.380000,753877.260000 L313.860010,753877.260000 L313.860010,753859.020000 '></path><path style='stroke:black' d='M385.380000,753859.020000 L385.380000,753877.260000 L385.860010,753877.260000 L385.860010,753859.020000 '></path><path style='stroke:black' d='M457.380000,753859.020000 L457.380000,753877.260000 L457.860010,753877.260000 L457.860010,753859.020000 '></path><path style='stroke:black' d='M169.380000,753876.779990 L169.380000,753877.260000 L241.620000,753877.260000 L241.620000,753876.779990 '></path><path style='stroke:black' d='M241.380000,753876.779990 L241.380000,753877.260000 L313.620000,753877.260000 L313.620000,753876.779990 '></path><path style='stroke:black' d='M313.380000,753876.779990 L313.380000,753877.260000 L385.620000,753877.260000 L385.620000,753876.779990 '></path><path style='stroke:black' d='M385.380000,753876.779990 L385.380000,753877.260000 L457.620000,753877.260000 L457.620000,753876.779990 '></path><text y='753762.527384' x='273.543012' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='753807.527384' x='267.837312' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='753762.527384' x='204.84' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='753762.527384' x='345.541764' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='753762.527384' x='417.604356' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='753807.527384' x='204.84' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='753807.527384' x='339.836064' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='753807.527384' x='411.834816' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text><text y='753870.707484' x='184.86' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='30.663948'>Y3 ... Y0</text><text y='753870.707484' x='262.084854' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='30.655968'>Y3 ... Y0</text><text y='753870.707484' x='334.082808' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='30.655968'>X3 ... X0</text></svg><h3>Figure 4-22.  SHUFPS Shuffle Operation</h3><p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The select operand is an 8-bit immediate: bits 0 and 1 select the value to be moved from the destination operand to the low doubleword of the result, bits 2 and 3 select the value to be moved from the destination operand to the second doubleword of the result, bits 4 and 5 select the value to be moved from the source operand to the third doubleword of the result, and bits 6 and 7 select the value to be moved from the source operand to the high doubleword of the result.</p></span>", "url": "SHUFPS.html", "tooltip": "Moves two of the four packed single-precision floating-point values from the destination operand (first operand) into the low quadword of the destination operand; moves two of the four packed single-precision floating-point values from the source operand (second operand) into to the high quadword of the destination operand (see Figure 4-22). The select operand (third operand) determines which values are moved to the destination operand."},
    "PUSH": {"html": "<p>Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand sizes are determined and used as follows:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The address size is used only when referencing a source operand in memory.</p><p>The operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is decremented (2, 4 or 8).</p><p>If the source operand is an immediate of size less than the operand size, a sign-extended value is pushed on the  stack.  If  the  source  operand  is  a  segment  register  (16  bits)  and  the  operand  size  is  64-bits,  a  zero-extended value is pushed on the stack; if the operand size is 32-bits, either a zero-extended value is pushed on the stack or the segment selector is written on the stack using a 16-bit move. For the last case, all recent Core and Atom processors perform a 16-bit move, leaving the upper portion of the stack location unmodified.</p><p>The stack-address size determines the width of the stack pointer when writing to the stack in memory and when  decrementing</p><p>the  stack  pointer.  (As  stated  above,</p><p>the  amount  by  which</p><p>the  stack  pointer</p><p>is</p><p>decremented is determined by the operand size.)</p><p>If the operand size is less than the stack-address size, the PUSH instruction may result in a misaligned stack pointer (a stack pointer that is not aligned on a doubleword or quadword boundary).</p><p>The PUSH ESP instruction pushes the value of the ESP register as it existed before the instruction was executed. If a PUSH instruction uses a memory operand in which the ESP register is used for computing the operand address, the address of the operand is computed before the ESP register is decremented.</p><p>If the ESP or SP register is 1 when the PUSH instruction is executed in real-address mode, a stack-fault exception (#SS) is generated (because the limit of the stack segment is violated). Its delivery encounters a second stack-fault exception (for the same reason), causing generation of a double-fault exception (#DF). Delivery of the double-fault exception encounters a third stack-fault exception, and the logical processor enters shutdown mode. See the discussion of the double-fault exception in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p></span>", "url": "PUSH.html", "tooltip": "Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand sizes are determined and used as follows:"},
    "POR": {"html": "<p>Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source and destination operands can be YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "POR.html", "tooltip": "Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0."},
    "PMINUB": {"html": "<p>Performs a SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of byte integers to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMINUB.html", "tooltip": "Performs a SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of byte integers to the destination operand."},
    "XCHG": {"html": "<p>Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor’s locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more information on the locking protocol.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is useful for implementing semaphores or similar data structures for process synchronization. (See 'Bus Locking” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for more information on bus locking.)</p><p>The XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "XCHG.html", "tooltip": "Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor’s locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more information on the locking protocol.)"},
    "INVPCID": {"html": "<p>Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-context identifier (PCID). (See Section 4.10, 'Caching Translation Information,” in <em>Intel 64 and IA-32 Architecture Software Developer’s Manual, Volume 3A</em>.) Invalidation is based on the INVPCID type specified in the register operand and the INVPCID descriptor specified in the memory operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Outside 64-bit mode, the register operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode the register operand has 64 bits.</p><p>There are four INVPCID types currently defined:</p><p>The INVPCID descriptor comprises 128 bits and consists of a PCID and a linear address as shown in Figure 3-23. For INVPCID type 0, the processor uses the full 64 bits of the linear address even outside 64-bit mode; the linear address is not used for other INVPCID types.</p><p>1.</p><p>If the paging structures map the linear address using a page larger than 4 KBytes and there are multiple TLB entries for that page (see Section 4.10.2.3, 'Details of TLB Use,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>), the instruction invalidates all of them.</p><svg width='568.799985' viewBox='112.380000 324009.000010 379.199990 75.420000' height='113.13'><text y='324033.889279' x='150.0' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='14.99144762'>127</text><text y='324033.889279' x='295.5' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='21.52745803'>64 63</text><text y='324033.889279' x='419.7005' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='10.01270801'>12</text><text y='324033.889279' x='431.2207' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='9.3526787'>11</text><text y='324033.889279' x='456.04918714' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='5.0339684'>0</text><rect y='324037.98' x='153.6' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='306.06'></rect><text y='324049.189479' x='200.3996' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='60.40128307'>Linear Address</text><text y='324049.189479' x='319.2601' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='98.84866942'>Reserved (must be zero)</text><text y='324049.189479' x='434.41032096' style='font-size:9.053900pt' lengthAdjust='spacingAndGlyphs' textLength='21.55099817'>PCID</text><rect y='324037.98' x='306.66' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='124.26'></rect></svg><h3>Figure 3-23.  INVPCID Descriptor</h3><p>If CR4.PCIDE = 0, a logical processor does not cache information for any PCID other than 000H. In this case, executions with INVPCID types 0 and 1 are allowed only if the PCID specified in the INVPCID descriptor is 000H; executions with INVPCID types 2 and 3 invalidate mappings only for PCID 000H. Note that CR4.PCIDE must be 0 outside 64-bit mode (see Chapter 4.10.1, 'Process-Context Identifiers (PCIDs)‚” of the <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 3A</em>).</p></span>", "url": "INVPCID.html", "tooltip": "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-context identifier (PCID). (See Section 4.10, 'Caching Translation Information,” in <em>Intel 64 and IA-32 Architecture Software Developer’s Manual, Volume 3A</em>.) Invalidation is based on the INVPCID type specified in the register operand and the INVPCID descriptor specified in the memory operand."},
    "MOVBE": {"html": "<p>Performs a byte swap operation on the data copied from the second operand (source operand) and store the result in the first operand (destination operand). The source operand can be a general-purpose register, or memory loca-tion; the destination register can be a general-purpose register, or a memory location; however, both operands can not be registers, and only one operand can be a memory location. Both operands must be the same size, which can be a word, a doubleword or quadword.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The MOVBE instruction is provided for swapping the bytes on a read from memory or on a write to memory; thus providing support for converting little-endian values to big-endian format and vice versa.</p><p>In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOVBE.html", "tooltip": "Performs a byte swap operation on the data copied from the second operand (source operand) and store the result in the first operand (destination operand). The source operand can be a general-purpose register, or memory loca-tion; the destination register can be a general-purpose register, or a memory location; however, both operands can not be registers, and only one operand can be a memory location. Both operands must be the same size, which can be a word, a doubleword or quadword."},
    "AESKEYGENASSIST": {"html": "<p>Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory loca-tion.</p><p>128-bit Legacy SSE version:Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "AESKEYGENASSIST.html", "tooltip": "Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the result in the destination operand."},
    "SAL": {"html": "<p>Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.</p><p>The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see Figure 7-7 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>).</p><p>The shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit (see Figure 7-8 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>); the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position’s shifted value with the sign of the unshifted value (see Figure 7-9 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>).</p><p>The SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.</p><p>Using the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction. The quotient from the IDIV instruction is rounded toward zero, whereas the 'quotient” of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the 'remainder” is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).</p><p>The OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the most-significant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits and the mask width for CL is 5 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64-bits and sets the mask width for CL to 6 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "SAL:SAR:SHL:SHR.html", "tooltip": "Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand."},
    "ADDPD": {"html": "<p>Performs a SIMD add of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified. See Chapter 11 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an overview of SIMD double-precision floating-point operation.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "ADDPD.html", "tooltip": "Performs a SIMD add of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand."},
    "NOT": {"html": "<p>Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "NOT.html", "tooltip": "Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location."},
    "UCOMISD": {"html": "<p>Performs an unordered compare of the double-precision floating-point values in the low quadwords of source operand 1 (first operand) and source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Source operand 1 is an XMM register; source operand 2 can be an XMM register or a 64 bit memory location.</p><p>The UCOMISD instruction differs from the COMISD instruction in that it signals a SIMD floating-point invalid oper-ation exception (#I) only when a source operand is an SNaN. The COMISD instruction signals an invalid operation exception if a source operand is either a QNaN or an SNaN.</p><p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "UCOMISD.html", "tooltip": "Performs an unordered compare of the double-precision floating-point values in the low quadwords of source operand 1 (first operand) and source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "PADDSB": {"html": "<p>Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The PADDSB instruction adds packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.</p><p>The PADDSW instruction adds packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.</p><p>These instructions can operate on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX tech-nology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PADDSB:PADDSW.html", "tooltip": "Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs."},
    "PMOVMSKB": {"html": "<p>Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source operand. The destination operand is a general-purpose register.</p><p>In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.</p><p>Legacy SSE version: The source operand is an MMX technology register.</p><p>128-bit Legacy SSE version: The source operand is an XMM register.</p><p>VEX.128 encoded version: The source operand is an XMM register.</p><p>VEX.256 encoded version: The source operand is a YMM register.</p><p>Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMOVMSKB.html", "tooltip": "Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand)."},
    "CVTPS2DQ": {"html": "<p>Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed doubleword integers in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operation is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "CVTPS2DQ.html", "tooltip": "Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed doubleword integers in the destination operand."},
    "SQRTPS": {"html": "<p>Performs a SIMD computation of the square roots of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "SQRTPS.html", "tooltip": "Performs a SIMD computation of the square roots of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation."},
    "FXAM": {"html": "<p>Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register (see the table below).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-52.  FXAM Results</h3><p>.</p><table><tr><th>Class</th><th>C3</th><th>C2</th><th>C0</th></tr><tr><td>Unsupported</td><td>0</td><td>0</td><td>0</td></tr><tr><td>NaN</td><td>0</td><td>0</td><td>1</td></tr><tr><td>Normal finite number</td><td>0</td><td>1</td><td>0</td></tr><tr><td>Infinity</td><td>0</td><td>1</td><td>1</td></tr><tr><td>Zero</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Empty</td><td>1</td><td>0</td><td>1</td></tr><tr><td>Denormal number</td><td>1</td><td>1</td><td>0</td></tr></table><p>The C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FXAM.html", "tooltip": "Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register (see the table below)."},
    "LEA": {"html": "<p>Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attri-butes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-63.  Non-64-bit Mode LEA Operation with Address and Operand Size Attributes</h3><table><tr><th>Operand Size</th><th>Address Size</th><th>Action Performed</th></tr><tr><td>16</td><td>16</td><td>16-bit effective address is calculated and stored in requested 16-bit register destination.</td></tr><tr><td>16</td><td>32</td><td>32-bit effective address is calculated. The lower 16 bits of the address are stored in the requested 16-bit register destination.</td></tr><tr><td>32</td><td>16</td><td>16-bit effective address is calculated. The 16-bit address is zero-extended and stored in the requested 32-bit register destination.</td></tr><tr><td>32</td><td>32</td><td>32-bit effective address is calculated and stored in the requested 32-bit register destination.</td></tr></table><p>Different assemblers may use different algorithms based on the size attribute and symbolic reference of the source operand.</p><p>In 64-bit mode, the instruction’s destination operand is governed by operand size attribute, the default operand size is 32 bits. Address calculation is governed by address size attribute, the default address size is 64-bits. In 64-bit mode, address size of 16 bits is not encodable. See Table 3-64.</p><h3>Table 3-64.  64-bit Mode LEA Operation with Address and Operand Size Attributes</h3><table><tr><th>Operand Size</th><th>Address Size</th><th>Action Performed</th></tr><tr><td>16</td><td>32</td><td>32-bit effective address is calculated (using 67H prefix). The lower 16 bits of the address are stored in the requested 16-bit register destination (using 66H prefix).</td></tr><tr><td>16</td><td>64</td><td>64-bit effective address is calculated (default address size). The lower 16 bits of the address are stored in the requested 16-bit register destination (using 66H prefix).</td></tr><tr><td>32</td><td>32</td><td>32-bit effective address is calculated (using 67H prefix) and stored in the requested 32-bit register destination.</td></tr><tr><td>32</td><td>64</td><td>64-bit effective address is calculated (default address size) and the lower 32 bits of the address are stored in the requested 32-bit register destination.</td></tr><tr><td>64</td><td>32</td><td>32-bit effective address is calculated (using 67H prefix), zero-extended to 64-bits, and stored in the requested 64-bit register destination (using REX.W).</td></tr><tr><td>64</td><td>64</td><td>64-bit effective address is calculated (default address size) and all 64-bits of the address are stored in the requested 64-bit register destination (using REX.W).</td></tr></table></span>", "url": "LEA.html", "tooltip": "Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attri-butes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment."},
    "XEND": {"html": "<p>The instruction marks the end of an RTM code region. If this corresponds to the outermost scope (that is, including this XEND instruction, the number of XBEGIN instructions is the same as number of XEND instructions), the logical processor will attempt to commit the logical processor state atomically. If the commit fails, the logical processor will rollback all architectural register and memory updates performed during the RTM execution. The logical processor will resume execution at the fallback address computed from the outermost XBEGIN instruction. The EAX register is updated to reflect RTM abort information.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>XEND executed outside a transactional region will cause a #GP (General Protection Fault).</p></span>", "url": "XEND.html", "tooltip": "The instruction marks the end of an RTM code region. If this corresponds to the outermost scope (that is, including this XEND instruction, the number of XBEGIN instructions is the same as number of XEND instructions), the logical processor will attempt to commit the logical processor state atomically. If the commit fails, the logical processor will rollback all architectural register and memory updates performed during the RTM execution. The logical processor will resume execution at the fallback address computed from the outermost XBEGIN instruction. The EAX register is updated to reflect RTM abort information."},
    "STAC": {"html": "<p>Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute STAC when CPL &gt; 0 cause #UD.</p></span>", "url": "STAC.html", "tooltip": "Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register."},
    "WRMSR": {"html": "<p>Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are copied to low-order 32 bits of the MSR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an MSR should be set to values previously read.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to bits in a reserved MSR.</p><p>When the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated. This includes global entries (see 'Translation Lookaside Buffers (TLBs)” in Chapter 3 of the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 3A</em>).</p><p>MSRs control functions for testability, execution tracing, performance-monitoring and machine check errors. Chapter 35, 'Model-Specific Registers (MSRs)”, in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C</em>, lists all MSRs that can be written with this instruction and their addresses. Note that each processor family has its own set of MSRs.</p><p>The WRMSR instruction is a serializing instruction (see 'Serializing Instructions” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>). Note that WRMSR to the IA32_TSC_DEADLINE MSR (MSR index 6E0H) and the X2APIC MSRs (MSR indices 802H to 83FH) are not serializing.</p><p>The CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.</p></span>", "url": "WRMSR.html", "tooltip": "Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are copied to low-order 32 bits of the MSR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an MSR should be set to values previously read."},
    "CVTTSS2SI": {"html": "<p>Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>Legacy SSE instructions: In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "CVTTSS2SI.html", "tooltip": "Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register."},
    "FTST": {"html": "<p>Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-50.  FTST Results</h3><table><tr><th>Condition</th><th>C3</th><th>C2</th><th>C0</th></tr><tr><td>ST(0) &gt; 0.0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>ST(0) &lt; 0.0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>ST(0) = 0.0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Unordered</td><td>1</td><td>1</td><td>1</td></tr></table><p>This instruction performs an 'unordered comparison.” An unordered comparison also checks the class of the numbers being compared (see 'FXAM—Examine ModR/M” in this chapter). If the value in register ST(0) is a NaN or is in an undefined format, the condition flags are set to 'unordered” and the invalid operation exception is gener-ated.</p><p>The sign of zero is ignored, so that (– 0.0 ← +0.0).</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FTST.html", "tooltip": "Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below)."},
    "MOVHLPS": {"html": "<p>This instruction cannot be used for memory to register moves.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p><strong>128-bit two-argument form:</strong></p><p>Moves two packed single-precision floating-point values from the high quadword of the second XMM argument (second operand) to the low quadword of the first XMM register (first argument). The high quadword of the desti-nation operand is left unchanged. Bits (VLMAX-1:64) of the corresponding YMM destination register are unmodi-fied.</p><p><strong>128-bit three-argument form</strong></p><p>Moves two packed single-precision floating-point values from the high quadword of the third XMM argument (third operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM argument (second operand) to the high quadword of the destination (first operand). Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>If VMOVHLPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "MOVHLPS.html", "tooltip": "This instruction cannot be used for memory to register moves."},
    "CVTTSD2SI": {"html": "<p>Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "CVTTSD2SI.html", "tooltip": "Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register."},
    "FST": {"html": "<p>The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory loca-tion or another register in the FPU register stack. When storing the value in memory, the value is converted to single-precision or double-precision floating-point format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in double extended-precision floating-point format.</p><p>If the destination operand is a memory location, the operand specifies the address where the first byte of the desti-nation value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.</p><p>If the destination size is single-precision or double-precision, the significand of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception (#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.</p><p>If the value being stored is ±0, ±∞, or a NaN, the least-significant bits of the significand and the exponent are trun-cated to fit the destination format. This operation preserves the value’s identity as a 0, ∞, or NaN.</p><p>If the destination operand is a non-empty register, the invalid-operation exception is not generated.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FST:FSTP.html", "tooltip": "The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory loca-tion or another register in the FPU register stack. When storing the value in memory, the value is converted to single-precision or double-precision floating-point format."},
    "CVTDQ2PD": {"html": "<p>Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding XMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or 128- bit memory location. The destination operation is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>SRC</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>DEST</p><h3>Figure 3-10.  CVTDQ2PD (VEX.256 encoded version)</h3></span>", "url": "CVTDQ2PD.html", "tooltip": "Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand)."},
    "OR": {"html": "<p>Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "OR.html", "tooltip": "Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1."},
    "SBB": {"html": "<p>Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p><p>The SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p><p>The SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "SBB.html", "tooltip": "Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction."},
    "FXCH": {"html": "<p>Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)], so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For example, the following instruction sequence takes the square root of the third register from the top of the register stack:</p><p>FXCH ST(3);</p><p>FSQRT;</p><p>FXCH ST(3);</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FXCH.html", "tooltip": "Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged."},
    "MAXSD": {"html": "<p>Compares the low double-precision floating-point values in the first source operand and second the source operand, and returns the maximum value to the low quadword of the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. When the second source operand is a memory operand, only 64 bits are accessed. The high quadword of the destination operand is copied from the same bits of first source operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "MAXSD.html", "tooltip": "Compares the low double-precision floating-point values in the first source operand and second the source operand, and returns the maximum value to the low quadword of the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. When the second source operand is a memory operand, only 64 bits are accessed. The high quadword of the destination operand is copied from the same bits of first source operand."},
    "FDECSTP": {"html": "<p>Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FDECSTP.html", "tooltip": "Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected."},
    "VZEROUPPER": {"html": "<p>The instruction zeros the bits in position 128 and higher of all YMM registers. The lower 128-bits of the registers (the corresponding XMM registers) are unmodified.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is recommended when transitioning between AVX and legacy SSE code - it will eliminate perfor-mance penalties caused by false dependencies.</p><p>Note: VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified.</p></span>", "url": "VZEROUPPER.html", "tooltip": "The instruction zeros the bits in position 128 and higher of all YMM registers. The lower 128-bits of the registers (the corresponding XMM registers) are unmodified."},
    "NOP": {"html": "<p>This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction stream but does not impact machine context, except for the EIP register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The multi-byte form of NOP is available on processors with model encoding:</p><p>The multi-byte NOP instruction does not alter the content of a register and will not issue a memory operation. The instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "NOP.html", "tooltip": "This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction stream but does not impact machine context, except for the EIP register."},
    "TEST": {"html": "<p>Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "TEST.html", "tooltip": "Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded."},
    "UCOMISS": {"html": "<p>Performs an unordered compare of the single-precision floating-point values in the low doublewords of the source operand 1 (first operand) and the source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Source operand 1 is an XMM register; source operand 2 can be an XMM register or a 32 bit memory location.</p><p>The UCOMISS instruction differs from the COMISS instruction in that it signals a SIMD floating-point invalid opera-tion exception (#I) only when a source operand is an SNaN. The COMISS instruction signals an invalid operation exception if a source operand is either a QNaN or an SNaN.</p><p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "UCOMISS.html", "tooltip": "Performs an unordered compare of the single-precision floating-point values in the low doublewords of the source operand 1 (first operand) and the source operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "SHRD": {"html": "<p>The SHRD instruction is useful for multi-precision shifts of 64 bits or more.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The instruction shifts the first operand (destination operand) to the right the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with the most significant bit of the destination operand).</p><p>The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode, the width of the count mask is 5 bits. Only bits 0 through 4 of the count register are used (masking the count to a value between 0 and 31). If the count is greater than the operand size, the result is undefined.</p><p>If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "SHRD.html", "tooltip": "The SHRD instruction is useful for multi-precision shifts of 64 bits or more."},
    "PMINSB": {"html": "<p>Compares packed signed byte integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMINSB.html", "tooltip": "Compares packed signed byte integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand."},
    "FLDCW": {"html": "<p>Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruc-tion is typically used to establish or change the FPU’s mode of operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled 'Soft-ware Exception Handling” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FLDCW.html", "tooltip": "Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruc-tion is typically used to establish or change the FPU’s mode of operation."},
    "IN": {"html": "<p>Copies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte imme-diate allows I/O port addresses 0 to 255 to be accessed.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port, the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.</p><p>This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 16, 'Input/Output,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more infor-mation on accessing I/O ports in the I/O address space.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "IN.html", "tooltip": "Copies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte imme-diate allows I/O port addresses 0 to 255 to be accessed."},
    "LLDT": {"html": "<p>Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently. However, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general protection exception (#GP).</p><p>The operand-size attribute has no effect on this instruction.</p><p>The LLDT instruction is provided for use in operating-system software; it should not be used in application programs. This instruction can only be executed in protected mode or 64-bit mode.</p><p>In 64-bit mode, the operand size is fixed at 16 bits.</p></span>", "url": "LLDT.html", "tooltip": "Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task."},
    "BLENDVPD": {"html": "<p>Conditionally copy each quadword data element of double-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Each quadword element of the destination operand is copied from:</p><p>The register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPD with a VEX prefix will cause #UD.</p><p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.</p><p>VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction will #UD.</p><p>VBLENDVPD permits the mask to be any XMM or YMM register. In contrast, BLENDVPD treats XMM0 implicitly as the mask and do not support non-destructive destination operation.</p></span>", "url": "BLENDVPD.html", "tooltip": "Conditionally copy each quadword data element of double-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register."},
    "PUSHA": {"html": "<p>Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instruc-tions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register is its value before prior to pushing the first register (see the 'Operation” section below).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode. The PUSHA instruc-tion is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.</p><p>In the real-address mode, if the ESP or SP register is 1, 3, or 5 when PUSHA/PUSHAD executes: an #SS exception is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p><p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "PUSHA:PUSHAD.html", "tooltip": "Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instruc-tions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register is its value before prior to pushing the first register (see the 'Operation” section below)."},
    "STI": {"html": "<p>If protected-mode virtual interrupts are not enabled, STI sets the interrupt flag (IF) in the EFLAGS register. After the IF flag is set, the processor begins responding to external, maskable interrupts after the next instruction is executed. The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure (or subroutine). For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized<sup>1</sup>. If the STI instruction is followed by a CLI instruction (which clears the IF flag), the effect of the STI instruction is negated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The IF flag and the STI and CLI instructions do not prohibit the generation of exceptions and NMI interrupts. NMI interrupts (and SMIs) may be blocked for one macroinstruction following an STI.</p><p>When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; STI sets the VIF flag in the EFLAGS register, leaving IF unaffected.</p><p>Table 4-16 indicates the action of the STI instruction depending on the processor’s mode of operation and the CPL/IOPL settings of the running program or procedure.</p><p>Operation is the same in all modes.</p><h3>Table 4-16.  Decision Table for STI Results</h3><table><tr><th>CR0.PE</th><th>EFLAGS.VM</th><th>EFLAGS.IOPL</th><th>CS.CPL</th><th>CR4.PVI</th><th>EFLAGS.VIP</th><th>CR4.VME</th><th>STI Result</th></tr><tr><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><th>IF = 1</th></tr><tr><td>1</td><td>0</td><td>≥ CPL</td><td>X</td><td>X</td><td>X</td><td>X</td><th>IF = 1</th></tr><tr><td>1</td><td>0</td><td>&lt; CPL</td><td>3</td><td>1</td><td>X</td><td>X</td><th>VIF = 1</th></tr><tr><td>1</td><td>0</td><td>&lt; CPL</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><th>GP Fault</th></tr><tr><td>1</td><td>0</td><td>&lt; CPL</td><td>X</td><td>0</td><td>X</td><td>X</td><th>GP Fault</th></tr><tr><td>1</td><td>0</td><td>&lt; CPL</td><td>X</td><td>X</td><td>1</td><td>X</td><th>GP Fault</th></tr><tr><td>1</td><td>1</td><td>3</td><td>X</td><td>X</td><td>X</td><td>X</td><th>IF = 1</th></tr><tr><td>1</td><td>1</td><td>&lt; 3</td><td>X</td><td>X</td><td>0</td><td>1</td><th>VIF = 1</th></tr><tr><td>1</td><td>1</td><td>&lt; 3</td><td>X</td><td>X</td><td>1</td><td>X</td><th>GP Fault</th></tr><tr><td>1</td><td>1</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><td>0</td><th>GP Fault</th></tr></table><p><strong>NOTES:</strong></p><p>X = This setting has no impact.</p><p>1.</p><p>The STI instruction delays recognition of interrupts only if it is executed with EFLAGS.IF = 0. In a sequence of STI instructions, only the first instruction in the sequence is guaranteed to delay interrupts.</p><p>In the following instruction sequence, interrupts may be recognized before RET executes: STI STI RET</p></span>", "url": "STI.html", "tooltip": "If protected-mode virtual interrupts are not enabled, STI sets the interrupt flag (IF) in the EFLAGS register. After the IF flag is set, the processor begins responding to external, maskable interrupts after the next instruction is executed. The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure (or subroutine). For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized<sup>1</sup>. If the STI instruction is followed by a CLI instruction (which clears the IF flag), the effect of the STI instruction is negated."},
    "VFNMADD132PS": {"html": "<p>VFNMADD132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four or eight packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFNMADD213PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the four or eight packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFNMADD231PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four or eight packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMADD132PS:VFNMADD213PS:VFNMADD231PS.html", "tooltip": "VFNMADD132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four or eight packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand)."},
    "OUTS": {"html": "<p>Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the assembly-code level, two forms of this instruction are allowed: the 'explicit-operands” form and the 'no-operands” form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct <strong>type</strong> (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct <strong>location</strong>. The location is always specified by the DS:(E)SI or RSI registers, which must be loaded correctly before the OUTS instruction is executed.</p><p>The no-operands form provides 'short forms” of the byte, word, and doubleword versions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).</p><p>After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.) The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.</p><p>The OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See 'REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix. This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 16, 'Input/Output,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more information on accessing I/O ports in the I/O address space.</p><p>In 64-bit mode, the default operand size is 32 bits; operand size is not promoted by the use of REX.W. In 64-bit mode, the default address size is 64 bits, and 64-bit address is specified using RSI by default. 32-bit address using ESI is support using the prefix 67H, but 16-bit address is not supported in 64-bit mode.</p></span>", "url": "OUTS:OUTSB:OUTSW:OUTSD.html", "tooltip": "Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port."},
    "VTESTPD": {"html": "<p>VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VTESTPD performs a bitwise comparison of all the sign bits of the double-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.</p><p>The first source register is specified by the ModR/M <em>reg</em> field.</p><p>128-bit version: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.</p><p>VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "VTESTPD:VTESTPS.html", "tooltip": "VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD."},
    "MOVSS": {"html": "<p>Moves a scalar single-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to move a single-precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single-precision floating-point value between the low doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>For non-VEX encoded syntax and when the source and destination operands are XMM registers, the high double-words of the destination operand remains unchanged. When the source operand is a memory location and destina-tion operand is an XMM registers, the high doublewords of the destination operand is cleared to all 0s.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>VEX encoded instruction syntax supports two source operands and a destination operand if ModR/M.mod field is 11B. VEX.vvvv is used to encode the first source operand (the second operand). The low 128 bits of the destination operand stores the result of merging the low dword of the second source operand with three dwords in bits 127:32 of the first source operand. The upper bits of the destination operand are cleared.</p><p>Note: For the 'VMOVSS m32, xmm1” (memory store form) instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.</p><p>Note: For the 'VMOVSS xmm1, m32” (memory load form) instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.</p></span>", "url": "MOVSS.html", "tooltip": "Moves a scalar single-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to move a single-precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single-precision floating-point value between the low doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations."},
    "STR": {"html": "<p>Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the register and the upper 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of operand size.</p><p>In 64-bit mode, operation is the same. The size of the memory operand is fixed at 16 bits. In register stores, the 2-byte TR is zero extended if stored to a 64-bit register.</p><p>The STR instruction is useful only in operating-system software. It can only be executed in protected mode.</p></span>", "url": "STR.html", "tooltip": "Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task."},
    "PMINSW": {"html": "<p>Performs a SIMD compare of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of word integers to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMINSW.html", "tooltip": "Performs a SIMD compare of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum value for each pair of word integers to the destination operand."},
    "PCMPGTQ": {"html": "<p>Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PCMPGTQ.html", "tooltip": "Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s."},
    "FBSTP": {"html": "<p>Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The destination operand specifies the address where the first byte destination value is to be stored. The BCD value (including its sign bit) requires 10 bytes of space in memory.</p><p>The following table shows the results obtained when storing various classes of numbers in packed BCD format.</p><h3>Table 3-29.  FBSTP Results</h3><table><tr><th>ST(0)</th><th>DEST</th></tr><tr><td>− ∞ or Value Too Large for DEST Format</td><td>*</td></tr><tr><td>F ≤ − 1</td><td>− D</td></tr><tr><td>−1 &lt; F &lt; -0</td><td>**</td></tr><tr><td>− 0</td><td>− 0</td></tr><tr><td>+ 0</td><td>+ 0</td></tr><tr><td>+ 0 &lt; F &lt; +1</td><td>**</td></tr><tr><td>F ≥ +1</td><td>+ D</td></tr><tr><td>+ ∞ or Value Too Large for DEST Format</td><td>*</td></tr><tr><td>NaN</td><td>*</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>D Means packed-BCD number.</p><p>*</p><p>Indicates floating-point invalid-operation (#IA) exception.</p><p>** ±0 or ±1, depending on the rounding mode.</p><p>If the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FBSTP.html", "tooltip": "Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1."},
    "PMINUW": {"html": "<p>Compares packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMINUW.html", "tooltip": "Compares packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand."},
    "LAHF": {"html": "<p>This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "LAHF.html", "tooltip": "This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1."},
    "BLSR": {"html": "<p>Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destina-tion operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "BLSR.html", "tooltip": "Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destina-tion operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF."},
    "RCPSS": {"html": "<p>Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The relative error for this approximation is:</p><p>|Relative Error| ≤ 1.5 ∗ 2<sup>−12</sup></p><p>The RCPSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2<sup>125</sup>| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2<sup>126</sup>| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "RCPSS.html", "tooltip": "Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation."},
    "SMSW": {"html": "<p>Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The desti-nation operand can be a general-purpose register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In non-64-bit modes, when the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are copied into the low-order 16 bits of the register and the high-order 16 bits are undefined. When the destination operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity, regardless of the operand size.</p><p>In 64-bit mode, the behavior of the SMSW instruction is defined by the following examples:</p><p>SMSW is only useful in operating-system software. However, it is not a privileged instruction and can be used in application programs. The is provided for compatibility with the Intel 286 processor. Programs and procedures intended to run on the Pentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors should use the MOV (control registers) instruction to load the machine status word.</p><p>See 'Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p></span>", "url": "SMSW.html", "tooltip": "Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The desti-nation operand can be a general-purpose register or a memory location."},
    "AAA": {"html": "<p>Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4 through 7 of the AL register are set to 0.</p><p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "AAA.html", "tooltip": "Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result."},
    "PAVGB": {"html": "<p>Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "PAVGB:PAVGW.html", "tooltip": "Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position."},
    "VFNMSUB132SD": {"html": "<p>VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFNMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VFNMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From negated infinite precision interme-diate result, subtracts the low double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 64-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMSUB132SD:VFNMSUB213SD:VFNMSUB231SD.html", "tooltip": "VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand)."},
    "AND": {"html": "<p>Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the it to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "AND.html", "tooltip": "Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0."},
    "VPERMILPS": {"html": "<p>(variable control version)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Permute single-precision floating-point values in the first source operand (second operand) using 8-bit control fields in the low bytes of corresponding elements the shuffle control (third operand) and store results in the desti-nation operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.</p><svg width='445.5900075' viewBox='136.080000 885148.199995 297.060005 13.500015' height='20.2500225002'><rect y='885148.2' x='136.08' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='885148.2' x='173.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='885148.2' x='210.36' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='885148.2' x='247.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.08'></rect><rect y='885148.2' x='284.58' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='885148.2' x='321.72' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='885148.2' x='358.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='885148.2' x='396.0' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><text y='885156.3134' x='147.18' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X7</text><text y='885156.3134' x='184.32' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.21'>X6</text><text y='885156.3134' x='221.46' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X5</text><text y='885156.3134' x='258.54' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X4</text><text y='885156.3134' x='295.68' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X3</text><text y='885156.3134' x='332.82' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.21'>X2</text><text y='885156.3134' x='369.96' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.21'>X1</text><text y='885156.3134' x='407.1' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text></svg><p>SRC1</p><p>DEST</p><p>X7 .. X4</p><p>X7 .. X4</p><p>X7 .. X4</p><p>X7 .. X4</p><p>X3 ..X0</p><p>X3 ..X0</p><p>X3 .. X0</p><p>X3 .. X0</p><h3>Figure 4-40.  VPERMILPS Operation</h3><p>There is one control byte per destination single-precision element. Each control byte is aligned with the low 8 bits of the corresponding single-precision destination element. Each control byte contains a 2-bit select field (see Figure 4-41) that determines which of the source elements are selected. Source elements are restricted to lie in the same source 128-bit region as the destination.</p><p>Bit</p><p>31</p><p>226</p><p>225 224</p><p>63</p><p>34</p><p>33 32</p><p>1</p><p>0</p><p>255</p><p><strong>. . .</strong></p><svg width='160.155' viewBox='125.220000 885569.819980 106.770000 36.000030' height='54.000045'><rect y='885569.82' x='125.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='36.0' width='82.98'></rect><rect y='885569.82' x='209.76' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='36.0' width='22.2'></rect><text y='885590.8836' x='152.7' style='font-size:9.129800pt' lengthAdjust='spacingAndGlyphs' textLength='27.53730276'>ignored</text><text y='885591.3635' x='216.48' style='font-size:9.129800pt' lengthAdjust='spacingAndGlyphs' textLength='9.97704544'>sel</text></svg><p>ignored</p><p>ignored</p><p>sel</p><p>sel</p><p>Control Field 7</p><p>Control Field 2</p><p>Control Field 1</p><h3>Figure 4-41.  VPERMILPS Shuffle Control</h3><p>(immediate control version)</p><p>Permute single-precision floating-point values in the first source operand (second operand) using four 2-bit control fields in the 8-bit immediate and store results in the destination operand (first operand). The source operand is a YMM register or 256-bit memory location and the destination operand is a YMM register. This is similar to a wider version of PSHUFD, just operating on single-precision floating-point values.</p><p>Note: For the VEX.128.66.0F3A 04 instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruc-tion will #UD.</p><p>Note: For the VEX.256.66.0F3A 04 instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruc-tion will #UD.</p></span>", "url": "VPERMILPS.html", "tooltip": "(variable control version)"},
    "XSAVEC": {"html": "<p>Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The format of the XSAVE area is detailed in Section 13.4, 'XSAVE Area,” of <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>.</p><p>Section 13.9, 'Operation of XSAVEC,” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em> provides a detailed description of the operation of the XSAVEC instruction. The following items provide a high-level outline:</p><p>Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</p></span>", "url": "XSAVEC.html", "tooltip": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0."},
    "FXTRACT": {"html": "<p>Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0), and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original significand expressed as a floating-point value. The sign and significand of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true expo-nent of zero). The ST(1) register contains the value of the original operand’s true (unbiased) exponent expressed as a floating-point value. (The operation performed by this instruction is a superset of the IEEE-recommended logb(<em>x</em>) function.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to decimal representations (e.g., for printing or displaying).</p><p>If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of – ∞ is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FXTRACT.html", "tooltip": "Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0), and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original significand expressed as a floating-point value. The sign and significand of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true expo-nent of zero). The ST(1) register contains the value of the original operand’s true (unbiased) exponent expressed as a floating-point value. (The operation performed by this instruction is a superset of the IEEE-recommended logb(<em>x</em>) function.)"},
    "FIST": {"html": "<p>The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the desti-nation operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction also stores values in quadword integer format.</p><p>The following table shows the results obtained when storing various classes of numbers in integer format.</p><h3>Table 3-37.  FIST/FISTP Results</h3><table><tr><th>ST(0)</th><th>DEST</th></tr><tr><td>− ∞ or Value Too Large for DEST Format</td><td>*</td></tr><tr><td>F ≤ −1</td><td>− I</td></tr><tr><td>−1 &lt; F &lt; −0</td><td>**</td></tr><tr><td>− 0</td><td>0</td></tr><tr><td>+ 0</td><td>0</td></tr><tr><td>+ 0 &lt; F &lt; + 1</td><td>**</td></tr><tr><td>F ≥ + 1</td><td>+ I</td></tr><tr><td>+ ∞ or Value Too Large for DEST Format</td><td>*</td></tr><tr><td>NaN</td><td>*</td></tr><tr><td></td><td></td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>I</p><p>Means integer.</p><p>*</p><p>Indicates floating-point invalid-operation (#IA) exception.</p><p>** 0 or ±1, depending on the rounding mode.</p><p>If the source value is a non-integral value, it is rounded to an integer value, according to the rounding mode spec-ified by the RC field of the FPU control word.</p><p>If the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination operand. If the invalid-operation exception is masked, the integer indefinite value is stored in memory.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FIST:FISTP.html", "tooltip": "The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the desti-nation operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored."},
    "PMOVZX": {"html": "<p>Zero-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The destination register is YMM Register.</p><p>Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMOVZX.html", "tooltip": "Zero-extend the low byte/word/dword values in each word/dword/qword element of the source operand (second operand) to word/dword/qword integers and stored as packed data in the destination operand (first operand)."},
    "ROUNDPS": {"html": "<p>Round the 4 single-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single-precision floating-point value.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-15 lists the encoded values for rounding-mode field).</p><p>The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.</p><p>128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "ROUNDPS.html", "tooltip": "Round the 4 single-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single-precision floating-point value."},
    "XORPD": {"html": "<p>Performs a bitwise logical exclusive-OR of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "XORPD.html", "tooltip": "Performs a bitwise logical exclusive-OR of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register."},
    "BZHI": {"html": "<p>BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first operand) and clears the higher bits in the destination according to the INDEX value specified by the second source operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand is greater than OperandSize -1.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "BZHI.html", "tooltip": "BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first operand) and clears the higher bits in the destination according to the INDEX value specified by the second source operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand is greater than OperandSize -1."},
    "VFMSUBADD132PS": {"html": "<p>VFMSUBADD132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMSUBADD213PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFMSUBADD231PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMSUBADD132PS:VFMSUBADD213PS:VFMSUBADD231PS.html", "tooltip": "VFMSUBADD132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand)."},
    "RDRAND": {"html": "<p>Loads a hardware generated random value and store it in the destination register. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Other-wise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random value has been returned, otherwise it is expected to loop and retry execution of RDRAND (see <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 1</em>, Section 7.3.17, 'Random Number Generator Instructions”).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is available at all privilege levels.</p><p>In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit oper-ands. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "RDRAND.html", "tooltip": "Loads a hardware generated random value and store it in the destination register. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Other-wise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random value has been returned, otherwise it is expected to loop and retry execution of RDRAND (see <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 1</em>, Section 7.3.17, 'Random Number Generator Instructions”)."},
    "RDSEED": {"html": "<p>Loads a hardware generated random value and store it in the destination register. The random value is generated from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is expected to loop and retry execution of RDSEED (see Section 1.2).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The RDSEED instruction is available at all privilege levels. The RDSEED instruction executes normally either inside or outside a transaction region.</p><p>In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit oper-ands. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "RDSEED.html", "tooltip": "Loads a hardware generated random value and store it in the destination register. The random value is generated from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is expected to loop and retry execution of RDSEED (see Section 1.2)."},
    "RDTSCP": {"html": "<p>Loads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also loads the IA32_TSC_AUX MSR (address C000_0103H) into the ECX register. The EDX register is loaded with the high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See 'Time Stamp Counter” in Chapter 17 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B</em>, for specific details of the time stamp counter behavior.</p><p>When in protected or virtual 8086 mode, the time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSCP instruction as follows. When the TSD flag is clear, the RDTSCP instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0. (When in real-address mode, the RDTSCP instruction is always enabled.)</p><p>The RDTSCP instruction waits until all previous instructions have been executed before reading the counter. However,  subsequent instructions may begin execution before the read operation is performed.</p><p>The presence of the RDTSCP instruction is indicated by CPUID leaf 80000001H, EDX bit 27. If the bit is set to 1 then RDTSCP is present on the processor.</p><p>See 'Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p></span>", "url": "RDTSCP.html", "tooltip": "Loads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also loads the IA32_TSC_AUX MSR (address C000_0103H) into the ECX register. The EDX register is loaded with the high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared."},
    "FCMOVcc": {"html": "<p>Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-tion column above and in Chapter 8 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>. The source operand is always in the ST(i) register and the destination operand is always ST(0).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FCMOV<em>cc</em> instructions are useful for optimizing small IF constructions. They also help eliminate branching over-head for IF operations and the possibility of branch mispredictions by the processor.</p><p>A processor may not support the FCMOV<em>cc</em> instructions. Software can check if the FCMOV<em>cc</em> instructions are supported by checking the processor’s feature information with the CPUID instruction (see 'COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOV<em>cc</em> instructions are supported.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FCMOVcc.html", "tooltip": "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-tion column above and in Chapter 8 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>. The source operand is always in the ST(i) register and the destination operand is always ST(0)."},
    "PADDQ": {"html": "<p>Adds the first operand (destination operand) to the second operand (source operand) and stores the result in the destination operand. The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location, or it can be two packed quadword integers stored in an XMM register or an 128-bit memory location. The destination operand can be a quadword integer stored in an MMX technology register or two packed quadword integers stored in an XMM register. When packed quadword operands are used, a SIMD add is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note that the (V)PADDQ instruction can operate on either unsigned or signed (two’s complement notation) inte-gers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PADDQ.html", "tooltip": "Adds the first operand (destination operand) to the second operand (source operand) and stores the result in the destination operand. The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location, or it can be two packed quadword integers stored in an XMM register or an 128-bit memory location. The destination operand can be a quadword integer stored in an MMX technology register or two packed quadword integers stored in an XMM register. When packed quadword operands are used, a SIMD add is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored)."},
    "ANDNPS": {"html": "<p>Inverts the bits of the four packed single-precision floating-point values in the destination operand (first operand), performs a bitwise logical AND of the four packed single-precision floating-point values in the source operand (second operand) and the temporary inverted result, and stores the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "ANDNPS.html", "tooltip": "Inverts the bits of the four packed single-precision floating-point values in the destination operand (first operand), performs a bitwise logical AND of the four packed single-precision floating-point values in the source operand (second operand) and the temporary inverted result, and stores the result in the destination operand."},
    "BLENDPS": {"html": "<p>Packed single-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is '1', then the single-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "BLENDPS.html", "tooltip": "Packed single-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is '1', then the single-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied."},
    "FDIV": {"html": "<p>Divides the destination operand by the source operand and stores the result in the destination location. The desti-nation operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.</p><p>The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.</p><p>The FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.</p><p>If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.</p><p>The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs.</p><h3>Table 3-34.  FDIV/FDIVP/FIDIV Results</h3><p><strong>DEST</strong></p><p>− ∞</p><p>− F</p><p>− 0</p><p>+ 0</p><p>+ F</p><p>+ ∞</p><p>NaN</p><p>− ∞</p><p>+ 0</p><p>+ 0</p><p>− 0</p><p>− 0</p><p>*</p><p>*</p><p>NaN</p><p>− F</p><p>+ ∞</p><p>+ F</p><p>+ 0</p><p>− 0</p><p>− F</p><p>− ∞</p><p>NaN</p><p>− I</p><p>+ ∞</p><p>+ F</p><p>+ 0</p><p>− 0</p><p>− F</p><p>− ∞</p><p>NaN</p><p>− 0</p><p>+ ∞</p><p>− ∞</p><p><strong>SRC</strong></p><p>**</p><p>*</p><p>*</p><p>**</p><p>NaN</p><p>+ 0</p><p>− ∞</p><p>+ ∞</p><p>**</p><p>*</p><p>*</p><p>**</p><p>NaN</p><p>+ I</p><p>− ∞</p><p>− F</p><p>− 0</p><p>+ 0</p><p>+ F</p><p>+ ∞</p><p>NaN</p><p>+ F</p><p>− ∞</p><p>− F</p><p>− 0</p><p>+ 0</p><p>+ F</p><p>+ ∞</p><p>NaN</p><p>+ ∞</p><p>− 0</p><p>− 0</p><p>+ 0</p><p>+ 0</p><p>*</p><p>*</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p>NaN</p><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>I</p><p>Means integer.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>** Indicates floating-point zero-divide (#Z) exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FDIV:FDIVP:FIDIV.html", "tooltip": "Divides the destination operand by the source operand and stores the result in the destination location. The desti-nation operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format."},
    "CRC32": {"html": "<p>Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial 11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If the destination is an r64 register, then the 32-bit result is stored in the least significant double word and 00000000H is stored in the most significant double word of the r64 register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The initial value supplied in the destination operand is a double word integer stored in the r32 register or the least significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new input data in the source operand. Data contained in the source operand is processed in reflected bit order. This means that the most significant bit of the source operand is treated as the least significant bit of the quotient, and so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC.</p></span>", "url": "CRC32.html", "tooltip": "Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial 11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If the destination is an r64 register, then the 32-bit result is stored in the least significant double word and 00000000H is stored in the most significant double word of the r64 register."},
    "IDIV": {"html": "<p>Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magni-tude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand. RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.</p><p>See the summary chart at the beginning of this section for encoding data and limits. See Table 3-60.</p><h3>Table 3-60.  IDIV Results</h3><table><tr><th>Operand Size</th><th>Dividend</th><th>Divisor</th><th>Quotient</th><th>Remainder</th><th>Quotient Range</th></tr><tr><td><p>Word/byte</p><p>Doubleword/word</p><p>Quadword/doubleword</p><p>Doublequadword/ quadword</p></td><td><p>AX</p><p>DX:AX</p><p>EDX:EAX</p><p>RDX:RAX</p></td><td><p>r/m8</p><p>r/m16</p><p>r/m32</p><p>r/m64</p></td><td><p>AL</p><p>AX</p><p>EAX</p><p>RAX</p></td><td><p>AH</p><p>DX</p><p>EDX</p><p>RDX</p></td><td><p>−128 to +127</p><p>−32,768 to +32,767</p><p>−2<sup>31</sup> to 2<sup>31</sup> − 1</p><p>−2<sup>63</sup> to 2<sup>63</sup> − 1</p></td></tr></table></span>", "url": "IDIV.html", "tooltip": "Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor)."},
    "BEXTR": {"html": "<p>Extracts contiguous bits from the first source operand (the second operand) using an index value and length value specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH) beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is cleared if no bits are extracted.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "BEXTR.html", "tooltip": "Extracts contiguous bits from the first source operand (the second operand) using an index value and length value specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH) beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is cleared if no bits are extracted."},
    "DPPS": {"html": "<p>Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand) with the packed single-precision floats in the source (second operand) depending on a mask extracted from the high 4 bits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4] is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 1</em>.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The four resulting single-precision values are summed into an intermediate result. The intermediate result is condi-tionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte.</p><p>If a broadcast mask bit is '1', the intermediate result is copied to the corresponding dword element in the destina-tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.</p><p>DPPS follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4.7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-ated NaNs will have at least one NaN propagated to the destination.</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "DPPS.html", "tooltip": "Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand) with the packed single-precision floats in the source (second operand) depending on a mask extracted from the high 4 bits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4] is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 1</em>."},
    "PCMPGTB": {"html": "<p>Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source oper-ands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source</p><p>operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destina-tion and source operands.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PCMPGTB:PCMPGTW:PCMPGTD.html", "tooltip": "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s."},
    "INVLPG": {"html": "<p>Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.<sup>1</sup></p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must be 0 to execute this instruction.</p><p>The INVLPG instruction normally flushes TLB entries only for the specified page; however, in some cases, it may flush more entries, even the entire TLB. The instruction is guaranteed to invalidates only TLB entries associated with the current PCID. (If PCIDs are disabled — CR4.PCIDE = 0 — the current PCID is 000H.) The instruction also invalidates any global TLB entries for the specified page, regardless of PCID.</p><p>For more details on operations that flush the TLB, see 'MOV—Move to/from Control Registers” and Section 4.10.4.1, 'Operations that Invalidate TLBs and Paging-Structure Caches,” of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p><p>This instruction’s operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP.</p></span>", "url": "INVLPG.html", "tooltip": "Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.<sup>1</sup>"},
    "PMULHW": {"html": "<p>Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destina-tion operand. (Figure 4-8 shows this operation when using 64-bit operands.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>n 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p></span>", "url": "PMULHW.html", "tooltip": "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destina-tion operand. (Figure 4-8 shows this operation when using 64-bit operands.)"},
    "AESDEC": {"html": "<p>This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Use the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDEC-CLAST instruction.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "AESDEC.html", "tooltip": "This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand."},
    "FPREM1": {"html": "<p>Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or <strong>modulus</strong>), and stores the result in ST(0). The remainder represents the following value:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Remainder ← ST(0) − (Q ∗ ST(1))</p><p>Here, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)] toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the modulus, unless a partial remainder was computed (as described below).</p><p>This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.</p><h3>Table 3-42.  FPREM1 Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>ST(1)</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>ST(0)</th><td colspan='2'>− F</td><td colspan='2'>ST(0)</td><td colspan='2'>±F or −0</td><td colspan='2'>**</td><td colspan='2'>**</td><td colspan='2'>± F or − 0</td><td colspan='2'>ST(0)</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>− 0</td><td colspan='2'>-0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>+ 0</td><td colspan='2'>+0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ F</td><td colspan='2'>ST(0)</td><td colspan='2'>± F or + 0</td><td colspan='2'>**</td><td colspan='2'>**</td><td colspan='2'>± F or + 0</td><td colspan='2'>ST(0)</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ ∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>** Indicates floating-point zero-divide (#Z) exception.</p><p>When the result is 0, its sign is the same as that of the dividend. When the modulus is ∞, the result is equal to the value in ST(0).</p><p>The FPREM1 instruction computes the remainder specified in IEEE Standard 754. This instruction operates differ-ently from the FPREM instruction in the way that it rounds the quotient of ST(0) divided by ST(1) to an integer (see the 'Operation” section below).</p><p>Like the FPREM instruction, FPREM1 computes the remainder through iterative subtraction, but can reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than one half the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the <strong>partial remainder</strong>. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instructions in the loop.)</p><p>An important use of the FPREM1 instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU</p><p>status word. This information is important in argument reduction for the tangent function (using a modulus of π/4), because it locates the original angle in the correct one of eight sectors of the unit circle.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FPREM1.html", "tooltip": "Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or <strong>modulus</strong>), and stores the result in ST(0). The remainder represents the following value:"},
    "IRET": {"html": "<p>Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled 'Task Linking” in Chapter 7 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.</p><p>In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.</p><p>In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:</p><p>If the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure, without a task switch. The code segment being returned to must be equally or less privileged than the interrupt handler routine (as indicated by the RPL field of the code segment selector popped from the stack).</p><p>As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is to virtual-8086 mode, the processor also pops the data segment registers from the stack.</p><p>If the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET instruction is executed.</p><p>If the NT flag is set and the processor is in IA-32e mode, the IRET instruction causes a general protection excep-tion.</p><p>If nonmaskable interrupts (NMIs) are blocked (see Section 6.7.1, 'Handling Multiple NMIs” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>), execution of the IRET instruction unblocks NMIs.</p><p>This unblocking occurs even if the instruction causes a fault. In such a case, NMIs are unmasked before the excep-tion handler is invoked.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.W prefix promotes operation to 64 bits (IRETQ). See the summary chart at the beginning of this section for encoding data and limits.</p><p>See 'Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p></span>", "url": "IRET:IRETD.html", "tooltip": "Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled 'Task Linking” in Chapter 7 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>."},
    "UNPCKHPS": {"html": "<p>Performs an interleaved unpack of the high-order single-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-24. The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 800308.019995 379.199990 146.880000' height='220.32'><text y='800331.407484' x='143.58' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='800377.427384' x='148.0201' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='800439.227684' x='143.58' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='800319.9' x='169.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800319.9' x='313.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800319.9' x='385.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800364.9' x='169.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800364.9' x='313.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800364.9' x='385.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800427.9' x='169.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800427.9' x='241.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800427.9' x='313.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800427.9' x='385.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='800319.9' x='241.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.06'></rect><rect y='800364.9' x='241.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.06'></rect><path style='stroke:black' d='M169.740000,800319.659990 L169.740000,800320.140000 L241.980000,800320.140000 L241.980000,800319.659990 '></path><path style='stroke:black' d='M241.740000,800319.659990 L241.740000,800320.140000 L314.040000,800320.140000 L314.040000,800319.659990 '></path><path style='stroke:black' d='M313.800000,800319.659990 L313.800000,800320.140000 L386.040000,800320.140000 L386.040000,800319.659990 '></path><path style='stroke:black' d='M385.800000,800319.659990 L385.800000,800320.140000 L458.040000,800320.140000 L458.040000,800319.659990 '></path><path style='stroke:black' d='M169.500000,800319.660000 L169.500000,800337.900000 L169.980000,800337.900000 L169.980000,800319.660000 '></path><path style='stroke:black' d='M241.500000,800319.660000 L241.500000,800337.900000 L241.980000,800337.900000 L241.980000,800319.660000 '></path><path style='stroke:black' d='M313.560000,800319.660000 L313.560000,800337.900000 L314.040010,800337.900000 L314.040010,800319.660000 '></path><path style='stroke:black' d='M385.560000,800319.660000 L385.560000,800337.900000 L386.040010,800337.900000 L386.040010,800319.660000 '></path><path style='stroke:black' d='M241.500000,800319.900000 L241.500000,800338.140000 L241.980000,800338.140000 L241.980000,800319.900000 '></path><path style='stroke:black' d='M313.560000,800319.900000 L313.560000,800338.140000 L314.040010,800338.140000 L314.040010,800319.900000 '></path><path style='stroke:black' d='M385.560000,800319.900000 L385.560000,800338.140000 L386.040010,800338.140000 L386.040010,800319.900000 '></path><path style='stroke:black' d='M457.560000,800319.900000 L457.560000,800338.140000 L458.039980,800338.140000 L458.039980,800319.900000 '></path><path style='stroke:black' d='M169.500000,800337.659990 L169.500000,800338.140000 L241.740000,800338.140000 L241.740000,800337.659990 '></path><path style='stroke:black' d='M241.500000,800337.659990 L241.500000,800338.140000 L313.800000,800338.140000 L313.800000,800337.659990 '></path><path style='stroke:black' d='M313.560000,800337.659990 L313.560000,800338.140000 L385.800000,800338.140000 L385.800000,800337.659990 '></path><path style='stroke:black' d='M385.560000,800337.659990 L385.560000,800338.140000 L457.800000,800338.140000 L457.800000,800337.659990 '></path><path style='stroke:black' d='M169.740000,800364.659990 L169.740000,800365.140000 L241.980000,800365.140000 L241.980000,800364.659990 '></path><path style='stroke:black' d='M241.740000,800364.659990 L241.740000,800365.140000 L314.040000,800365.140000 L314.040000,800364.659990 '></path><path style='stroke:black' d='M313.800000,800364.659990 L313.800000,800365.140000 L386.040000,800365.140000 L386.040000,800364.659990 '></path><path style='stroke:black' d='M385.800000,800364.659990 L385.800000,800365.140000 L458.040000,800365.140000 L458.040000,800364.659990 '></path><path style='stroke:black' d='M169.500000,800364.660000 L169.500000,800382.900000 L169.980000,800382.900000 L169.980000,800364.660000 '></path><path style='stroke:black' d='M241.500000,800364.660000 L241.500000,800382.900000 L241.980000,800382.900000 L241.980000,800364.660000 '></path><path style='stroke:black' d='M313.560000,800364.660000 L313.560000,800382.900000 L314.040010,800382.900000 L314.040010,800364.660000 '></path><path style='stroke:black' d='M385.560000,800364.660000 L385.560000,800382.900000 L386.040010,800382.900000 L386.040010,800364.660000 '></path><path style='stroke:black' d='M241.500000,800364.900000 L241.500000,800383.140000 L241.980000,800383.140000 L241.980000,800364.900000 '></path><path style='stroke:black' d='M313.560000,800364.900000 L313.560000,800383.140000 L314.040010,800383.140000 L314.040010,800364.900000 '></path><path style='stroke:black' d='M385.560000,800364.900000 L385.560000,800383.140000 L386.040010,800383.140000 L386.040010,800364.900000 '></path><path style='stroke:black' d='M457.560000,800364.900000 L457.560000,800383.140000 L458.039980,800383.140000 L458.039980,800364.900000 '></path><path style='stroke:black' d='M169.500000,800382.659990 L169.500000,800383.140000 L241.740000,800383.140000 L241.740000,800382.659990 '></path><path style='stroke:black' d='M241.500000,800382.659990 L241.500000,800383.140000 L313.800000,800383.140000 L313.800000,800382.659990 '></path><path style='stroke:black' d='M313.560000,800382.659990 L313.560000,800383.140000 L385.800000,800383.140000 L385.800000,800382.659990 '></path><path style='stroke:black' d='M385.560000,800382.659990 L385.560000,800383.140000 L457.800000,800383.140000 L457.800000,800382.659990 '></path><path style='stroke:black' d='M207.480000,800382.780010 L207.480000,800383.020000 L207.960010,800383.020000 L207.960010,800382.780010 '></path><path style='stroke:black' d='M207.480000,800383.020000 L207.480000,800419.080000 L207.960010,800419.080000 L207.960010,800383.020000 '></path><path style='stroke:black' d='M207.480000,800418.840000 L207.480000,800420.040000 L207.960010,800420.040000 L207.960010,800418.840000 '></path><path style='stroke:black' d='M169.140000,800427.659990 L169.140000,800428.140000 L241.380000,800428.140000 L241.380000,800427.659990 '></path><path style='stroke:black' d='M241.140000,800427.659990 L241.140000,800428.140000 L313.380000,800428.140000 L313.380000,800427.659990 '></path><path style='stroke:black' d='M313.140000,800427.659990 L313.140000,800428.140000 L385.380000,800428.140000 L385.380000,800427.659990 '></path><path style='stroke:black' d='M385.140000,800427.659990 L385.140000,800428.140000 L457.380000,800428.140000 L457.380000,800427.659990 '></path><path style='stroke:black' d='M168.900000,800427.660000 L168.900000,800445.900000 L169.380000,800445.900000 L169.380000,800427.660000 '></path><path style='stroke:black' d='M240.900000,800427.660000 L240.900000,800445.900000 L241.379980,800445.900000 L241.379980,800427.660000 '></path><path style='stroke:black' d='M312.900000,800427.660000 L312.900000,800445.900000 L313.380010,800445.900000 L313.380010,800427.660000 '></path><path style='stroke:black' d='M384.900000,800427.660000 L384.900000,800445.900000 L385.380010,800445.900000 L385.380010,800427.660000 '></path><path style='stroke:black' d='M240.900000,800427.900000 L240.900000,800446.140000 L241.379980,800446.140000 L241.379980,800427.900000 '></path><path style='stroke:black' d='M312.900000,800427.900000 L312.900000,800446.140000 L313.380010,800446.140000 L313.380010,800427.900000 '></path><path style='stroke:black' d='M384.900000,800427.900000 L384.900000,800446.140000 L385.380010,800446.140000 L385.380010,800427.900000 '></path><path style='stroke:black' d='M456.900000,800427.900000 L456.900000,800446.140000 L457.380010,800446.140000 L457.380010,800427.900000 '></path><path style='stroke:black' d='M168.900000,800445.659990 L168.900000,800446.140000 L241.140000,800446.140000 L241.140000,800445.659990 '></path><path style='stroke:black' d='M240.900000,800445.659990 L240.900000,800446.140000 L313.140000,800446.140000 L313.140000,800445.659990 '></path><path style='stroke:black' d='M312.900000,800445.659990 L312.900000,800446.140000 L385.140000,800446.140000 L385.140000,800445.659990 '></path><path style='stroke:black' d='M384.900000,800445.659990 L384.900000,800446.140000 L457.140000,800446.140000 L457.140000,800445.659990 '></path><text y='800331.407484' x='204.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X3</text><text y='800331.407484' x='345.069744' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>X1</text><text y='800331.407484' x='417.076476' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>X0</text><text y='800376.407484' x='204.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>Y3</text><text y='800376.407484' x='339.364044' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y1</text><text y='800376.407484' x='411.370776' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y0</text><text y='800439.647484' x='203.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='800439.647484' x='275.758152' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='800439.647484' x='347.756904' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='800439.647484' x='418.438956' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='800331.407484' x='273.063012' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>X2</text><text y='800376.407484' x='274.020612' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y2</text></svg><h3>Figure 4-24.  UNPCKHPS Instruction High Unpack and Interleave Operation</h3><p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: T second source can be an XMM register or an 128-bit memory location. The destina-tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p></span>", "url": "UNPCKHPS.html", "tooltip": "Performs an interleaved unpack of the high-order single-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-24. The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register."},
    "MINPS": {"html": "<p>Performs an SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "MINPS.html", "tooltip": "Performs an SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand."},
    "PCLMULQDQ": {"html": "<p>Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use according to Table 4-10, other bits of the immediate byte are ignored.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 4-10.  PCLMULQDQ Quadword Selection of Immediate Byte</h3><table><tr><th>Imm[4]</th><th>Imm[0]</th><th>PCLMULQDQ Operation</th></tr><tr><td>0</td><td>0</td><td>CL_MUL( SRC2<sup>1</sup>[63:0], SRC1[63:0] )</td></tr><tr><td>0</td><td>1</td><td>CL_MUL( SRC2[63:0], SRC1[127:64] )</td></tr><tr><td>1</td><td>0</td><td>CL_MUL( SRC2[127:64], SRC1[63:0] )</td></tr><tr><td>1</td><td>1</td><td>CL_MUL( SRC2[127:64], SRC1[127:64] )</td></tr></table><p><strong>NOTES:</strong></p><p>1. SRC2 denotes the second source operand, which can be a register or memory; SRC1 denotes the first source and destination oper-</p><p>and.</p><p> The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>Compilers and assemblers may implement the following pseudo-op syntax to simply programming and emit the required encoding for Imm8.</p><h3>Table 4-11.  Pseudo-Op and PCLMULQDQ Implementation</h3><table><tr><th>Pseudo-Op</th><th>Imm8 Encoding</th></tr><tr><th>PCLMULLQLQDQ<em> xmm1, xmm2</em></th><th>0000_0000B</th></tr><tr><th>PCLMULHQLQDQ<em> xmm1, xmm2</em></th><th>0000_0001B</th></tr><tr><th>PCLMULLQHDQ<em> xmm1, xmm2</em></th><th>0001_0000B</th></tr><tr><th>PCLMULHQHDQ<em> xmm1, xmm2</em></th><th>0001_0001B</th></tr></table></span>", "url": "PCLMULQDQ.html", "tooltip": "Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use according to Table 4-10, other bits of the immediate byte are ignored."},
    "CVTTPS2DQ": {"html": "<p>Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed doubleword integers in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, a truncated (round toward zero) value is returned.If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operation is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "CVTTPS2DQ.html", "tooltip": "Converts four or eight packed single-precision floating-point values in the source operand to four or eight signed doubleword integers in the destination operand."},
    "XABORT": {"html": "<p>XABORT forces an RTM abort. Following an RTM abort, the logical processor resumes execution at the fallback address computed through the outermost XBEGIN instruction. The EAX register is updated to reflect an XABORT instruction caused the abort, and the imm8 argument will be provided in bits 31:24 of EAX.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "XABORT.html", "tooltip": "XABORT forces an RTM abort. Following an RTM abort, the logical processor resumes execution at the fallback address computed through the outermost XBEGIN instruction. The EAX register is updated to reflect an XABORT instruction caused the abort, and the imm8 argument will be provided in bits 31:24 of EAX."},
    "PSUBSB": {"html": "<p>Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following para-graphs.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.</p><p>The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-nation register remain unchanged.</p><p>VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSUBSB:PSUBSW.html", "tooltip": "Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following para-graphs."},
    "CLFLUSH": {"html": "<p>Invalidates the cache line that contains the linear address specified with the source operand from all levels of the processor cache hierarchy (data and instruction). The invalidation is broadcast throughout the cache coherence domain. If, at any level of the cache hierarchy, the line is inconsistent with memory (dirty) it is written to memory before invalidation. The source operand is a byte memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (bit 19 of the EDX register, see 'CPUID—CPU Identification” in this chapter). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).</p><p>The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCH<em>h </em>instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCH<em>h</em> instructions or any of the speculative fetching mechanisms (that is, data can be specula-tively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).</p><p>CLFLUSH is only ordered by the MFENCE instruction. It is not guaranteed to be ordered by any other fencing or seri-alizing instructions or by another CLFLUSH instruction. For example, software can use an MFENCE instruction to ensure that previous stores are included in the write-back.</p><p>The CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults asso-ciated with a byte load (and in addition, a CLFLUSH instruction is allowed to flush a linear address in an execute-only segment). Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.</p><p>The CLFLUSH instruction was introduced with the SSE2 extensions; however, because it has its own CPUID feature flag, it can be implemented in IA-32 processors that do not include the SSE2 extensions. Also, detecting the pres-ence of the SSE2 extensions with the CPUID instruction does not guarantee that the CLFLUSH instruction is imple-mented in the processor.</p><p>CLFLUSH operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "CLFLUSH.html", "tooltip": "Invalidates the cache line that contains the linear address specified with the source operand from all levels of the processor cache hierarchy (data and instruction). The invalidation is broadcast throughout the cache coherence domain. If, at any level of the cache hierarchy, the line is inconsistent with memory (dirty) it is written to memory before invalidation. The source operand is a byte memory location."},
    "WBINVD": {"html": "<p>Writes back all modified cache lines in the processor’s internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>After executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals. The amount of time or cycles for WBINVD to complete will vary due to size and other factors of different cache hierarchies. As a consequence, the use of the WBINVD instruction can have an impact on logical processor interrupt/event response time. Additional information of WBINVD behavior in a cache hierarchy with hierarchical sharing topology can be found in Chapter 2 of the <em>Intel® 64 and IA-32 Architec-tures Software Developer’s Manual, Volume 3A</em>.</p><p>The WBINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see 'Serializing Instructions” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>).</p><p>In situations where cache coherency with main memory is not a concern, software can use the INVD instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "WBINVD.html", "tooltip": "Writes back all modified cache lines in the processor’s internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated."},
    "MOVHPD": {"html": "<p>This instruction cannot be used for register to register or memory to memory moves.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p><strong>128-bit Legacy SSE load:</strong></p><p>Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. The upper 128-bits of the corresponding YMM destination register are preserved.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p><strong>VEX.128 encoded load:</strong></p><p>Loads a double-precision floating-point value from the source 64-bit memory operand (third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from second XMM register (second operand) are stored in the lower 64-bits of the destination. The upper 128-bits of the destination YMM register are zeroed.</p><p><strong>128-bit store:</strong></p><p>Stores a double-precision floating-point value from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).</p><p>Note: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has the same behavior as the existing 66 0F 17 store. For VMOVHPD (store) (VEX.128.66.0F 17 /r) instruction version, VEX.vvvv is reserved and must be 1111b other-wise instruction will #UD.</p><p>If VMOVHPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "MOVHPD.html", "tooltip": "This instruction cannot be used for register to register or memory to memory moves."},
    "OUT": {"html": "<p>Copies the value from the second operand (source operand) to the I/O port specified with the destination operand (first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register. Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source operand allows I/O ports from 0 to 65,535 to be accessed.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.</p><p>At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.</p><p>This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 16, 'Input/Output,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more infor-mation on accessing I/O ports in the I/O address space.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "OUT.html", "tooltip": "Copies the value from the second operand (source operand) to the I/O port specified with the destination operand (first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register. Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source operand allows I/O ports from 0 to 65,535 to be accessed."},
    "PSUBUSB": {"html": "<p>Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>These instructions can operate on either 64-bit or 128-bit operands.</p><p>The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.</p><p>The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-nation register remain unchanged.</p><p>VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSUBUSB:PSUBUSW.html", "tooltip": "Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs."},
    "XBEGIN": {"html": "<p>The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in trans-actional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execu-tion. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>On an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The fallback address following an abort is computed from the outermost XBEGIN instruction.</p></span>", "url": "XBEGIN.html", "tooltip": "The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in trans-actional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execu-tion. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort."},
    "ADDSS": {"html": "<p>Adds the low single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the single-precision floating-point result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. See Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a scalar single-precision floating-point operation.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "ADDSS.html", "tooltip": "Adds the low single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the single-precision floating-point result in the destination operand."},
    "VFNMSUB132PS": {"html": "<p>VFNMSUB132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four or eight packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-preci-sion floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFNMSUB213PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the four or eight packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFNMSUB231PS: Multiplies the four or eight packed single-precision floating-point values from the second source to the four or eight packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four or eight packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a</p><p>XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMSUB132PS:VFNMSUB213PS:VFNMSUB231PS.html", "tooltip": "VFNMSUB132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four or eight packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-preci-sion floating-point values to the destination operand (first source operand)."},
    "FCOS": {"html": "<p>Computes the cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −2<sup>63</sup> to +2<sup>63</sup>. The following table shows the results obtained when taking the cosine of various classes of numbers.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-33.  FCOS Results</h3><table><tr><th>ST(0) SRC</th><th>ST(0) DEST</th></tr><tr><td>− ∞</td><td>*</td></tr><tr><td>− F</td><td>−1 to +1</td></tr><tr><td>− 0</td><td>+ 1</td></tr><tr><td>+ 0</td><td>+ 1</td></tr><tr><td>+ F</td><td>− 1 to + 1</td></tr><tr><td>+ ∞</td><td>*</td></tr><tr><td>NaN</td><td>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 2<sup>63</sup> to +2<sup>63</sup> can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π or by using the FPREM instruction with a divisor of 2π. See the section titled 'Pi” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for a discussion of the proper value to use for π in performing such reductions.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FCOS.html", "tooltip": "Computes the cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −2<sup>63</sup> to +2<sup>63</sup>. The following table shows the results obtained when taking the cosine of various classes of numbers."},
    "CVTSS2SD": {"html": "<p>Converts a single-precision floating-point value in the source operand (second operand) to a double-precision floating-point value in the destination operand (first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand, and the high quadword is left unchanged.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "CVTSS2SD.html", "tooltip": "Converts a single-precision floating-point value in the source operand (second operand) to a double-precision floating-point value in the destination operand (first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand, and the high quadword is left unchanged."},
    "CVTTPS2PI": {"html": "<p>Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "CVTTPS2PI.html", "tooltip": "Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register."},
    "SUBPD": {"html": "<p>Performs a SIMD subtract of the two packed double-precision floating-point values in the source operand (second operand) from the two packed double-precision floating-point values in the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: T second source can be an XMM register or an 128-bit memory location. The destina-tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "SUBPD.html", "tooltip": "Performs a SIMD subtract of the two packed double-precision floating-point values in the source operand (second operand) from the two packed double-precision floating-point values in the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation."},
    "VPERM2F128": {"html": "<p>Permute 128 bit floating-point-containing fields from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Y1</p><p>Y0</p><p>SRC2</p><p>X1</p><p>X0</p><p>SRC1</p><p>X0, X1, Y0, or Y1</p><p>DEST</p><p>X0, X1, Y0, or Y1</p><h3>Figure 4-42.  VPERM2F128 Operation</h3><p>Imm8[1:0] select the source for the first destination 128-bit field, imm8[5:4] select the source for the second destination field. If imm8[3] is set, the low 128-bit field is zeroed. If imm8[7] is set, the high 128-bit field is zeroed.</p><p>VEX.L must be 1, otherwise the instruction will #UD.</p></span>", "url": "VPERM2F128.html", "tooltip": "Permute 128 bit floating-point-containing fields from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register."},
    "ADDSUBPD": {"html": "<p>Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the corresponding double-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered double-precision floating-point values from the second source operand from the corresponding double-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-3.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><svg width='541.17' viewBox='130.080000 17532.480000 360.780000 138.990000' height='208.485'><text y='17550.0581139' x='229.8614' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='116.9083839'>ADDSUBPD xmm1, xmm2/m128</text><text y='17575.3711139' x='436.3147' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='44.0096503'>xmm2/m128</text><text y='17575.3716139' x='201.8456' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:64]</text><text y='17575.3716139' x='350.3017' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[63:0]</text><text y='17618.9479139' x='436.3147' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='32.3052114'>RESULT:</text><text y='17623.7485139' x='149.9333' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='132.7329773'>xmm1[127:64] + xmm2/m128[127:64]</text><text y='17623.7485139' x='303.8498' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='112.9322348'>xmm1[63:0] - xmm2/m128[63:0]</text><text y='17628.5483139' x='436.3147' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='17647.3994139' x='201.8555' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:64]</text><text y='17647.3994139' x='350.31146689' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[63:0]</text><rect y='17533.224' x='130.803' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='126.005' width='360.015'></rect><path style='stroke:black' d='M216.306000,17602.316000 L216.306000,17586.105000 '></path><path style='stroke:black' d='M360.312000,17602.316000 L360.312000,17586.105000 '></path><path style='stroke:black' d='M219.066000,17601.956000 L216.306000,17607.476000 L213.546000,17601.956000 L219.066000,17601.956000 '></path><path style='stroke:black' d='M363.072000,17601.956000 L360.312000,17607.476000 L357.552000,17601.956000 L363.072000,17601.956000 '></path><rect y='17533.224' x='130.803' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='126.005' width='360.015'></rect><rect y='17559.1' x='144.303' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='17607.477' x='144.303' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='17607.477' x='288.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='17559.1' x='288.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='17559.1' x='144.303' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='17607.477' x='144.303' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='17607.477' x='288.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='17559.1' x='288.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect></svg><h3>Figure 3-3.  ADDSUBPD—Packed Double-FP Add/Subtract</h3></span>", "url": "ADDSUBPD.html", "tooltip": "Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the corresponding double-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered double-precision floating-point values from the second source operand from the corresponding double-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand."},
    "RDFSBASE": {"html": "<p>Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.</p><p>This instruction is supported only in 64-bit mode.</p></span>", "url": "RDFSBASE:RDGSBASE.html", "tooltip": "Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address."},
    "PMAXUD": {"html": "<p>Compares packed unsigned dword integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMAXUD.html", "tooltip": "Compares packed unsigned dword integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand."},
    "MULX": {"html": "<p>Performs an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand (the third operand) and stores the low half of the result in the second destination (second operand), the high half of the result in the first destination operand (first operand), without reading or writing the arithmetic flags. This enables efficient programming where the software can interleave add with carry operations and multiplications.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the first and second operand are identical, it will contain the high half of the multiplication result.</p><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "MULX.html", "tooltip": "Performs an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand (the third operand) and stores the low half of the result in the second destination (second operand), the high half of the result in the first destination operand (first operand), without reading or writing the arithmetic flags. This enables efficient programming where the software can interleave add with carry operations and multiplications."},
    "AESENC": {"html": "<p>This instruction performs a single round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Use the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENC-CLAST instruction.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "AESENC.html", "tooltip": "This instruction performs a single round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand."},
    "SFENCE": {"html": "<p>Performs a serializing operation on all store-to-memory instructions that were issued prior the SFENCE instruction. This serializing operation guarantees that every store instruction that precedes the SFENCE instruction in program order becomes globally visible before any store instruction that follows the SFENCE instruction. The SFENCE instruction is ordered with respect to store instructions, other SFENCE instructions, any LFENCE and MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to load instructions.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The SFENCE instruction provides a performance-efficient way of ensuring store ordering between routines that produce weakly-ordered results and routines that consume this data.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p><p>Specification of the instruction's opcode above indicates a ModR/M byte of F8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, SFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 8-F.</p></span>", "url": "SFENCE.html", "tooltip": "Performs a serializing operation on all store-to-memory instructions that were issued prior the SFENCE instruction. This serializing operation guarantees that every store instruction that precedes the SFENCE instruction in program order becomes globally visible before any store instruction that follows the SFENCE instruction. The SFENCE instruction is ordered with respect to store instructions, other SFENCE instructions, any LFENCE and MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to load instructions."},
    "MOV-1": {"html": "<p>Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purpose register or the contents of a general purpose register to a control register. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. (See 'Control Registers” in Chapter 2 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for a detailed description of the flags and fields in the control registers.) This instruction can be executed only when the current privilege level is 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the opcode level, the <em>reg</em> field within the ModR/M byte specifies which of the control registers is loaded or read. The 2 bits in the <em>mod </em>field are ignored. The <em>r/m</em> field specifies the general-purpose register loaded or read. Attempts to reference CR1, CR5, CR6, CR7, and CR9–CR15 result in undefined opcode (#UD) exceptions.</p><p>When loading control registers, programs should not attempt to change the reserved bits; that is, always set reserved bits to the value previously read. An attempt to change CR4's reserved bits will cause a general protection fault. Reserved bits in CR0 and CR3 remain clear after any load of those registers; attempts to set them have no impact. On Pentium 4, Intel Xeon and P6 family processors, CR0.ET remains set after any load of CR0; attempts to clear this bit have no impact.</p><p>In certain cases, these instructions have the side effect of invalidating entries in the TLBs and the paging-structure caches. See Section 4.10.4.1, 'Operations that Invalidate TLBs and Paging-Structure Caches,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em> for details.</p><p>The following side effects are implementation-specific for the Pentium 4, Intel Xeon, and P6 processor family: when modifying PE or PG in register CR0, or PSE or PAE in register CR4, all TLB entries are flushed, including global entries. Software should not depend on this functionality in all Intel 64 or IA-32 processors.</p><p>In 64-bit mode, the instruction’s default operation size is 64 bits. The REX.R prefix must be used to access CR8. Use of REX.B permits access to additional registers (R8-R15). Use of the REX.W prefix or 66H prefix is ignored. Use of</p><p>the REX.R prefix to specify a register other than CR8 causes an invalid-opcode exception. See the summary chart at the beginning of this section for encoding data and limits.</p><p>If CR4.PCIDE = 1, bit 63 of the source operand to MOV to CR3 determines whether the instruction invalidates entries in the TLBs and the paging-structure caches (see Section 4.10.4.1, 'Operations that Invalidate TLBs and Paging-Structure Caches,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>). The instruction does not modify bit 63 of CR3, which is reserved and always 0.</p><p>See 'Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p></span>", "url": "MOV-1.html", "tooltip": "Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purpose register or the contents of a general purpose register to a control register. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. (See 'Control Registers” in Chapter 2 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for a detailed description of the flags and fields in the control registers.) This instruction can be executed only when the current privilege level is 0."},
    "CVTSS2SI": {"html": "<p>Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary chart at the begin-ning of this section for encoding data and limits.</p><p>Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary chart at the beginning of this section for encoding data and limits.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "CVTSS2SI.html", "tooltip": "Converts a single-precision floating-point value in the source operand (second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register."},
    "PUSHF": {"html": "<p>Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions reverse the operation of the POPF/POPFD instructions.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more information about the EFLAGS register.</p><p>The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.</p><p>In 64-bit mode, the instruction’s default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, values for these flags are cleared in the RFLAGS image stored on the stack.</p><p>When in virtual-8086 mode and the I/O privilege level (IOPL) is less than 3, the PUSHF/PUSHFD instruction causes a general protection exception (#GP).</p><p>In the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS excep-tion is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p></span>", "url": "PUSHF:PUSHFD.html", "tooltip": "Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions reverse the operation of the POPF/POPFD instructions."},
    "RORX": {"html": "<p>Rotates the bits of second operand right by the count value specified in imm8 without affecting arithmetic flags. The RORX instruction does not read or write the arithmetic flags.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "RORX.html", "tooltip": "Rotates the bits of second operand right by the count value specified in imm8 without affecting arithmetic flags. The RORX instruction does not read or write the arithmetic flags."},
    "SYSEXIT": {"html": "<p>Executes a fast return to privilege level 3 user code. SYSEXIT is a companion instruction to the SYSENTER instruc-tion. The instruction is optimized to provide the maximum performance for returns from system procedures executing at protections levels 0 to user procedures executing at protection level 3. It must be executed from code executing at privilege level 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>With a 64-bit operand size, SYSEXIT remains in 64-bit mode; otherwise, it either enters compatibility mode (if the logical processor is in IA-32e mode) or remains in protected mode (if it is not).</p><p>Prior to executing SYSEXIT, software must specify the privilege level 3 code segment and code entry point, and the privilege level 3 stack segment and stack pointer by writing values into the following MSR and general-purpose registers:</p><p>The IA32_SYSENTER_CS MSR can be read from and written to using RDMSR and WRMSR.</p><p>While SYSEXIT loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and SS descriptor caches are <strong>not</strong> loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSEXIT instruction does not ensure this correspondence.</p><p>The SYSEXIT instruction can be invoked from all operating modes except real-address mode and virtual-8086 mode.</p><p>The SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor. The availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually present. For example:</p><p>IF CPUID SEP bit is set</p><p>THEN IF (Family = 6) and (Model &lt; 3) and (Stepping &lt; 3)</p><p>THEN</p><p>SYSENTER/SYSEXIT_Not_Supported; FI;</p><p>ELSE</p><p>SYSENTER/SYSEXIT_Supported; FI;</p><p>FI;</p><p>When the CPUID instruction is executed on the Pentium Pro processor (model 1), the processor returns a the SEP flag as set, but does not support the SYSENTER/SYSEXIT instructions.</p></span>", "url": "SYSEXIT.html", "tooltip": "Executes a fast return to privilege level 3 user code. SYSEXIT is a companion instruction to the SYSENTER instruc-tion. The instruction is optimized to provide the maximum performance for returns from system procedures executing at protections levels 0 to user procedures executing at protection level 3. It must be executed from code executing at privilege level 0."},
    "VGATHERDPD": {"html": "<p>The instruction conditionally loads up to 2 or 4 double-precision floating-point values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-fied by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.</p><p>Using dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 double-precision floating-point values from the VSIB addressing memory operand, and updates the destination register.</p><p>This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set).  When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero.  If any traps or interrupts are pending from already gath-ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.</p><p>If the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered.  This instruction sets those parts to zero.  It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.</p><p>VEX.128 version: The instruction will gather two double-precision floating-point values.  For dword indices, only the lower two indices in the vector index register are used.</p><p>VEX.256 version: The instruction will gather four double-precision floating-point values.  For dword indices, only the lower four indices in the vector index register are used.</p><p>Note that:</p></span>", "url": "VGATHERDPD:VGATHERQPD.html", "tooltip": "The instruction conditionally loads up to 2 or 4 double-precision floating-point values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor."},
    "XADD": {"html": "<p>Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p></span>", "url": "XADD.html", "tooltip": "Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register."},
    "PREFETCHWT1": {"html": "<p>Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by an intent to write hint (so that data is brought into ‘Exclusive’ state via a request for ownership) and a locality hint:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte. Use of any ModR/M value other than the specified ones will lead to unpredictable behavior.)</p><p>If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.</p><p>The PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.</p><p>The implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.</p><p>It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHh instruction is also unordered with respect to CLFLUSH instructions, other PREFETCHh instructions, or any other general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "PREFETCHWT1.html", "tooltip": "Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by an intent to write hint (so that data is brought into ‘Exclusive’ state via a request for ownership) and a locality hint:"},
    "ORPD": {"html": "<p>Performs a bitwise logical OR of the two or four packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: If VORPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "ORPD.html", "tooltip": "Performs a bitwise logical OR of the two or four packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand"},
    "MOV": {"html": "<p>Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, a doubleword, or a quadword.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode excep-tion (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.</p><p>If the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the 'Operation” algorithm below). The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector.</p><p>A NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP) and no memory reference occurs.</p><p>Loading the SS register with a MOV instruction inhibits all interrupts until after the execution of the next instruc-tion. This operation allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP, <strong>stack-pointer value</strong>) before an interrupt occurs<sup>1</sup>. Be aware that the LSS instruction offers a more efficient method of loading the SS and ESP registers.</p><p>When operating in 32-bit mode and moving data between a segment register and a general-purpose register, the 32-bit IA-32 processors do not require the use of the 16-bit operand-size prefix (a byte with the value 66H) with</p><p>1.</p><p>If a code instruction breakpoint (for debug) is placed on an instruction located immediately after a MOV SS instruction, the break-point may not be triggered. However, in a sequence of instructions that load the SS register, only the first instruction in the sequence is guaranteed to delay an interrupt.</p><p>In the following sequence, interrupts may be recognized before MOV ESP, EBP executes:</p><p>MOV SS, EDX MOV SS, EAX MOV ESP, EBP</p><p>this instruction, but most assemblers will insert it if the standard form of the instruction is used (for example, MOV DS, AX). The processor will execute this instruction correctly, but it will usually require an extra clock. With most assemblers, using the instruction form MOV DS, EAX will avoid this unneeded 66H prefix. When the processor executes the instruction with a 32-bit general-purpose register, it assumes that the 16 least-significant bits of the general-purpose register are the destination or source operand. If the register is a destination operand, the resulting value in the two high-order bytes of the register is implementation dependent. For the Pentium 4, Intel Xeon, and P6 family processors, the two high-order bytes are filled with zeros; for earlier 32-bit IA-32 processors, the two high order bytes are undefined.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOV.html", "tooltip": "Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, a doubleword, or a quadword."},
    "BLENDVPS": {"html": "<p>Conditionally copy each dword data element of single-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Each quadword element of the destination operand is copied from:</p><p>The register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPS with a VEX prefix will cause #UD.</p><p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.</p><p>VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction will #UD.</p><p>VBLENDVPS permits the mask to be any XMM or YMM register. In contrast, BLENDVPS treats XMM0 implicitly as the mask and do not support non-destructive destination operation.</p></span>", "url": "BLENDVPS.html", "tooltip": "Conditionally copy each dword data element of single-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register."},
    "SUBPS": {"html": "<p>Performs a SIMD subtract of the four packed single-precision floating-point values in the source operand (second operand) from the four packed single-precision floating-point values in the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "SUBPS.html", "tooltip": "Performs a SIMD subtract of the four packed single-precision floating-point values in the source operand (second operand) from the four packed single-precision floating-point values in the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation."},
    "AESDECLAST": {"html": "<p>This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "AESDECLAST.html", "tooltip": "This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand."},
    "FRSTOR": {"html": "<p>Loads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruc-tion.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following the operating environment image.</p><p>The FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE instruction.</p><p>If one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be generated. To avoid raising exceptions when loading a new operating environment, clear all the exception flags in the FPU status word that is being loaded.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FRSTOR.html", "tooltip": "Loads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruc-tion."},
    "FINCSTP": {"html": "<p>Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FINCSTP.html", "tooltip": "Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty."},
    "VFMSUB132PS": {"html": "<p>Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMSUB132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, subtracts the four or eight packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFMSUB213PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the first source operand. From the infi-nite precision intermediate result, subtracts the four or eight packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFMSUB231PS: Multiplies the four or eight packed single-precision floating-point values from the second source to the four or eight packed single-precision floating-point values in the third source operand. From the infinite preci-sion intermediate result, subtracts the four or eight packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMSUB132PS:VFMSUB213PS:VFMSUB231PS.html", "tooltip": "Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "MAXPS": {"html": "<p>Performs an SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "MAXPS.html", "tooltip": "Performs an SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand."},
    "VFMSUB132SS": {"html": "<p>Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From the infinite precision interme-diate result, subtracts the low packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VFMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From the infinite precision interme-diate result, subtracts the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VFMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 32-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMSUB132SS:VFMSUB213SS:VFMSUB231SS.html", "tooltip": "Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "STD": {"html": "<p>Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index regis-ters (ESI and/or EDI). Operation is the same in all modes.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "STD.html", "tooltip": "Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index regis-ters (ESI and/or EDI). Operation is the same in all modes."},
    "PBLENDW": {"html": "<p>Words from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is '1', then the word is copied, else the word element in the destination operand is unchanged.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "PBLENDW.html", "tooltip": "Words from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is '1', then the word is copied, else the word element in the destination operand is unchanged."},
    "CLAC": {"html": "<p>Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when CPL &gt; 0 cause #UD.</p></span>", "url": "CLAC.html", "tooltip": "Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages."},
    "FINIT": {"html": "<p>Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.</p><p>The assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FINIT:FNINIT.html", "tooltip": "Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared."},
    "LSL": {"html": "<p>Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The processor performs access checks as part of the loading process. Once loaded in the destination register, soft-ware can compare the segment limit with the offset of a pointer.</p><p>The segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit before loading it into the destination operand. The translation is performed by shifting the 20-bit 'raw” limit left 12 bits and filling the low-order 12 bits with 1s.</p><p>When the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits are loaded into the destination operand.</p><p>This instruction performs the following checks before it loads the segment limit into the destination register:</p><p>If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no value is loaded in the destination operand.</p><h3>Table 3-65.  Segment and Gate Descriptor Types</h3><table><tr><th>Type</th><th>Protected Mode</th><td></td><th>IA-32e Mode</th><td></td></tr><tr><td></td><th>Name</th><th>Valid</th><th>Name</th><th>Valid</th></tr><tr><td><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>A</p><p>B</p><p>C</p><p>D</p><p>E</p><p>F</p></td><td><p>Reserved</p><p>Available 16-bit TSS</p><p>LDT</p><p>Busy 16-bit TSS</p><p>16-bit call gate</p><p>16-bit/32-bit task gate</p><p>16-bit interrupt gate</p><p>16-bit trap gate</p><p>Reserved</p><p>Available 32-bit TSS</p><p>Reserved</p><p>Busy 32-bit TSS</p><p>32-bit call gate</p><p>Reserved</p><p>32-bit interrupt gate</p><p>32-bit trap gate</p></td><td><p>No</p><p>Yes</p><p>Yes</p><p>Yes</p><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>Yes</p><p>No</p><p>Yes</p><p>No</p><p>No</p><p>No</p><p>No</p></td><td><p>Upper 8 byte of a 16-Byte descriptor</p><p>Reserved</p><p>LDT</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>64-bit TSS</p><p>Reserved</p><p>Busy 64-bit TSS</p><p>64-bit call gate</p><p>Reserved</p><p>64-bit interrupt gate</p><p>64-bit trap gate</p></td><td><p>Yes</p><p>No</p><p>Yes</p><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>Yes</p><p>No</p><p>Yes</p><p>No</p><p>No</p><p>No</p><p>No</p></td></tr></table></span>", "url": "LSL.html", "tooltip": "Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register."},
    "NEG": {"html": "<p>Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "NEG.html", "tooltip": "Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location."},
    "PBLENDVB": {"html": "<p>Conditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most significant bit in each byte element of the XMM0 register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If a mask bit is '1', then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged.</p><p>The register assignment of the implicit third operand is defined to be the architectural register XMM0.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD.</p><p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD.</p><p>VEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.</p><p>VPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a VEX prefix will cause a #UD exception.</p></span>", "url": "PBLENDVB.html", "tooltip": "Conditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most significant bit in each byte element of the XMM0 register."},
    "XSETBV": {"html": "<p>Writes the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX register are copied to low-order 32 bits of the XCR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values previously read.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented XCR in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to reserved bits in an XCR.</p><p>Currently, only XCR0 is supported. Thus, all other values of ECX are reserved and will cause a #GP(0). Note that bit 0 of XCR0 (corresponding to x87 state) must be set to 1; the instruction will cause a #GP(0) if an attempt is made to clear this bit. In addition, the instruction causes a #GP(0) if an attempt is made to set XCR0[2] (AVX state) while clearing XCR0[1] (SSE state); it is necessary to set both bits to use AVX instructions; Section 13.3, 'Enabling the XSAVE Feature Set and XSAVE-Supported Features,” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "XSETBV.html", "tooltip": "Writes the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX register are copied to low-order 32 bits of the XCR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values previously read."},
    "XLAT": {"html": "<p>Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the assembly-code level, two forms of this instruction are allowed: the 'explicit-operand” form and the 'no-operand” form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded correctly before the XLAT instruction is executed.</p><p>The no-operands form (XLATB) provides a 'short form” of the XLAT instructions. Here also the processor assumes that the DS:(E)BX registers contain the base address of the table.</p><p>In 64-bit mode, operation is similar to that in legacy or compatibility mode. AL is used to specify the table index (the operand size is fixed at 8 bits). RBX, however, is used to specify the table’s base address. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "XLAT:XLATB.html", "tooltip": "Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)"},
    "CVTSD2SI": {"html": "<p>Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the begin-ning of this section for encoding data and limits.</p><p>Legacy SSE instructions: Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "CVTSD2SI.html", "tooltip": "Converts a double-precision floating-point value in the source operand (second operand) to a signed doubleword integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register."},
    "SIDT": {"html": "<p>Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In non-64-bit modes, if the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes. If the operand-size attri-bute is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in the third, fourth, and fifth byte, with the sixth byte filled with 0s.</p><p>In 64-bit mode, the operand size fixed at 8+2 bytes. The instruction stores 8-byte base and 2-byte limit values.</p><p>SIDT is only useful in operating-system software; however, it can be used in application programs without causing an exception to be generated. See 'LGDT/LIDT—Load Global/Interrupt Descriptor Table Register” in Chapter 3, <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em>, for information on loading the GDTR and IDTR.</p></span>", "url": "SIDT.html", "tooltip": "Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location."},
    "MAXPD": {"html": "<p>Performs an SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "MAXPD.html", "tooltip": "Performs an SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand."},
    "PSRAW": {"html": "<p>Shifts the bits in the individual data elements (words or doublewords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words) or 31 (for doublewords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-14 gives an example of shifting words in a 64-bit operand.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 644963.999980 379.199990 104.760015' height='157.1400225'><text y='644982.827484' x='159.5399' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='31.008684'>Pre-Shift</text><text y='644991.107484' x='170.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='645004.705488' x='158.46' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='31.41744'>Shift Right</text><text y='645011.965488' x='162.54' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='27.528192'>with Sign</text><text y='645019.765588' x='160.6197' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='29.386512'>Extension</text><text y='645035.687784' x='154.7399' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='34.539834'>Post-Shift</text><text y='645043.667484' x='169.02' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.315378'>DEST</text><rect y='644975.16' x='319.98' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='644975.16' x='382.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='645028.14' x='193.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='645028.14' x='256.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='645028.14' x='319.38' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='644975.16' x='194.16' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='644975.16' x='257.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.94'></rect><rect y='645028.14' x='382.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.94'></rect><path style='stroke:black' d='M193.920000,644974.920000 L193.920000,644993.160000 L194.400000,644993.160000 L194.400000,644974.920000 '></path><path style='stroke:black' d='M256.800000,644974.920000 L256.800000,644993.160000 L257.280010,644993.160000 L257.280010,644974.920000 '></path><path style='stroke:black' d='M319.740000,644974.920000 L319.740000,644993.160000 L320.220010,644993.160000 L320.220010,644974.920000 '></path><path style='stroke:black' d='M382.620000,644974.920000 L382.620000,644993.160000 L383.100010,644993.160000 L383.100010,644974.920000 '></path><path style='stroke:black' d='M194.160000,644974.920020 L194.160000,644975.400000 L257.280000,644975.400000 L257.280000,644974.920020 '></path><path style='stroke:black' d='M257.040000,644974.920020 L257.040000,644975.400000 L320.220000,644975.400000 L320.220000,644974.920020 '></path><path style='stroke:black' d='M319.980000,644974.920020 L319.980000,644975.400000 L383.100000,644975.400000 L383.100000,644974.920020 '></path><path style='stroke:black' d='M382.860000,644974.920020 L382.860000,644975.400000 L445.980000,644975.400000 L445.980000,644974.920020 '></path><path style='stroke:black' d='M256.800000,644975.160000 L256.800000,644993.400000 L257.280010,644993.400000 L257.280010,644975.160000 '></path><path style='stroke:black' d='M319.740000,644975.160000 L319.740000,644993.400000 L320.220010,644993.400000 L320.220010,644975.160000 '></path><path style='stroke:black' d='M382.620000,644975.160000 L382.620000,644993.400000 L383.100010,644993.400000 L383.100010,644975.160000 '></path><path style='stroke:black' d='M445.500000,644975.160000 L445.500000,644993.400000 L445.980010,644993.400000 L445.980010,644975.160000 '></path><path style='stroke:black' d='M193.920000,644992.920020 L193.920000,644993.400000 L257.040000,644993.400000 L257.040000,644992.920020 '></path><path style='stroke:black' d='M256.800000,644992.920020 L256.800000,644993.400000 L319.980000,644993.400000 L319.980000,644992.920020 '></path><path style='stroke:black' d='M319.740000,644992.920020 L319.740000,644993.400000 L382.860000,644993.400000 L382.860000,644992.920020 '></path><path style='stroke:black' d='M382.620000,644992.920020 L382.620000,644993.400000 L445.740000,644993.400000 L445.740000,644992.920020 '></path><path style='stroke:black' d='M275.820000,644993.280000 L275.820000,645008.220000 L276.299980,645008.220000 L276.299980,644993.280000 '></path><path style='stroke:black' d='M212.100000,644993.340000 L212.100000,645008.280000 L212.580010,645008.280000 L212.580010,644993.340000 '></path><path style='stroke:black' d='M394.320000,644993.340000 L394.320000,645008.280000 L394.800010,645008.280000 L394.800010,644993.340000 '></path><path style='stroke:black' d='M332.580000,644993.820000 L332.580000,645008.760000 L333.060010,645008.760000 L333.060010,644993.820000 '></path><path style='stroke:black' d='M276.060000,645007.739990 L276.060000,645008.220000 L302.040000,645008.220000 L302.040000,645007.739990 '></path><path style='stroke:black' d='M212.340000,645007.799990 L212.340000,645008.280000 L238.320000,645008.280000 L238.320000,645007.799990 '></path><path style='stroke:black' d='M394.560000,645007.799990 L394.560000,645008.280000 L420.480000,645008.280000 L420.480000,645007.799990 '></path><path style='stroke:black' d='M301.560000,645007.980000 L301.560000,645020.880000 L302.040010,645020.880000 L302.040010,645007.980000 '></path><path style='stroke:black' d='M237.840000,645008.040000 L237.840000,645020.940000 L238.320000,645020.940000 L238.320000,645008.040000 '></path><path style='stroke:black' d='M420.000000,645008.040000 L420.000000,645021.000000 L420.480010,645021.000000 L420.480010,645008.040000 '></path><path style='stroke:black' d='M332.820000,645008.280020 L332.820000,645008.760000 L358.800000,645008.760000 L358.800000,645008.280020 '></path><path style='stroke:black' d='M358.320000,645008.520000 L358.320000,645021.420000 L358.800010,645021.420000 L358.800010,645008.520000 '></path><path style='stroke:black' d='M237.900000,645021.300000 L239.460000,645020.700000 L240.420000,645020.340000 L240.120000,645021.360000 L238.560000,645026.760000 L238.080000,645028.440000 L237.600000,645026.760000 L236.040000,645021.360000 L235.740000,645020.340000 L236.700000,645020.700000 L237.000000,645021.060000 L238.560000,645026.460000 L237.600000,645026.760000 L237.600000,645026.460000 L239.160000,645021.060000 L240.120000,645021.360000 L239.820000,645021.660000 L238.260000,645022.260000 '></path><path style='stroke:black' d='M301.620000,645021.240000 L303.180000,645020.700000 L304.140000,645020.340000 L303.840000,645021.360000 L302.280000,645026.700000 L301.800000,645028.320000 L301.320000,645026.700000 L299.760000,645021.360000 L299.460000,645020.340000 L300.420000,645020.700000 L300.720000,645021.060000 L302.280000,645026.400000 L301.320000,645026.700000 L301.320000,645026.400000 L302.880000,645021.060000 L303.840000,645021.360000 L303.540000,645021.660000 L301.980000,645022.200000 '></path><path style='stroke:black' d='M420.060000,645021.300000 L421.620000,645020.760000 L422.580000,645020.400000 L422.280000,645021.420000 L420.720000,645026.820000 L420.240000,645028.560000 L419.760000,645026.820000 L418.260000,645021.420000 L417.960000,645020.400000 L418.920000,645020.760000 L419.220000,645021.120000 L420.720000,645026.520000 L419.760000,645026.820000 L419.760000,645026.520000 L421.320000,645021.120000 L422.280000,645021.420000 L421.980000,645021.720000 L420.420000,645022.260000 '></path><path style='stroke:black' d='M301.560000,645020.640000 L301.560000,645021.720000 L302.040010,645021.720000 L302.040010,645020.640000 '></path><path style='stroke:black' d='M236.700000,645020.700000 L238.260000,645021.300000 L238.260000,645022.260000 L238.080000,645022.320000 L237.900000,645022.260000 L236.340000,645021.660000 '></path><path style='stroke:black' d='M237.840000,645020.700000 L237.840000,645021.780000 L238.320000,645021.780000 L238.320000,645020.700000 '></path><path style='stroke:black' d='M300.420000,645020.700000 L301.980000,645021.240000 L301.980000,645022.200000 L301.800000,645022.260000 L301.620000,645022.200000 L300.060000,645021.660000 '></path><path style='stroke:black' d='M358.380000,645021.720000 L359.880000,645021.180000 L360.840000,645020.760000 L359.040000,645027.240000 L358.560000,645028.920000 L358.080000,645027.240000 L356.520000,645021.840000 L356.220000,645020.820000 L357.180000,645021.180000 L357.480000,645021.540000 L359.040000,645026.940000 L358.080000,645027.240000 L358.080000,645026.940000 L359.580000,645021.540000 L360.540000,645021.840000 L360.240000,645022.140000 L358.740000,645022.680000 '></path><path style='stroke:black' d='M418.920000,645020.760000 L420.420000,645021.300000 L420.420000,645022.260000 L420.240000,645022.320000 L420.060000,645022.260000 L418.560000,645021.720000 '></path><path style='stroke:black' d='M420.000000,645020.760000 L420.000000,645021.780000 L420.480010,645021.780000 L420.480010,645020.760000 '></path><path style='stroke:black' d='M238.080000,645021.780000 L239.640000,645021.180000 L238.080000,645026.580000 L236.520000,645021.180000 '></path><path style='stroke:black' d='M301.800000,645021.720000 L303.360000,645021.180000 L301.800000,645026.520000 L300.240000,645021.180000 '></path><path style='stroke:black' d='M357.180000,645021.180000 L358.740000,645021.720000 L358.740000,645022.680000 L358.560000,645022.740000 L358.380000,645022.680000 L356.820000,645022.140000 '></path><path style='stroke:black' d='M358.320000,645021.180000 L358.320000,645022.200000 L358.800010,645022.200000 L358.800010,645021.180000 '></path><path style='stroke:black' d='M420.240000,645021.780000 L421.800000,645021.240000 L420.240000,645026.640000 L418.740000,645021.240000 '></path><path style='stroke:black' d='M358.560000,645022.200000 L360.060000,645021.660000 L358.560000,645027.060000 L357.000000,645021.660000 '></path><path style='stroke:black' d='M193.620000,645027.899990 L193.620000,645028.380000 L256.740000,645028.380000 L256.740000,645027.899990 '></path><path style='stroke:black' d='M256.500000,645027.899990 L256.500000,645028.380000 L319.620000,645028.380000 L319.620000,645027.899990 '></path><path style='stroke:black' d='M319.380000,645027.899990 L319.380000,645028.380000 L382.500000,645028.380000 L382.500000,645027.899990 '></path><path style='stroke:black' d='M382.260000,645027.899990 L382.260000,645028.380000 L445.440000,645028.380000 L445.440000,645027.899990 '></path><path style='stroke:black' d='M193.380000,645027.900000 L193.380000,645046.140000 L193.860010,645046.140000 L193.860010,645027.900000 '></path><path style='stroke:black' d='M256.260000,645027.900000 L256.260000,645046.140000 L256.739980,645046.140000 L256.739980,645027.900000 '></path><path style='stroke:black' d='M319.140000,645027.900000 L319.140000,645046.140000 L319.619980,645046.140000 L319.619980,645027.900000 '></path><path style='stroke:black' d='M382.020000,645027.900000 L382.020000,645046.140000 L382.500010,645046.140000 L382.500010,645027.900000 '></path><path style='stroke:black' d='M256.260000,645028.140000 L256.260000,645046.380000 L256.739980,645046.380000 L256.739980,645028.140000 '></path><path style='stroke:black' d='M319.140000,645028.140000 L319.140000,645046.380000 L319.619980,645046.380000 L319.619980,645028.140000 '></path><path style='stroke:black' d='M382.020000,645028.140000 L382.020000,645046.380000 L382.500010,645046.380000 L382.500010,645028.140000 '></path><path style='stroke:black' d='M444.960000,645028.140000 L444.960000,645046.380000 L445.440010,645046.380000 L445.440010,645028.140000 '></path><path style='stroke:black' d='M193.380000,645045.899990 L193.380000,645046.380000 L256.500000,645046.380000 L256.500000,645045.899990 '></path><path style='stroke:black' d='M256.260000,645045.899990 L256.260000,645046.380000 L319.380000,645046.380000 L319.380000,645045.899990 '></path><path style='stroke:black' d='M319.140000,645045.899990 L319.140000,645046.380000 L382.260000,645046.380000 L382.260000,645045.899990 '></path><path style='stroke:black' d='M382.020000,645045.899990 L382.020000,645046.380000 L445.200000,645046.380000 L445.200000,645045.899990 '></path><text y='644986.907784' x='345.177424' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='644986.907484' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X0</text><text y='645040.667484' x='198.3598' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.65532'>X3 &gt;&gt; COUNT</text><text y='645040.667484' x='262.1402' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.59906'>X2 &gt;&gt; COUNT</text><text y='645040.667484' x='325.4397' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.5836'>X1 &gt;&gt; COUNT</text><text y='644986.907784' x='220.3798' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='644986.907784' x='284.095312' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='645040.667184' x='385.9801' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='11.997132'>X0 &gt;&gt; COUNT</text></svg><h3>Figure 4-14.  PSRAW and PSRAD Instruction Operation Using a 64-bit Operand</h3><p>Note that only the first 64-bits of a 128-bit count operand are checked to compute the count. If the second source operand is a memory address, 128 bits are loaded.</p><p>The (V)PSRAW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand, and the (V)PSRAD instruction shifts each of the doublewords in the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.</p><p>128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.</p><p>VEX.128 encoded version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory loca-tion or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.</p><p>VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate.</p><p>Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /4), VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSRAW:PSRAD.html", "tooltip": "Shifts the bits in the individual data elements (words or doublewords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words) or 31 (for doublewords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-14 gives an example of shifting words in a 64-bit operand.)"},
    "WAIT": {"html": "<p>Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction’s results. See the section titled 'Floating-Point Exception Synchronization” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more information on using the WAIT/FWAIT instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "WAIT:FWAIT.html", "tooltip": "Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.)"},
    "CVTPI2PS": {"html": "<p>Converts two packed signed doubleword integers in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. The results are stored in the low quadword of the destination operand, and the high quadword remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p><p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "CVTPI2PS.html", "tooltip": "Converts two packed signed doubleword integers in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand)."},
    "SQRTSD": {"html": "<p>Computes the square root of the low double-precision floating-point value in the source operand (second operand) and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the desti-nation operand remains unchanged. See Figure 11-4 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an illustration of a scalar double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "SQRTSD.html", "tooltip": "Computes the square root of the low double-precision floating-point value in the source operand (second operand) and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the desti-nation operand remains unchanged. See Figure 11-4 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an illustration of a scalar double-precision floating-point operation."},
    "VPERMPS": {"html": "<p>Use the index values in each dword element of the first source operand (the second operand) to select a single-precision floating-point element in the second source operand (the third operand), the resultant data from the second source operand is copied to the destination operand (the first operand) in the corresponding position of the index element. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>An attempt to execute VPERMPS encoded with VEX.L= 0 will cause an #UD exception.</p></span>", "url": "VPERMPS.html", "tooltip": "Use the index values in each dword element of the first source operand (the second operand) to select a single-precision floating-point element in the second source operand (the third operand), the resultant data from the second source operand is copied to the destination operand (the first operand) in the corresponding position of the index element. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand."},
    "VPSRLVD": {"html": "<p>Shifts the bits in the individual data elements (doublewords, or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 31 (for double-words), or 63 (for a quadword), then the destination data element are written with 0.</p><p>VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory location.</p></span>", "url": "VPSRLVD:VPSRLVQ.html", "tooltip": "Shifts the bits in the individual data elements (doublewords, or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0)."},
    "AESENCLAST": {"html": "<p>This instruction performs the last round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "AESENCLAST.html", "tooltip": "This instruction performs the last round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand."},
    "MOVNTPS": {"html": "<p>Moves the packed single-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register or YMM register, which is assumed to contain packed single-precision, floating-pointing. The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see 'Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors might use different memory types to read/write the destination memory locations.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "MOVNTPS.html", "tooltip": "Moves the packed single-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register or YMM register, which is assumed to contain packed single-precision, floating-pointing. The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated."},
    "PSHUFD": {"html": "<p>Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-12 shows the operation of the 256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand (see the field encoding in Figure 4-12) determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>For 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.</p><p>SRC</p><p>X7</p><p>X6</p><p>X5</p><p>X4</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>DEST</p><p>Y7</p><p>Y6</p><p>Y5</p><p>Y4</p><p>Y3</p><p>Y2</p><p>Y1</p><p>Y0</p><p>00B - X4</p><p>Encoding</p><p>00B - X0</p><p>Encoding</p><p>01B - X5</p><p>of Fields in</p><p>ORDER</p><p>01B - X1</p><p>of Fields in</p><p>10B - X6</p><p>ORDER</p><p>10B - X2</p><p>ORDER</p><p>11B - X7</p><p>Operand</p><p>7</p><p>56</p><p>4</p><p>3</p><p>12</p><p>0</p><p>11B - X3</p><p>Operand</p><h3>Figure 4-12.  256-bit VPSHUFD Instruction Operation</h3><p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.</p><p>Legacy SSE instructions: In 64-bit mode using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: Bits (255:128) of the destination stores the shuffled results of the upper 16 bytes of the source operand using the immediate byte as the order operand.</p><p>Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PSHUFD.html", "tooltip": "Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-12 shows the operation of the 256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand (see the field encoding in Figure 4-12) determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand."},
    "VPSRAVD": {"html": "<p>Shifts the bits in the individual doubleword data elements in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in each data element are shifted right, the empty high-order bits are filled with the sign bit of the source element.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 31, then the destination data element are filled with the corresponding sign bit of the source element.</p><p>VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory location.</p></span>", "url": "VPSRAVD.html", "tooltip": "Shifts the bits in the individual doubleword data elements in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in each data element are shifted right, the empty high-order bits are filled with the sign bit of the source element."},
    "CMOVcc": {"html": "<p>The CMOV<em>cc</em> instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (<em>cc</em>) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOV<em>cc</em> instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.</p><p>The condition for each CMOV<em>cc</em> mnemonic is given in the description column of the above table. The terms 'less” and 'greater” are used for comparisons of signed integers and the terms 'above” and 'below” are used for unsigned integers.</p><p>Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.</p><p>The CMOV<em>cc</em> instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOV<em>cc</em> instructions are supported by checking the processor’s feature information with the CPUID instruction (see 'CPUID—CPU Identification” in this chapter).</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "CMOVcc.html", "tooltip": "The CMOV<em>cc</em> instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (<em>cc</em>) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOV<em>cc</em> instruction."},
    "MOVUPD": {"html": "<p><strong>128-bit versions:</strong></p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Moves a double quadword containing two packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, store the contents of an XMM register into a 128-bit memory location, or move data between two XMM registers.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>When the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte boundary without causing a general-protection exception (#GP) to be generated.<sup>1</sup></p><p>To move double-precision floating-point values to and from memory locations that are known to be aligned on 16-byte boundaries, use the MOVAPD instruction.</p><p>While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the segment may or may not wrap around to the beginning of the segment.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: Moves 256 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.</p><p>1.</p><p>If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an alignment-check exception (#AC) may or may not be generated (depending on processor implementation) when the operand is not aligned on an 8-byte boundary.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "MOVUPD.html", "tooltip": "<strong>128-bit versions:</strong>"},
    "SAHF": {"html": "<p>Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain as shown in the 'Operation” section below.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.</p></span>", "url": "SAHF.html", "tooltip": "Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain as shown in the 'Operation” section below."},
    "F2XM1": {"html": "<p>Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range –1.0 to +1.0. If the source value is outside this range, the result is undefined.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The following table shows the results obtained when computing the exponential value of various classes of numbers, assuming that neither overflow nor underflow occurs.</p><h3>Table 3-26.  Results Obtained from F2XM1</h3><table><tr><th>ST(0) SRC</th><th>ST(0) DEST</th></tr><tr><td>− 1.0 to −0</td><td>− 0.5 to − 0</td></tr><tr><td>− 0</td><td>− 0</td></tr><tr><td>+ 0</td><td>+ 0</td></tr><tr><td>+ 0 to +1.0</td><td>+ 0 to 1.0</td></tr></table><p>Values other than 2 can be exponentiated using the following formula:</p><p>x<sup>y</sup> ← 2<sup>(y ∗ log<sub>2<sup>x)</sup></sub></sup></p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "F2XM1.html", "tooltip": "Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range –1.0 to +1.0. If the source value is outside this range, the result is undefined."},
    "PHSUBW": {"html": "<p>(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least signifi-cant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PHSUBW:PHSUBD.html", "tooltip": "(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least signifi-cant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},
    "FYL2X": {"html": "<p>Computes (ST(1) ∗ log<sub>2</sub> (ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The following table shows the results obtained when taking the log of various classes of numbers, assuming that neither overflow nor underflow occurs.</p><h3>Table 3-58.  FYL2X Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>ST(0)</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>±0</td><td colspan='2'>+0&lt;+F&lt;+1</td><td colspan='2'>+ 1</td><td colspan='2'>+ F &gt; + 1</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>*</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>ST(1)</th><td colspan='2'>− F</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>**</td><td colspan='2'>+ F</td><td colspan='2'>− 0</td><td colspan='2'>− F</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− 0</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>+ 0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ 0</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ F</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>**</td><td colspan='2'>− F</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ ∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-operation (#IA) exception.</p><p>** Indicates floating-point zero-divide (#Z) exception.</p><p>If the divide-by-zero exception is masked and register ST(0) contains ±0, the instruction returns ∞ with a sign that is the opposite of the sign of the source operand in register ST(1).</p><p>The FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an arbitrary positive base (b):</p><p>log<sub>b</sub>x ← (log<sub>2</sub>b)<sup>–1</sup> ∗ log<sub>2</sub>x</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FYL2X.html", "tooltip": "Computes (ST(1) ∗ log<sub>2</sub> (ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number."},
    "XTEST": {"html": "<p>The XTEST instruction queries the transactional execution status. If the instruction executes inside a transaction-ally executing RTM region or a transactionally executing HLE region, then the ZF flag is cleared, else it is set.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "XTEST.html", "tooltip": "The XTEST instruction queries the transactional execution status. If the instruction executes inside a transaction-ally executing RTM region or a transactionally executing HLE region, then the ZF flag is cleared, else it is set."},
    "UNPCKLPS": {"html": "<p>Performs an interleaved unpack of the low-order single-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-26. The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 803476.019995 379.199990 156.360005' height='234.5400075'><text y='803508.887484' x='144.06' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='803554.907384' x='148.5001' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='803616.707684' x='144.06' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='803497.44' x='242.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803542.44' x='242.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803497.44' x='170.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803497.44' x='314.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803497.44' x='386.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803542.44' x='170.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803542.44' x='314.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803542.44' x='386.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803605.44' x='169.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803605.44' x='241.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='803605.44' x='313.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><path style='stroke:black' d='M170.040000,803542.200000 L170.040000,803560.440000 L170.520000,803560.440000 L170.520000,803542.200000 '></path><path style='stroke:black' d='M242.040000,803542.200000 L242.040000,803560.440000 L242.520010,803560.440000 L242.520010,803542.200000 '></path><path style='stroke:black' d='M314.040000,803542.200000 L314.040000,803560.440000 L314.519980,803560.440000 L314.519980,803542.200000 '></path><path style='stroke:black' d='M386.040000,803542.200000 L386.040000,803560.440000 L386.519980,803560.440000 L386.519980,803542.200000 '></path><path style='stroke:black' d='M170.280000,803542.200020 L170.280000,803542.680000 L242.520000,803542.680000 L242.520000,803542.200020 '></path><path style='stroke:black' d='M242.280000,803542.200020 L242.280000,803542.680000 L314.520000,803542.680000 L314.520000,803542.200020 '></path><path style='stroke:black' d='M314.280000,803542.200020 L314.280000,803542.680000 L386.520000,803542.680000 L386.520000,803542.200020 '></path><path style='stroke:black' d='M386.280000,803542.200020 L386.280000,803542.680000 L458.520000,803542.680000 L458.520000,803542.200020 '></path><path style='stroke:black' d='M242.040000,803542.440000 L242.040000,803560.680000 L242.520010,803560.680000 L242.520010,803542.440000 '></path><path style='stroke:black' d='M314.040000,803542.440000 L314.040000,803560.680000 L314.519980,803560.680000 L314.519980,803542.440000 '></path><path style='stroke:black' d='M386.040000,803542.440000 L386.040000,803560.680000 L386.519980,803560.680000 L386.519980,803542.440000 '></path><path style='stroke:black' d='M458.040000,803542.440000 L458.040000,803560.680000 L458.519980,803560.680000 L458.519980,803542.440000 '></path><path style='stroke:black' d='M170.040000,803560.199990 L170.040000,803560.680000 L242.280000,803560.680000 L242.280000,803560.199990 '></path><path style='stroke:black' d='M242.040000,803560.199990 L242.040000,803560.680000 L314.280000,803560.680000 L314.280000,803560.199990 '></path><path style='stroke:black' d='M314.040000,803560.199990 L314.040000,803560.680000 L386.280000,803560.680000 L386.280000,803560.199990 '></path><path style='stroke:black' d='M386.040000,803560.199990 L386.040000,803560.680000 L458.280000,803560.680000 L458.280000,803560.199990 '></path><text y='803508.887484' x='273.543012' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.713256'>X2</text><text y='803553.887484' x='274.500612' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='803508.887484' x='204.84' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='803508.887484' x='345.541764' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.713256'>X1</text><text y='803508.887484' x='417.540516' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='803553.887484' x='204.84' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='803553.887484' x='339.836064' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='803553.887484' x='411.834816' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text><text y='803616.77786' x='204.0' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='803616.77786' x='276.238152' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='803616.77786' x='348.236904' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text></svg><h3>Figure 4-26.  UNPCKLPS Instruction Low Unpack and Interleave Operation</h3><p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p></span>", "url": "UNPCKLPS.html", "tooltip": "Performs an interleaved unpack of the low-order single-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-26. The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register."},
    "POP": {"html": "<p>Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode) and then increments the stack pointer. The destination operand can be a general-purpose register, memory loca-tion, or segment register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Address and operand sizes are determined and used as follows:</p><p>The address size is used only when writing to a destination operand in memory.</p><p>The operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is incremented (2, 4 or 8).</p><p>The stack-address size determines the width of the stack pointer when reading from the stack in memory and when incrementing the stack pointer. (As stated above, the amount by which the stack pointer is incremented is determined by the operand size.)</p><p>If the destination operand is one of the segment registers DS, ES, FS, GS, or SS, the value loaded into the register must be a valid segment selector. In protected mode, popping a segment selector into a segment register automat-ically causes the descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register and causes the selector and the descriptor information to be validated (see the 'Operation” section below).</p><p>A NULL value (0000-0003) may be popped into the DS, ES, FS, or GS register without causing a general protection fault. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP). In this situation, no memory reference occurs and the saved value of the segment register is NULL.</p><p>The POP instruction cannot pop a value into the CS register. To load the CS register from the stack, use the RET instruction.</p><p>If the ESP register is used as a base register for addressing a destination operand in memory, the POP instruction computes the effective address of the operand after it increments the ESP register. For the case of a 16-bit stack where ESP wraps to 0H as a result of the POP instruction, the resulting location of the memory write is processor-family-specific.</p><p>The POP ESP instruction increments the stack pointer (ESP) before data at the old top of stack is written into the destination.</p><p>A POP SS instruction inhibits all interrupts, including the NMI interrupt, until after execution of the next instruction. This action allows sequential execution of POP SS and MOV ESP, EBP instructions without the danger of having an invalid stack during an interrupt<sup>1</sup>. However, use of the LSS instruction is the preferred method of loading the SS and ESP registers.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). When in 64-bit mode, POPs using 32-bit operands are not encodable and POPs to DS, ES, SS are not valid. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "POP.html", "tooltip": "Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode) and then increments the stack pointer. The destination operand can be a general-purpose register, memory loca-tion, or segment register."},
    "PALIGNR": {"html": "<p>(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant imme-diate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX, XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L (i.e. 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX regis-ters, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register and contains two 16-byte blocks. The second source operand is a YMM register or a 256-bit memory location containing two 16-byte block. The destination operand is a YMM register and contain two 16-byte results. The imm8[7:0] is the common shift count used for the two lower 16-byte block sources and the two upper 16-byte block sources. The low 16-byte block of the two source</p><p>operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source oper-ands produce the high 16-byte result of the destination operand.</p><p>Concatenation is done with 128-bit data in the first and second source operand for both 128-bit and 256-bit instructions. The high 128-bits of the intermediate composite 256-bit result came from the 128-bit data from the first source operand; the low 128-bits of the intermediate result came from the 128-bit data of the second source operand.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p><p>0</p><p>127</p><p>0</p><p>127</p><p>SRC1</p><p>SRC2</p><p>Imm8[7:0]*8</p><p>255</p><p>128</p><p>128</p><p>255</p><p>SRC1</p><p>SRC2</p><p>Imm8[7:0]*8</p><p>127</p><p>0</p><p>128</p><p>255</p><p>DEST</p><p>DEST</p><h3>Figure 4-3.  256-bit VPALIGN Instruction Operation</h3></span>", "url": "PALIGNR.html", "tooltip": "(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant imme-diate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX, XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L (i.e. 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX regis-ters, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},
    "CMPSD": {"html": "<p>Compares the low double-precision floating-point values in the source operand (second operand) and the destina-tion operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed. The comparison result is a quad-word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 64-bit memory location. The comparison pred-icate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed (see Table 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.</p><p>A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate a fault, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p><p>Note that processors with 'CPUID.1H:ECX.AVX =0” do not implement the 'greater-than”, 'greater-than-or-equal”, 'not-greater than”, and 'not-greater-than-or-equal relations” predicates. These comparisons can be made either by using the inverse relationship (that is, use the 'not-less-than-or-equal” to make a 'greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination operand), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in Table 3-7 under the heading Emulation.</p><p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSD instruction, for processors with 'CPUID.1H:ECX.AVX =0”. See Table 3-13. Compiler should treat reserved Imm8 values as illegal syntax.</p><h3>Table 3-13.  Pseudo-Ops and CMPSD</h3><table><tr><th>Pseudo-Op</th><th>Implementation</th></tr><tr><td>CMPEQSD<em> xmm1, xmm2</em></td><td>CMPSD<em> xmm1,xmm2, 0</em></td></tr><tr><td>CMPLTSD <em>xmm1, xmm2</em></td><td>CMPSD<em> xmm1,xmm2, 1</em></td></tr><tr><td>CMPLESD <em>xmm1, xmm2</em></td><td>CMPSD <em>xmm1,xmm2, 2</em></td></tr><tr><td>CMPUNORDSD <em>xmm1, xmm2</em></td><td>CMPSD <em>xmm1,xmm2, 3</em></td></tr><tr><td>CMPNEQSD<em> xmm1, xmm2</em></td><td>CMPSD <em>xmm1,xmm2, 4</em></td></tr><tr><td>CMPNLTSD<em> xmm1, xmm2</em></td><td>CMPSD <em>xmm1,xmm2, 5</em></td></tr><tr><td>CMPNLESD <em>xmm1, xmm2</em></td><td>CMPSD<em> xmm1,xmm2, 6</em></td></tr><tr><td>CMPORDSD<em> xmm1, xmm2</em></td><td>CMPSD <em>xmm1,xmm2, 7</em></td></tr></table><p>The greater-than relations not implemented in the processor require more than one instruction to emulate in soft-ware and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p><strong>Enhanced Comparison Predicate for VEX-Encoded VCMPSD</strong></p><p>VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 64-bit memory location. Bits (VLMAX-1:128) of the destina-tion YMM register are zeroed. The comparison predicate operand is an 8-bit immediate:</p><p>Processors with 'CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-9, soft-ware emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSD instruction. See Table 3-14, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. Compiler should treat reserved Imm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic inter-face.</p><h3>Table 3-14.  Pseudo-Op and VCMPSD Implementation</h3><p>:</p><table><tr><th>Pseudo-Op</th><th>CMPSD Implementation</th></tr><tr><td>VCMPEQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 0</em></td></tr><tr><td>VCMPLTSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 1</em></td></tr><tr><td>VCMPLESD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 2</em></td></tr><tr><td>VCMPUNORDSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 3</em></td></tr><tr><td>VCMPNEQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 4</em></td></tr><tr><td>VCMPNLTSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 5</em></td></tr><tr><td>VCMPNLESD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 6</em></td></tr><tr><td>VCMPORDSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 7</em></td></tr><tr><td>VCMPEQ_UQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 8</em></td></tr><tr><td>VCMPNGESD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 9</em></td></tr><tr><td>VCMPNGTSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 0AH</em></td></tr><tr><td>VCMPFALSESD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 0BH</em></td></tr><tr><td>VCMPNEQ_OQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 0CH</em></td></tr><tr><td>VCMPGESD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 0DH</em></td></tr><tr><td>VCMPGTSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 0EH</em></td></tr></table><h3>Table 3-14.  Pseudo-Op and VCMPSD Implementation (Contd.)</h3><table><tr><th>Pseudo-Op</th><th>CMPSD Implementation</th></tr><tr><td>VCMPTRUESD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 0FH</em></td></tr><tr><td>VCMPEQ_OSSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 10H</em></td></tr><tr><td>VCMPLT_OQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 11H</em></td></tr><tr><td>VCMPLE_OQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 12H</em></td></tr><tr><td>VCMPUNORD_SSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 13H</em></td></tr><tr><td>VCMPNEQ_USSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 14H</em></td></tr><tr><td>VCMPNLT_UQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 15H</em></td></tr><tr><td>VCMPNLE_UQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 16H</em></td></tr><tr><td>VCMPORD_SSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 17H</em></td></tr><tr><td>VCMPEQ_USSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 18H</em></td></tr><tr><td>VCMPNGE_UQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 19H</em></td></tr><tr><td>VCMPNGT_UQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 1AH</em></td></tr><tr><td>VCMPFALSE_OSSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 1BH</em></td></tr><tr><td>VCMPNEQ_OSSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 1CH</em></td></tr><tr><td>VCMPGE_OQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 1DH</em></td></tr><tr><td>VCMPGT_OQSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 1EH</em></td></tr><tr><td>VCMPTRUE_USSD r<em>eg1, reg2, reg3</em></td><td>VCMPSD r<em>eg1, reg2, reg3, 1FH</em></td></tr></table></span>", "url": "CMPSD.html", "tooltip": "Compares the low double-precision floating-point values in the source operand (second operand) and the destina-tion operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed. The comparison result is a quad-word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "VINSERTF128": {"html": "<p>Performs an insertion of 128-bits of packed floating-point values from the second source operand (third operand) into an the destination operand (first operand) at an 128-bit offset from imm8[0]. The remaining portions of the destination are written by the corresponding fields of the first source operand (second operand). The second source operand can be either an XMM register or a 128-bit memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The high 7 bits of the immediate are ignored.</p></span>", "url": "VINSERTF128.html", "tooltip": "Performs an insertion of 128-bits of packed floating-point values from the second source operand (third operand) into an the destination operand (first operand) at an 128-bit offset from imm8[0]. The remaining portions of the destination are written by the corresponding fields of the first source operand (second operand). The second source operand can be either an XMM register or a 128-bit memory location."},
    "TZCNT": {"html": "<p>TZCNT counts the number of trailing least significant zero bits in source operand (second operand) and returns the result in destination operand (first operand). TZCNT is an extension of the BSF instruction. The key difference between TZCNT and BSF instruction is that TZCNT provides operand size as output when source operand is zero while in the case of BSF instruction, if source operand is zero, the content of destination operand are undefined. On processors that do not support TZCNT, the instruction byte encoding is executed as BSF.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "TZCNT.html", "tooltip": "TZCNT counts the number of trailing least significant zero bits in source operand (second operand) and returns the result in destination operand (first operand). TZCNT is an extension of the BSF instruction. The key difference between TZCNT and BSF instruction is that TZCNT provides operand size as output when source operand is zero while in the case of BSF instruction, if source operand is zero, the content of destination operand are undefined. On processors that do not support TZCNT, the instruction byte encoding is executed as BSF."},
    "FYL2XP1": {"html": "<p>Computes (ST(1) ∗ log<sub>2</sub>(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><math>	<mo>-</mo>	<mo stretchy='true'>(</mo>	<mn>1</mn>	<mo>-</mo>	<mfrac>		<mrow><msqrt><mn>2</mn></msqrt></mrow>		<mrow><mn>2</mn></mrow>	</mfrac>	<mo stretchy='true'>)</mo>	<mtext>&nbsp;to&nbsp;</mtext>	<mo stretchy='true'>(</mo>	<mn>1</mn>	<mo>-</mo>	<mfrac>		<mrow><msqrt><mn>2</mi></msqrt></mrow>		<mrow><mn>2</mn></mrow>	</mfrac>	<mo stretchy='true'>)</mo></math><p>The source operand in ST(1) can range from −∞ to +∞. If the ST(0) operand is outside of its acceptable range, the result is undefined and software should not rely on an exception being generated. Under some circumstances exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not guaranteed.</p><p>The following table shows the results obtained when taking the log epsilon of various classes of numbers, assuming that underflow does not occur.</p><h3>Table 3-59.  FYL2XP1 Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>ST(0)</th><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'><math>	<mo>-</mo>	<mo stretchy='true'>(</mo>	<mn>1</mn>	<mo>-</mo>	<mfrac>		<mrow><msqrt><mn>2</mn></msqrt></mrow>		<mrow><mn>2</mn></mrow>	</mfrac>	<mo stretchy='true'>)</mo>	<mtext>&nbsp;to&nbsp;</mtext>	<mo>-</mo>	<mn>0</mn></math></td><td colspan='2'>-0</td><td colspan='2'>+0</td><td colspan='2'><math>	<mo>+</mo>	<mn>0</mn>	<mtext>&nbsp;to&nbsp;</mtext>	<mo>+</mo>	<mo stretchy='true'>(</mo>	<mn>1</mn>	<mo>-</mo>	<mfrac>		<mrow><msqrt><mn>2</mn></msqrt></mrow>		<mrow><mn>2</mn></mrow>	</mfrac>	<mo stretchy='true'>)</mo></math></td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>+∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>ST(1)</th><td colspan='2'>− F</td><td colspan='2'>+F</td><td colspan='2'>+0</td><td colspan='2'>-0</td><td colspan='2'>− F</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− 0</td><td colspan='2'>+0</td><td colspan='2'>+0</td><td colspan='2'>-0</td><td colspan='2'>− 0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>+0</td><td colspan='2'>+0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+F</td><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>+0</td><td colspan='2'>+F</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+∞</td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>+∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-operation (#IA) exception.</p><p>This instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For small epsilon (ε) values, more significant digits can be retained by using the FYL2XP1 instruction than by using (ε+1) as an argument to the FYL2X instruction. The (ε+1) expression is commonly found in compound interest and annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale factor in the ST(1) source operand. The following equation is used to calculate the scale factor for a particular loga-rithm base, where n is the logarithm base desired for the result of the FYL2XP1 instruction:</p><p>scale factor ← log<sub>n</sub> 2</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FYL2XP1.html", "tooltip": "Computes (ST(1) ∗ log<sub>2</sub>(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range:"},
    "VPERMPD": {"html": "<p>Use two-bit index values in the immediate byte to select a double-precision floating-point element in the source operand; the resultant data from the source operand is copied to the corresponding element of the destination operand in the order of the index field. Note that this instruction permits a qword in the source operand to be copied to multiple location in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>An attempt to execute VPERMPD encoded with VEX.L= 0 will cause an #UD exception.</p></span>", "url": "VPERMPD.html", "tooltip": "Use two-bit index values in the immediate byte to select a double-precision floating-point element in the source operand; the resultant data from the source operand is copied to the corresponding element of the destination operand in the order of the index field. Note that this instruction permits a qword in the source operand to be copied to multiple location in the destination operand."},
    "CVTPS2PI": {"html": "<p>Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX tech-nology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indef-inite integer value (80000000H) is returned.</p><p>CVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "CVTPS2PI.html", "tooltip": "Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand)."},
    "CLI": {"html": "<p>If protected-mode virtual interrupts are not enabled, CLI clears the IF flag in the EFLAGS register. No other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no affect on the generation of exceptions and NMI interrupts.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; CLI clears the VIF flag in the EFLAGS register, leaving IF unaffected. Table 3-6 indicates the action of the CLI instruction depending on the processor operating mode and the CPL/IOPL of the running program or procedure.</p><p>Operation is the same in all modes.</p><h3>Table 3-6.  Decision Table for CLI Results</h3><table><tr><th>PE</th><th>VM</th><th>IOPL</th><th>CPL</th><th>PVI</th><th>VIP</th><th>VME</th><th>CLI Result</th></tr><tr><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><th>IF = 0</th></tr><tr><td>1</td><td>0</td><td>≥ CPL</td><td>X</td><td>X</td><td>X</td><td>X</td><th>IF = 0</th></tr><tr><td>1</td><td>0</td><td>&lt; CPL</td><td>3</td><td>1</td><td>X</td><td>X</td><th>VIF = 0</th></tr><tr><td>1</td><td>0</td><td>&lt; CPL</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><th>GP Fault</th></tr><tr><td>1</td><td>0</td><td>&lt; CPL</td><td>X</td><td>0</td><td>X</td><td>X</td><th>GP Fault</th></tr><tr><td>1</td><td>1</td><td>3</td><td>X</td><td>X</td><td>X</td><td>X</td><th>IF = 0</th></tr><tr><td>1</td><td>1</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><td>1</td><th>VIF = 0</th></tr><tr><td>1</td><td>1</td><td>&lt; 3</td><td>X</td><td>X</td><td>X</td><td>0</td><th>GP Fault</th></tr></table><p><strong>NOTES:</strong></p><p>* X = This setting has no impact.</p></span>", "url": "CLI.html", "tooltip": "If protected-mode virtual interrupts are not enabled, CLI clears the IF flag in the EFLAGS register. No other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no affect on the generation of exceptions and NMI interrupts."},
    "BTC": {"html": "<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>See also: <strong>Bit(BitBase, BitOffset) </strong>on page 3-10.</p><p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-tion with the displacement field of the memory operand. See 'BT—Bit Test” in this chapter for more information on this addressing mechanism.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "BTC.html", "tooltip": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:"},
    "LZCNT": {"html": "<p>Counts the number of leading most significant zero bits in a source operand (second operand) returning the result into a destination (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>LZCNT differs from BSR. For example, LZCNT will produce the operand size when the input operand is zero. It should be noted that on processors that do not support LZCNT, the instruction byte encoding is executed as BSR.</p><p>In 64-bit mode 64-bit operand size requires REX.W=1.</p></span>", "url": "LZCNT.html", "tooltip": "Counts the number of leading most significant zero bits in a source operand (second operand) returning the result into a destination (first operand)."},
    "PSADBW": {"html": "<p>Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then summed to produce an unsigned word integer result that is stored in the destination operand. Figure 4-10 shows the operation of the PSADBW instruction when using 64-bit operands.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When operating on 64-bit operands, the word integer result is stored in the low word of the destination operand, and the remaining bytes in the destination operand are cleared to all 0s.</p><p>When operating on 128-bit operands, two packed results are computed. Here, the 8 low-order bytes of the source and destination operands are operated on to produce a word result that is stored in the low word of the destination operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79 of the destination operand. The remaining bytes of the destination operand are cleared.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE version: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand and destination register are YMM registers. The second source operand is an YMM register or a 256-bit memory location.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p><svg width='568.799985' viewBox='112.380000 625042.980010 379.199990 131.279985' height='196.9199775'><text y='625066.547284' x='148.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='625067.087484' x='363.960612' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='625095.527384' x='143.9999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='625126.427584' x='143.0997' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='22.189986'>TEMP</text><text y='625158.167484' x='144.0' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='625086.3' x='313.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='17.34' width='36.36'></rect><rect y='625086.3' x='386.34' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='17.34' width='36.36'></rect><rect y='625086.3' x='422.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='17.34' width='36.36'></rect><rect y='625086.3' x='349.92' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='17.34' width='36.42'></rect><rect y='625055.76' x='168.48' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625055.76' x='204.84' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625085.7' x='240.66' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625114.62' x='168.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625114.62' x='204.78' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625055.76' x='241.2' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625055.7' x='314.16' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625055.7' x='386.88' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625085.7' x='167.88' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625085.7' x='277.02' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625114.62' x='241.2' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625114.62' x='277.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625114.62' x='314.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625114.62' x='386.88' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625114.62' x='423.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625148.34' x='205.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625148.34' x='241.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625148.34' x='277.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625148.34' x='350.82' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='625148.34' x='168.72' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='625055.76' x='277.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='625055.7' x='423.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='625085.7' x='204.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='625114.62' x='350.46' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='625148.34' x='314.4' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='625148.34' x='387.18' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='71.22'></rect><path style='stroke:black' d='M313.920000,625055.460000 L313.920000,625073.700000 L314.399980,625073.700000 L314.399980,625055.460000 '></path><path style='stroke:black' d='M350.280000,625055.460000 L350.280000,625073.700000 L350.760010,625073.700000 L350.760010,625055.460000 '></path><path style='stroke:black' d='M386.640000,625055.460000 L386.640000,625073.700000 L387.119980,625073.700000 L387.119980,625055.460000 '></path><path style='stroke:black' d='M423.000000,625055.460000 L423.000000,625073.700000 L423.480010,625073.700000 L423.480010,625055.460000 '></path><path style='stroke:black' d='M314.160000,625055.460020 L314.160000,625055.940000 L350.760000,625055.940000 L350.760000,625055.460020 '></path><path style='stroke:black' d='M350.520000,625055.460020 L350.520000,625055.940000 L387.120000,625055.940000 L387.120000,625055.460020 '></path><path style='stroke:black' d='M386.880000,625055.460020 L386.880000,625055.940000 L423.480000,625055.940000 L423.480000,625055.460020 '></path><path style='stroke:black' d='M423.240000,625055.460020 L423.240000,625055.940000 L459.900000,625055.940000 L459.900000,625055.460020 '></path><path style='stroke:black' d='M168.480000,625055.519960 L168.480000,625056.000000 L205.080000,625056.000000 L205.080000,625055.519960 '></path><path style='stroke:black' d='M204.840000,625055.519960 L204.840000,625056.000000 L241.440000,625056.000000 L241.440000,625055.519960 '></path><path style='stroke:black' d='M241.200000,625055.519960 L241.200000,625056.000000 L277.800000,625056.000000 L277.800000,625055.519960 '></path><path style='stroke:black' d='M277.560000,625055.519960 L277.560000,625056.000000 L314.220000,625056.000000 L314.220000,625055.519960 '></path><path style='stroke:black' d='M168.240000,625055.520000 L168.240000,625073.760000 L168.720010,625073.760000 L168.720010,625055.520000 '></path><path style='stroke:black' d='M204.600000,625055.520000 L204.600000,625073.760000 L205.080010,625073.760000 L205.080010,625055.520000 '></path><path style='stroke:black' d='M240.960000,625055.520000 L240.960000,625073.760000 L241.439980,625073.760000 L241.439980,625055.520000 '></path><path style='stroke:black' d='M277.320000,625055.520000 L277.320000,625073.760000 L277.799980,625073.760000 L277.799980,625055.520000 '></path><path style='stroke:black' d='M350.280000,625055.700000 L350.280000,625073.940000 L350.760010,625073.940000 L350.760010,625055.700000 '></path><path style='stroke:black' d='M350.520000,625055.700000 L386.880000,625055.700000 L386.880000,625073.700000 L350.520000,625073.700000 '></path><path style='stroke:black' d='M386.640000,625055.700000 L386.640000,625073.940000 L387.119980,625073.940000 L387.119980,625055.700000 '></path><path style='stroke:black' d='M423.000000,625055.700000 L423.000000,625073.940000 L423.480010,625073.940000 L423.480010,625055.700000 '></path><path style='stroke:black' d='M459.420000,625055.700000 L459.420000,625073.940000 L459.899980,625073.940000 L459.899980,625055.700000 '></path><path style='stroke:black' d='M204.600000,625055.760000 L204.600000,625074.000000 L205.080010,625074.000000 L205.080010,625055.760000 '></path><path style='stroke:black' d='M240.960000,625055.760000 L240.960000,625074.000000 L241.439980,625074.000000 L241.439980,625055.760000 '></path><path style='stroke:black' d='M277.320000,625055.760000 L277.320000,625074.000000 L277.799980,625074.000000 L277.799980,625055.760000 '></path><path style='stroke:black' d='M313.740000,625055.760000 L313.740000,625074.000000 L314.220010,625074.000000 L314.220010,625055.760000 '></path><path style='stroke:black' d='M313.920000,625073.460020 L313.920000,625073.940000 L350.520000,625073.940000 L350.520000,625073.460020 '></path><path style='stroke:black' d='M350.280000,625073.460020 L350.280000,625073.940000 L386.880000,625073.940000 L386.880000,625073.460020 '></path><path style='stroke:black' d='M386.640000,625073.460020 L386.640000,625073.940000 L423.240000,625073.940000 L423.240000,625073.460020 '></path><path style='stroke:black' d='M423.000000,625073.460020 L423.000000,625073.940000 L459.660000,625073.940000 L459.660000,625073.460020 '></path><path style='stroke:black' d='M168.240000,625073.519960 L168.240000,625074.000000 L204.840000,625074.000000 L204.840000,625073.519960 '></path><path style='stroke:black' d='M204.600000,625073.519960 L204.600000,625074.000000 L241.200000,625074.000000 L241.200000,625073.519960 '></path><path style='stroke:black' d='M240.960000,625073.519960 L240.960000,625074.000000 L277.560000,625074.000000 L277.560000,625073.519960 '></path><path style='stroke:black' d='M277.320000,625073.519960 L277.320000,625074.000000 L313.980000,625074.000000 L313.980000,625073.519960 '></path><path style='stroke:black' d='M167.640000,625085.460000 L167.640000,625103.700000 L168.120000,625103.700000 L168.120000,625085.460000 '></path><path style='stroke:black' d='M204.000000,625085.460000 L204.000000,625103.700000 L204.480000,625103.700000 L204.480000,625085.460000 '></path><path style='stroke:black' d='M240.420000,625085.460000 L240.420000,625103.700000 L240.900010,625103.700000 L240.900010,625085.460000 '></path><path style='stroke:black' d='M276.780000,625085.460000 L276.780000,625103.700000 L277.260010,625103.700000 L277.260010,625085.460000 '></path><path style='stroke:black' d='M167.880000,625085.460020 L167.880000,625085.940000 L204.480000,625085.940000 L204.480000,625085.460020 '></path><path style='stroke:black' d='M204.240000,625085.460020 L204.240000,625085.940000 L240.900000,625085.940000 L240.900000,625085.460020 '></path><path style='stroke:black' d='M240.660000,625085.460020 L240.660000,625085.940000 L277.260000,625085.940000 L277.260000,625085.460020 '></path><path style='stroke:black' d='M277.020000,625085.460020 L277.020000,625085.940000 L313.620000,625085.940000 L313.620000,625085.460020 '></path><path style='stroke:black' d='M204.000000,625085.700000 L204.000000,625103.940000 L204.480000,625103.940000 L204.480000,625085.700000 '></path><path style='stroke:black' d='M240.420000,625085.700000 L240.420000,625103.940000 L240.900010,625103.940000 L240.900010,625085.700000 '></path><path style='stroke:black' d='M276.780000,625085.700000 L276.780000,625103.940000 L277.260010,625103.940000 L277.260010,625085.700000 '></path><path style='stroke:black' d='M313.140000,625085.700000 L313.140000,625103.940000 L313.619980,625103.940000 L313.619980,625085.700000 '></path><path style='stroke:black' d='M313.320000,625086.060000 L313.320000,625103.640000 L313.799980,625103.640000 L313.799980,625086.060000 '></path><path style='stroke:black' d='M349.680000,625086.060000 L349.680000,625103.640000 L350.160010,625103.640000 L350.160010,625086.060000 '></path><path style='stroke:black' d='M386.100000,625086.060000 L386.100000,625103.640000 L386.579980,625103.640000 L386.579980,625086.060000 '></path><path style='stroke:black' d='M422.460000,625086.060000 L422.460000,625103.640000 L422.940010,625103.640000 L422.940010,625086.060000 '></path><path style='stroke:black' d='M313.560000,625086.060020 L313.560000,625086.540000 L350.160000,625086.540000 L350.160000,625086.060020 '></path><path style='stroke:black' d='M349.920000,625086.060020 L349.920000,625086.540000 L386.580000,625086.540000 L386.580000,625086.060020 '></path><path style='stroke:black' d='M386.340000,625086.060020 L386.340000,625086.540000 L422.940000,625086.540000 L422.940000,625086.060020 '></path><path style='stroke:black' d='M422.700000,625086.060020 L422.700000,625086.540000 L459.300000,625086.540000 L459.300000,625086.060020 '></path><path style='stroke:black' d='M349.680000,625086.300000 L349.680000,625103.880000 L350.160010,625103.880000 L350.160010,625086.300000 '></path><path style='stroke:black' d='M386.100000,625086.300000 L386.100000,625103.880000 L386.579980,625103.880000 L386.579980,625086.300000 '></path><path style='stroke:black' d='M422.460000,625086.300000 L422.460000,625103.880000 L422.940010,625103.880000 L422.940010,625086.300000 '></path><path style='stroke:black' d='M458.820000,625086.300000 L458.820000,625103.880000 L459.300010,625103.880000 L459.300010,625086.300000 '></path><path style='stroke:black' d='M313.320000,625103.399960 L313.320000,625103.880000 L349.920000,625103.880000 L349.920000,625103.399960 '></path><path style='stroke:black' d='M349.680000,625103.399960 L349.680000,625103.880000 L386.340000,625103.880000 L386.340000,625103.399960 '></path><path style='stroke:black' d='M386.100000,625103.399960 L386.100000,625103.880000 L422.700000,625103.880000 L422.700000,625103.399960 '></path><path style='stroke:black' d='M422.460000,625103.399960 L422.460000,625103.880000 L459.060000,625103.880000 L459.060000,625103.399960 '></path><path style='stroke:black' d='M167.640000,625103.460020 L167.640000,625103.940000 L204.240000,625103.940000 L204.240000,625103.460020 '></path><path style='stroke:black' d='M204.000000,625103.460020 L204.000000,625103.940000 L240.660000,625103.940000 L240.660000,625103.460020 '></path><path style='stroke:black' d='M240.420000,625103.460020 L240.420000,625103.940000 L277.020000,625103.940000 L277.020000,625103.460020 '></path><path style='stroke:black' d='M276.780000,625103.460020 L276.780000,625103.940000 L313.380000,625103.940000 L313.380000,625103.460020 '></path><text y='625097.087484' x='325.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>Y3</text><text y='625097.087484' x='400.203624' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y1</text><text y='625097.087484' x='436.268436' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y0</text><text y='625097.087484' x='363.356772' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y2</text><text y='625067.087484' x='182.5202' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X7</text><text y='625067.087484' x='217.38' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X6</text><text y='625097.087484' x='253.2599' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y5</text><text y='625125.5748' x='170.76' style='font-size:6.000000pt' lengthAdjust='spacingAndGlyphs' textLength='32.304'>ABS(X7:Y7)</text><text y='625067.087484' x='253.8598' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X5</text><text y='625067.087484' x='326.22' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='625067.087484' x='400.799484' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='625097.087484' x='181.9203' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y7</text><text y='625097.087484' x='291.84' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y4</text><text y='625125.5748' x='280.116' style='font-size:6.000000pt' lengthAdjust='spacingAndGlyphs' textLength='32.298'>ABS(X4:Y4)</text><text y='625125.5748' x='389.07' style='font-size:6.000000pt' lengthAdjust='spacingAndGlyphs' textLength='32.334'>ABS(X1:Y1)</text><text y='625125.5748' x='424.92' style='font-size:6.000000pt' lengthAdjust='spacingAndGlyphs' textLength='32.304'>ABS(X0:Y0)</text><text y='625159.727484' x='216.24' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='14.638512'>00H</text><text y='625159.727484' x='252.6599' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='14.695968'>00H</text><text y='625159.727484' x='291.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='14.638512'>00H</text><text y='625159.727484' x='362.814228' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='14.638512'>00H</text><text y='625159.727484' x='181.3801' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='14.638512'>00H</text><text y='625067.087484' x='292.4399' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X4</text><text y='625067.087484' x='436.856316' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='625097.087484' x='216.7801' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y6</text><text y='625159.727484' x='325.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='14.638512'>00H</text><text y='625158.1548' x='391.32' style='font-size:6.000000pt' lengthAdjust='spacingAndGlyphs' textLength='62.2782'>SUM(TEMP7...TEMP0)</text></svg><table><tr><td></td><td></td><td>ABS(X6:Y6) ABS(X5:Y5)</td><td></td><td></td><td>ABS(X3:Y3) ABS(X2:Y2)</td><td></td><td></td></tr></table><h3>Figure 4-10.  PSADBW Instruction Operation Using 64-bit Operands</h3></span>", "url": "PSADBW.html", "tooltip": "Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then summed to produce an unsigned word integer result that is stored in the destination operand. Figure 4-10 shows the operation of the PSADBW instruction when using 64-bit operands."},
    "MOVNTDQA": {"html": "<p>(V)MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint. A processor implementation may make use of the non-temporal hint associated with this instruction if the memory source is WC (write combining) memory type. An implementation may also make use of the non-temporal hint associated with this instruction if the memory source is WB (write back) memory type.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>A processor’s implementation of the non-temporal hint does not override the effective memory type semantics, but the implementation of the hint is processor dependent. For example, a processor implementation may choose to ignore the hint and process the instruction as a normal MOVDQA for any memory type. Another implementation of the hint for WC memory type may optimize data transfer throughput of WC reads. A third implementation may optimize cache reads generated by (V)MOVNTDQA on WB memory type to reduce cache evictions.</p><p><strong>WC Streaming Load Hint</strong></p><p>For WC memory type in particular, the processor never appears to read the data into the cache hierarchy. Instead, the non-temporal hint may be implemented by loading a temporary internal buffer with the equivalent of an aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped and flushed. Subsequent MOVNTDQA reads to unread portions of the WC cache line will receive data from the temporary internal buffer if data is available. The temporary internal buffer may be flushed by the processor at any time for any reason, for example:</p><p>The memory type of the region being read can override the non-temporal hint, if the memory address specified for the non-temporal read is not a WC memory region. Information on non-temporal reads and writes can be found in Chapter 11, 'Memory Cache Control” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p><p>Because the WC protocol uses a weakly-ordered memory consistency model, an MFENCE or locked instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might reference the same WC memory locations or in order to synchronize reads of a processor with writes by other agents in the system. Because of the speculative nature of fetching due to MOVNTDQA, Streaming loads must not be used to reference memory addresses that are mapped to I/O devices having side effects or when reads to these devices are destruc-</p><p>tive. For additional information on MOVNTDQA usages, see Section 12.10.3 in Chapter 12, 'Programming with SSE3, SSSE3 and SSE4” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><p>The 128-bit (V)MOVNTDQA addresses must be 16-byte aligned or the instruction will cause a #GP.</p><p>The 256-bit VMOVNTDQA addresses must be 32-byte aligned or the instruction will cause a #GP.</p><p>Note: In VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instruc-tions will #UD.</p></span>", "url": "MOVNTDQA.html", "tooltip": "(V)MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint. A processor implementation may make use of the non-temporal hint associated with this instruction if the memory source is WC (write combining) memory type. An implementation may also make use of the non-temporal hint associated with this instruction if the memory source is WB (write back) memory type."},
    "PSRLW": {"html": "<p>Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-15 gives an example of shifting words in a 64-bit operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note that only the first 64-bits of a 128-bit count operand are checked to compute the count.</p><svg width='568.799985' viewBox='112.380000 650696.999995 379.199990 88.140005' height='132.2100075'><text y='650715.827384' x='160.0799' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='31.008684'>Pre-Shift</text><text y='650724.107384' x='170.58' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='650737.705488' x='159.0' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='31.41744'>Shift Right</text><text y='650744.965388' x='161.7' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='28.485888'>with Zero</text><text y='650752.765488' x='161.1599' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='29.386512'>Extension</text><text y='650768.687684' x='155.2201' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='34.539834'>Post-Shift</text><text y='650776.667384' x='169.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.315378'>DEST</text><rect y='650708.16' x='194.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='650708.16' x='257.58' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='650708.16' x='383.4' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='650761.14' x='257.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='650761.14' x='319.92' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='650761.14' x='382.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='650761.14' x='194.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.94'></rect><rect y='650708.16' x='320.46' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.94'></rect><path style='stroke:black' d='M194.460000,650707.920000 L194.460000,650726.160000 L194.939980,650726.160000 L194.939980,650707.920000 '></path><path style='stroke:black' d='M257.340000,650707.920000 L257.340000,650726.160000 L257.820010,650726.160000 L257.820010,650707.920000 '></path><path style='stroke:black' d='M320.220000,650707.920000 L320.220000,650726.160000 L320.700010,650726.160000 L320.700010,650707.920000 '></path><path style='stroke:black' d='M383.160000,650707.920000 L383.160000,650726.160000 L383.640010,650726.160000 L383.640010,650707.920000 '></path><path style='stroke:black' d='M194.700000,650707.920020 L194.700000,650708.400000 L257.820000,650708.400000 L257.820000,650707.920020 '></path><path style='stroke:black' d='M257.580000,650707.920020 L257.580000,650708.400000 L320.700000,650708.400000 L320.700000,650707.920020 '></path><path style='stroke:black' d='M320.460000,650707.920020 L320.460000,650708.400000 L383.640000,650708.400000 L383.640000,650707.920020 '></path><path style='stroke:black' d='M383.400000,650707.920020 L383.400000,650708.400000 L446.520000,650708.400000 L446.520000,650707.920020 '></path><path style='stroke:black' d='M257.340000,650708.160000 L257.340000,650726.400000 L257.820010,650726.400000 L257.820010,650708.160000 '></path><path style='stroke:black' d='M320.220000,650708.160000 L320.220000,650726.400000 L320.700010,650726.400000 L320.700010,650708.160000 '></path><path style='stroke:black' d='M383.160000,650708.160000 L383.160000,650726.400000 L383.640010,650726.400000 L383.640010,650708.160000 '></path><path style='stroke:black' d='M446.040000,650708.160000 L446.040000,650726.400000 L446.519980,650726.400000 L446.519980,650708.160000 '></path><path style='stroke:black' d='M194.460000,650725.919990 L194.460000,650726.400000 L257.580000,650726.400000 L257.580000,650725.919990 '></path><path style='stroke:black' d='M257.340000,650725.919990 L257.340000,650726.400000 L320.460000,650726.400000 L320.460000,650725.919990 '></path><path style='stroke:black' d='M320.220000,650725.919990 L320.220000,650726.400000 L383.400000,650726.400000 L383.400000,650725.919990 '></path><path style='stroke:black' d='M383.160000,650725.919990 L383.160000,650726.400000 L446.280000,650726.400000 L446.280000,650725.919990 '></path><path style='stroke:black' d='M276.360000,650726.280000 L276.360000,650741.220000 L276.839980,650741.220000 L276.839980,650726.280000 '></path><path style='stroke:black' d='M212.640000,650726.340000 L212.640000,650741.280000 L213.120000,650741.280000 L213.120000,650726.340000 '></path><path style='stroke:black' d='M394.800000,650726.400000 L394.800000,650741.340000 L395.279980,650741.340000 L395.279980,650726.400000 '></path><path style='stroke:black' d='M333.120000,650726.820000 L333.120000,650741.760000 L333.600010,650741.760000 L333.600010,650726.820000 '></path><path style='stroke:black' d='M276.600000,650740.739990 L276.600000,650741.220000 L302.580000,650741.220000 L302.580000,650740.739990 '></path><path style='stroke:black' d='M212.880000,650740.800020 L212.880000,650741.280000 L238.860000,650741.280000 L238.860000,650740.800020 '></path><path style='stroke:black' d='M395.040000,650740.860020 L395.040000,650741.340000 L421.020000,650741.340000 L421.020000,650740.860020 '></path><path style='stroke:black' d='M302.100000,650740.980000 L302.100000,650753.940000 L302.579980,650753.940000 L302.579980,650740.980000 '></path><path style='stroke:black' d='M238.380000,650741.040000 L238.380000,650753.940000 L238.860010,650753.940000 L238.860010,650741.040000 '></path><path style='stroke:black' d='M420.540000,650741.100000 L420.540000,650754.000000 L421.019980,650754.000000 L421.019980,650741.100000 '></path><path style='stroke:black' d='M333.360000,650741.279990 L333.360000,650741.760000 L359.280000,650741.760000 L359.280000,650741.279990 '></path><path style='stroke:black' d='M358.800000,650741.520000 L358.800000,650754.420000 L359.279980,650754.420000 L359.279980,650741.520000 '></path><path style='stroke:black' d='M238.440000,650754.300000 L239.940000,650753.700000 L240.900000,650753.280000 L239.100000,650759.760000 L238.620000,650761.440000 L238.140000,650759.760000 L236.580000,650754.360000 L236.280000,650753.340000 L237.240000,650753.700000 L237.540000,650754.060000 L239.100000,650759.460000 L238.140000,650759.760000 L238.140000,650759.460000 L239.640000,650754.060000 L240.600000,650754.360000 L240.300000,650754.660000 L238.800000,650755.260000 '></path><path style='stroke:black' d='M302.160000,650754.240000 L303.660000,650753.700000 L304.620000,650753.280000 L304.320000,650754.360000 L302.820000,650759.700000 L302.340000,650761.320000 L301.860000,650759.700000 L300.300000,650754.360000 L300.000000,650753.340000 L300.960000,650753.700000 L301.260000,650754.060000 L302.820000,650759.400000 L301.860000,650759.700000 L301.860000,650759.400000 L303.360000,650754.060000 L304.320000,650754.360000 L304.020000,650754.660000 L302.520000,650755.200000 '></path><path style='stroke:black' d='M420.600000,650754.300000 L422.160000,650753.760000 L423.120000,650753.400000 L422.820000,650754.420000 L421.260000,650759.820000 L420.780000,650761.500000 L420.300000,650759.820000 L418.740000,650754.420000 L418.440000,650753.400000 L419.400000,650753.760000 L419.700000,650754.120000 L421.260000,650759.520000 L420.300000,650759.820000 L420.300000,650759.520000 L421.860000,650754.120000 L422.820000,650754.420000 L422.520000,650754.720000 L420.960000,650755.260000 '></path><path style='stroke:black' d='M237.240000,650753.700000 L238.800000,650754.300000 L238.800000,650755.260000 L238.620000,650755.320000 L238.440000,650755.260000 L236.880000,650754.660000 '></path><path style='stroke:black' d='M238.380000,650753.700000 L238.380000,650754.780000 L238.860010,650754.780000 L238.860010,650753.700000 '></path><path style='stroke:black' d='M300.960000,650753.700000 L302.520000,650754.240000 L302.520000,650755.200000 L302.340000,650755.260000 L302.160000,650755.200000 L300.600000,650754.660000 '></path><path style='stroke:black' d='M302.100000,650753.700000 L302.100000,650754.720000 L302.579980,650754.720000 L302.579980,650753.700000 '></path><path style='stroke:black' d='M419.400000,650753.760000 L420.960000,650754.300000 L420.960000,650755.260000 L420.780000,650755.320000 L420.600000,650755.260000 L419.040000,650754.720000 '></path><path style='stroke:black' d='M420.540000,650753.760000 L420.540000,650754.780000 L421.019980,650754.780000 L421.019980,650753.760000 '></path><path style='stroke:black' d='M358.860000,650754.780000 L360.420000,650754.180000 L361.380000,650753.820000 L361.080000,650754.840000 L359.520000,650760.240000 L359.040000,650761.980000 L358.560000,650760.240000 L357.060000,650754.840000 L356.760000,650753.820000 L357.720000,650754.180000 L358.020000,650754.540000 L359.520000,650759.940000 L358.560000,650760.240000 L358.560000,650759.940000 L360.120000,650754.540000 L361.080000,650754.840000 L360.780000,650755.140000 L359.220000,650755.740000 '></path><path style='stroke:black' d='M238.620000,650754.780000 L240.120000,650754.180000 L238.620000,650759.580000 L237.060000,650754.180000 '></path><path style='stroke:black' d='M302.340000,650754.720000 L303.840000,650754.180000 L302.340000,650759.520000 L300.780000,650754.180000 '></path><path style='stroke:black' d='M357.720000,650754.180000 L359.220000,650754.780000 L359.220000,650755.740000 L359.040000,650755.800000 L358.860000,650755.740000 L357.360000,650755.140000 '></path><path style='stroke:black' d='M358.800000,650754.180000 L358.800000,650755.260000 L359.279980,650755.260000 L359.279980,650754.180000 '></path><path style='stroke:black' d='M420.780000,650754.780000 L422.340000,650754.240000 L420.780000,650759.640000 L419.220000,650754.240000 '></path><path style='stroke:black' d='M359.040000,650755.260000 L360.600000,650754.660000 L359.040000,650760.060000 L357.540000,650754.660000 '></path><path style='stroke:black' d='M193.860000,650760.900000 L193.860000,650779.140000 L194.340000,650779.140000 L194.340000,650760.900000 '></path><path style='stroke:black' d='M256.800000,650760.900000 L256.800000,650779.140000 L257.280010,650779.140000 L257.280010,650760.900000 '></path><path style='stroke:black' d='M319.680000,650760.900000 L319.680000,650779.140000 L320.160010,650779.140000 L320.160010,650760.900000 '></path><path style='stroke:black' d='M382.560000,650760.900000 L382.560000,650779.140000 L383.040010,650779.140000 L383.040010,650760.900000 '></path><path style='stroke:black' d='M194.100000,650760.900020 L194.100000,650761.380000 L257.280000,650761.380000 L257.280000,650760.900020 '></path><path style='stroke:black' d='M257.040000,650760.900020 L257.040000,650761.380000 L320.160000,650761.380000 L320.160000,650760.900020 '></path><path style='stroke:black' d='M319.920000,650760.900020 L319.920000,650761.380000 L383.040000,650761.380000 L383.040000,650760.900020 '></path><path style='stroke:black' d='M382.800000,650760.900020 L382.800000,650761.380000 L445.920000,650761.380000 L445.920000,650760.900020 '></path><path style='stroke:black' d='M256.800000,650761.140000 L256.800000,650779.380000 L257.280010,650779.380000 L257.280010,650761.140000 '></path><path style='stroke:black' d='M319.680000,650761.140000 L319.680000,650779.380000 L320.160010,650779.380000 L320.160010,650761.140000 '></path><path style='stroke:black' d='M382.560000,650761.140000 L382.560000,650779.380000 L383.040010,650779.380000 L383.040010,650761.140000 '></path><path style='stroke:black' d='M445.440000,650761.140000 L445.440000,650779.380000 L445.920010,650779.380000 L445.920010,650761.140000 '></path><path style='stroke:black' d='M193.860000,650778.900000 L193.860000,650779.380000 L257.040000,650779.380000 L257.040000,650778.900000 '></path><path style='stroke:black' d='M256.800000,650778.900000 L256.800000,650779.380000 L319.920000,650779.380000 L319.920000,650778.900000 '></path><path style='stroke:black' d='M319.680000,650778.900000 L319.680000,650779.380000 L382.800000,650779.380000 L382.800000,650778.900000 '></path><path style='stroke:black' d='M382.560000,650778.900000 L382.560000,650779.380000 L445.680000,650779.380000 L445.680000,650778.900000 '></path><text y='650719.907684' x='220.9198' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='650719.907684' x='284.635312' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='650719.907484' x='407.94' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X0</text><text y='650773.667384' x='262.6801' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.59916'>X2 &gt;&gt; COUNT</text><text y='650773.667384' x='325.9199' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.5834'>X1 &gt;&gt; COUNT</text><text y='650773.667184' x='386.5201' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='11.997132'>X0 &gt;&gt; COUNT</text><text y='650773.667384' x='198.8998' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.65532'>X3 &gt;&gt; COUNT</text><text y='650719.907684' x='345.653584' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text></svg><h3>Figure 4-15.  PSRLW, PSRLD, and PSRLQ Instruction Operation Using 64-bit Operand</h3><p>The (V)PSRLW instruction shifts each of the words in the destination operand to the right by the number of bits specified in the count operand; the (V)PSRLD instruction shifts each of the doublewords in the destination operand; and the PSRLQ instruction shifts the quadword (or quadwords) in the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.</p><p>128-bit Legacy SSE version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits</p><p>are loaded but the upper 64 bits are ignored. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The destination operand is an XMM register; the count operand can be either an XMM register or a 128-bit memory location, or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 128-bit memory location or an 8-bit immediate.</p><p>Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /2), VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSRLW:PSRLD:PSRLQ.html", "tooltip": "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-15 gives an example of shifting words in a 64-bit operand."},
    "MOVDQA": {"html": "<p>128-bit versions:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.</p><p>When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version:</p><p>Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.</p><p>When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "MOVDQA.html", "tooltip": "128-bit versions:"},
    "CWD": {"html": "<p>Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruc-tion (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO instruction can be used to produce a double quadword dividend from a quadword before a quadword division.</p><p>The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.</p><p>In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "CWD:CDQ:CQO.html", "tooltip": "Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruc-tion (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register."},
    "SYSRET": {"html": "<p>SYSRET is a companion instruction to the SYSCALL instruction. It returns from an OS system-call handler to user code at privilege level 3. It does so by loading RIP from RCX and loading RFLAGS from R11.<sup>1</sup> With a 64-bit operand size, SYSRET remains in 64-bit mode; otherwise, it enters compatibility mode and only the low 32 bits of the regis-ters are loaded.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>SYSRET loads the CS and SS selectors with values derived from bits 63:48 of the IA32_STAR MSR. However, the CS and SS descriptor caches are <strong>not</strong> loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the respon-sibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values corre-spond to the fixed values loaded into the descriptor caches; the SYSRET instruction does not ensure this correspondence.</p><p>The SYSRET instruction does not modify the stack pointer (ESP or RSP). For that reason, it is necessary for software to switch to the user stack. The OS may load the user stack pointer (if it was saved after SYSCALL) before executing SYSRET; alternatively, user code may load the stack pointer (if it was saved before SYSCALL) after receiving control from SYSRET.</p><p>If the OS loads the stack pointer before executing SYSRET, it must ensure that the handler of any interrupt or exception delivered between restoring the stack pointer and successful execution of SYSRET is not invoked with the user stack. It can do so using approaches such as the following:</p><p>— Confirming that the value of RCX is canonical before executing SYSRET.</p><p>— Using paging to ensure that the SYSCALL instruction will never save a non-canonical value into RCX.</p><p>— Using the IST mechanism for gate 13 (#GP) in the IDT.</p></span>", "url": "SYSRET.html", "tooltip": "SYSRET is a companion instruction to the SYSCALL instruction. It returns from an OS system-call handler to user code at privilege level 3. It does so by loading RIP from RCX and loading RFLAGS from R11.<sup>1</sup> With a 64-bit operand size, SYSRET remains in 64-bit mode; otherwise, it enters compatibility mode and only the low 32 bits of the regis-ters are loaded."},
    "EMMS": {"html": "<p>Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instruc-tions. (See Figure 8-7 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for the format of the x87 FPU tag word.) All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions. If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will result in an x87 floating-point exception or incorrect result.</p><p>EMMS operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "EMMS.html", "tooltip": "Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instruc-tions. (See Figure 8-7 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for the format of the x87 FPU tag word.) All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s)."},
    "MOVNTI": {"html": "<p>Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a general-purpose register. The destination operand is a 32-bit memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see 'Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple proces-sors might use different memory types to read/write the destination memory locations.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOVNTI.html", "tooltip": "Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a general-purpose register. The destination operand is a 32-bit memory location."},
    "VPMASKMOV": {"html": "<p>Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are speci-fied in the first source operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.</p><p>The second source operand is a memory address for the load form of these instructions. The destination operand is a memory address for the store form of these instructions. The other operands are either XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).</p><p>Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.</p><p>Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.</p><p>Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.</p><p>VMASKMOV should not be used to access memory mapped I/O as the ordering of the individual loads or stores it does is implementation specific.</p><p>In cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an imple-mentation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.</p><p>Note: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.</p><p>Note: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field.</p></span>", "url": "VPMASKMOV.html", "tooltip": "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are speci-fied in the first source operand."},
    "BSF": {"html": "<p>Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content of the source operand is 0, the content of the destination operand is undefined.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "BSF.html", "tooltip": "Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content of the source operand is 0, the content of the destination operand is undefined."},
    "MOVZX": {"html": "<p>Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value. The size of the converted value depends on the operand-size attribute.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOVZX.html", "tooltip": "Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value. The size of the converted value depends on the operand-size attribute."},
    "FCLEX": {"html": "<p>Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does not.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p></span>", "url": "FCLEX:FNCLEX.html", "tooltip": "Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does not."},
    "RSQRTSS": {"html": "<p>Computes an approximate reciprocal of the square root of the low single-precision floating-point value in the source operand (second operand) stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The relative error for this approximation is:</p><p>|Relative Error| ≤ 1.5 ∗ 2<sup>−12</sup></p><p>The RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "RSQRTSS.html", "tooltip": "Computes an approximate reciprocal of the square root of the low single-precision floating-point value in the source operand (second operand) stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation."},
    "VFMSUB132SD": {"html": "<p>Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From the infinite precision inter-mediate result, subtracts the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VFMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From the infinite precision inter-mediate result, subtracts the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VFMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 64-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMSUB132SD:VFMSUB213SD:VFMSUB231SD.html", "tooltip": "Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "XSAVE": {"html": "<p>Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The format of the XSAVE area is detailed in Section 13.4, 'XSAVE Area,” of <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>.</p><p>Section 13.6, 'Operation of XSAVE,” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 </em>provides a detailed description of the operation of the XSAVE instruction. The following items provide a high-level outline:</p><p>Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</p></span>", "url": "XSAVE.html", "tooltip": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0."},
    "CLTS": {"html": "<p>Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-address mode to allow initialization for protected mode.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU context in multitasking applications. See the description of the TS flag in the section titled 'Control Registers” in Chapter 2 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for more information about this flag.</p><p>CLTS operation is the same in non-64-bit modes and 64-bit mode.</p><p>See Chapter 25, 'VMX Non-Root Operation,” of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p></span>", "url": "CLTS.html", "tooltip": "Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-address mode to allow initialization for protected mode."},
    "VFMADDSUB132PS": {"html": "<p>VFMADDSUB132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMADDSUB213PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFMADDSUB231PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMADDSUB132PS:VFMADDSUB213PS:VFMADDSUB231PS.html", "tooltip": "VFMADDSUB132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand)."},
    "POPCNT": {"html": "<p>This instruction calculates of number of bits set to 1 in the second operand (source) and returns the count in the first operand (a destination register).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "POPCNT.html", "tooltip": "This instruction calculates of number of bits set to 1 in the second operand (source) and returns the count in the first operand (a destination register)."},
    "PSHUFHW": {"html": "<p>Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quad-word of the destination operand at word locations (of the respective lane) selected with the immediate operand. This 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illus-trated in Figure 4-12. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note that this instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p><p>VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.</p><p>Note: In VEX encoded versions VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "PSHUFHW.html", "tooltip": "Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quad-word of the destination operand at word locations (of the respective lane) selected with the immediate operand. This 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illus-trated in Figure 4-12. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane."},
    "ANDPD": {"html": "<p>Performs a bitwise logical AND of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "ANDPD.html", "tooltip": "Performs a bitwise logical AND of the two packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand."},
    "BT": {"html": "<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>See also: <strong>Bit(BitBase, BitOffset) </strong>on page 3-10.</p><p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-tion with the displacement field of the memory operand. In this case, the low-order 3 or 5 bits (3 for 16-bit oper-ands, 5 for 32-bit operands) of the immediate bit offset are stored in the immediate bit offset field, and the high-order bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The processor will ignore the high order bits if they are not zero.</p><p>When accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit operand size, using by the following relationship:</p><p>Effective Address + (4 ∗ (BitOffset DIV 32))</p><p>Or, it may access 2 bytes starting from the memory address for a 16-bit operand, using this relationship:</p><p>Effective Address + (2 ∗ (BitOffset DIV 16))</p><p>It may do so even when only a single byte needs to be accessed to reach the given bit. When using this bit addressing mechanism, software should avoid referencing areas of memory close to address space holes. In partic-ular, it should avoid references to memory-mapped I/O registers. Instead, software should use the MOV instruc-tions to load from or store to these addresses, and use the register form of these instructions to manipulate the data.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit oper-ands. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "BT.html", "tooltip": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:"},
    "PABSB": {"html": "<p>(V)PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). (V)PABSB operates on signed bytes, (V)PABSW operates on 16-bit words, and (V)PABSD operates on signed 32-bit integers. The source operand can be an MMX register or a 64-bit memory location, or it can be an XMM register, a YMM register, a 128-bit memory loca-tion, or a 256-bit memory location. The destination operand can be an MMX, an XMM or a YMM register. Both oper-ands can be MMX registers or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>128-bit Legacy SSE version: The source operand can be an XMM register or a 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD.</p></span>", "url": "PABSB:PABSW:PABSD.html", "tooltip": "(V)PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). (V)PABSB operates on signed bytes, (V)PABSW operates on 16-bit words, and (V)PABSD operates on signed 32-bit integers. The source operand can be an MMX register or a 64-bit memory location, or it can be an XMM register, a YMM register, a 128-bit memory loca-tion, or a 256-bit memory location. The destination operand can be an MMX, an XMM or a YMM register. Both oper-ands can be MMX registers or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16byte boundary or a general-protection exception (#GP) will be generated."},
    "PMULHRSW": {"html": "<p>PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and packed to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>Legacy SSE version: Both operands can be MMX registers. The second source operand is an MMX register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p></span>", "url": "PMULHRSW.html", "tooltip": "PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and packed to the destination operand."},
    "PMAXSB": {"html": "<p>Compares packed signed byte integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMAXSB.html", "tooltip": "Compares packed signed byte integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand."},
    "CMPS": {"html": "<p>Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the</p><p>instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.</p><p>At the assembly-code level, two forms of this instruction are allowed: the 'explicit-operands” form and the 'no-operands” form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-tion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) regis-ters, which must be loaded correctly before the compare string instruction is executed.</p><p>The no-operands form provides 'short forms” of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the loca-tion of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte compar-ison), CMPSW (word comparison), CMPSD (doubleword comparison), or CMPSQ (quadword comparison using REX.W).</p><p>After the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.</p><p>The CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block compar-isons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See 'REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B</em>, for a description of the REP prefix.</p><p>In 64-bit mode, the instruction’s default address size is 64 bits, 32 bit address size is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ). See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html", "tooltip": "Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results."},
    "PHADDSW": {"html": "<p>(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand) When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PHADDSW.html", "tooltip": "(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand) When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},
    "VFNMSUB132SS": {"html": "<p>VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From negated infinite precision interme-diate result, the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 32-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMSUB132SS:VFNMSUB213SS:VFNMSUB231SS.html", "tooltip": "VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand)."},
    "PEXTRB": {"html": "<p>Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.</p><p>Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros. Attempt to execute VPEXTRQ in non-64-bit mode will cause #UD.</p></span>", "url": "PEXTRB:PEXTRD:PEXTRQ.html", "tooltip": "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended."},
    "MOVDQ2Q": {"html": "<p>Moves the low quadword from the source operand (second operand) to the destination operand (first operand). The source operand is an XMM register and the destination operand is an MMX technology register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "MOVDQ2Q.html", "tooltip": "Moves the low quadword from the source operand (second operand) to the destination operand (first operand). The source operand is an XMM register and the destination operand is an MMX technology register."},
    "ANDNPD": {"html": "<p>Performs a bitwise logical AND NOT of the two or four packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "ANDNPD.html", "tooltip": "Performs a bitwise logical AND NOT of the two or four packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand."},
    "PHADDW": {"html": "<p>(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note that these instructions can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.</p><p>Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p><svg width='216.0000075' viewBox='151.200000 543516.540005 144.000005 18.120005' height='27.1800074999'><rect y='543516.66' x='151.2' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.0'></rect><text y='543528.467584' x='155.3416' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>Y7</text><text y='543528.467584' x='172.437952' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.781086'>Y6</text><text y='543528.467584' x='191.704864' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>Y5</text><text y='543528.467584' x='208.7414' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y4</text><text y='543529.067684' x='227.1608' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='543529.067684' x='244.320992' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='543529.067684' x='263.524064' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='543529.067684' x='280.5606' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text></svg><table class='exception-table'><tr><td>X7</td><td>X6</td><td>X5</td><td>X4</td><td>X3</td><td>X2</td><td>X1</td><td>X0</td></tr></table><p>SRC2</p><p>SRC1</p><p>S4</p><p>S3</p><p>S0</p><p>S7</p><p>S3</p><p>S3</p><p>S2</p><p>S1</p><p>255</p><p>0</p><p>Dest</p><h3>Figure 4-6.  256-bit VPHADDD Instruction Operation</h3></span>", "url": "PHADDW:PHADDD.html", "tooltip": "(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},
    "CVTSI2SD": {"html": "<p>Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the second source operand to a double-precision floating-point value in the destination operand. The result is stored in the low quad-word of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Legacy SSE instructions: Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary chart at the beginning of this section for encoding data and limits.</p><p>The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers.</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "CVTSI2SD.html", "tooltip": "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the second source operand to a double-precision floating-point value in the destination operand. The result is stored in the low quad-word of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register."},
    "BLSI": {"html": "<p>Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in the destination to 0 and sets ZF and CF.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "BLSI.html", "tooltip": "Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in the destination to 0 and sets ZF and CF."},
    "LDMXCSR": {"html": "<p>Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location. See 'MXCSR Control and Status Register” in Chapter 10, of the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for a description of the MXCSR register and its contents.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.</p><p>The default MXCSR value at reset is 1F80H.</p><p>If a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only upon the execution of the next instruction that meets both conditions below:</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p><p>If VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "LDMXCSR.html", "tooltip": "Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location. See 'MXCSR Control and Status Register” in Chapter 10, of the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for a description of the MXCSR register and its contents."},
    "BLSMSK": {"html": "<p>Sets all the lower bits of the destination operand to '1” up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "BLSMSK.html", "tooltip": "Sets all the lower bits of the destination operand to '1” up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1."},
    "LAR": {"html": "<p>Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. If the source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-purpose register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The processor performs access checks as part of the loading process. Once loaded in the destination register, soft-ware can perform additional checks on the access rights information.</p><p>The access rights for a segment descriptor include fields located in the second doubleword (bytes 4–7) of the segment descriptor. The following fields are loaded by the LAR instruction:</p><p>— Bits 19:16 are undefined.</p><p>— Bit 20 returns the software-available bit in the descriptor.</p><p>— Bit 21 returns the L flag.</p><p>— Bit 22 returns the D/B flag.</p><p>— Bit 23 returns the G flag.</p><p>— Bits 31:24 are returned as 0.</p><p>This instruction performs the following checks before it loads the access rights in the destination register:</p><p>If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no access rights are loaded in the destination operand.</p><p>The LAR instruction can only be executed in protected mode and IA-32e mode.</p><h3>Table 3-62.  Segment and Gate Types</h3><table><tr><th>Type</th><th>Protected Mode</th><td></td><th>IA-32e Mode</th><td></td></tr><tr><td></td><th>Name</th><th>Valid</th><th>Name</th><th>Valid</th></tr><tr><td><p>0</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>A</p><p>B</p><p>C</p><p>D</p><p>E</p><p>F</p></td><td><p>Reserved</p><p>Available 16-bit TSS</p><p>LDT</p><p>Busy 16-bit TSS</p><p>16-bit call gate</p><p>16-bit/32-bit task gate</p><p>16-bit interrupt gate</p><p>16-bit trap gate</p><p>Reserved</p><p>Available 32-bit TSS</p><p>Reserved</p><p>Busy 32-bit TSS</p><p>32-bit call gate</p><p>Reserved</p><p>32-bit interrupt gate</p><p>32-bit trap gate</p></td><td><p>No</p><p>Yes</p><p>Yes</p><p>Yes</p><p>Yes</p><p>Yes</p><p>No</p><p>No</p><p>No</p><p>Yes</p><p>No</p><p>Yes</p><p>Yes</p><p>No</p><p>No</p><p>No</p></td><td><p>Reserved</p><p>Reserved</p><p>LDT</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>Reserved</p><p>Available 64-bit TSS</p><p>Reserved</p><p>Busy 64-bit TSS</p><p>64-bit call gate</p><p>Reserved</p><p>64-bit interrupt gate</p><p>64-bit trap gate</p></td><td><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>No</p><p>Yes</p><p>No</p><p>Yes</p><p>Yes</p><p>No</p><p>No</p><p>No</p></td></tr></table></span>", "url": "LAR.html", "tooltip": "Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. If the source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-purpose register."},
    "BLENDPD": {"html": "<p>Double-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double-precision floating-point value in the desti-nation is copied from the second source or first source. If a bit in the mask, corresponding to a word, is '1', then the double-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "BLENDPD.html", "tooltip": "Double-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double-precision floating-point value in the desti-nation is copied from the second source or first source. If a bit in the mask, corresponding to a word, is '1', then the double-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied."},
    "ARPL": {"html": "<p>Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand. Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can be a word register or a memory location; the source operand must be a word register.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applica-tions). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system by an application program to match the privilege level of the application program. Here the segment selector passed to the operating system is placed in the destination operand and segment selector for the application program’s code segment is placed in the source operand. (The RPL field in the source operand represents the priv-ilege level of the application program.) Execution of the ARPL instruction then ensures that the RPL of the segment selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of the application program (the segment selector for the application program’s code segment can be read from the stack following a procedure call).</p><p>This instruction executes as described in compatibility mode and legacy mode. It is not encodable in 64-bit mode.</p><p>See 'Checking Caller Access Privileges” in Chapter 3, 'Protected-Mode Memory Management,” of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for more information about the use of this instruc-tion.</p></span>", "url": "ARPL.html", "tooltip": "Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand. Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can be a word register or a memory location; the source operand must be a word register.)"},
    "RDMSR": {"html": "<p>Reads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.</p><p>The MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors. Chapter 35, 'Model-Specific Registers (MSRs),” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C</em>, lists all the MSRs that can be read with this instruction and their addresses. Note that each processor family has its own set of MSRs.</p><p>The CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.</p></span>", "url": "RDMSR.html", "tooltip": "Reads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined."},
    "VFNMADD132SS": {"html": "<p>VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the negated infinite preci-sion intermediate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite preci-sion intermediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 32-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMADD132SS:VFNMADD213SS:VFNMADD231SS.html", "tooltip": "VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand)."},
    "MOVAPS": {"html": "<p>Moves 4 or8 single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM or YMM register from an 128-bit or 256-bit memory location, to store the contents of an XMM or YMM register into a 128-bit or 256-bit memory location, or to move data between two XMM or two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>To move single-precision floating-point values to and from unaligned memory locations, use the (V)MOVUPS instruction.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>128-bit versions:</p><p>Moves 128 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version:</p><p>Moves 256 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.</p></span>", "url": "MOVAPS.html", "tooltip": "Moves 4 or8 single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM or YMM register from an 128-bit or 256-bit memory location, to store the contents of an XMM or YMM register into a 128-bit or 256-bit memory location, or to move data between two XMM or two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary or a general-protection exception (#GP) will be generated."},
    "VCVTPS2PH": {"html": "<p>Convert four or eight packed single-precision floating values in first source operand to four or eight packed half-precision (16-bit) floating-point values. The rounding mode is specified using the immediate field (imm8).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Underflow results (i.e. tiny results) are converted to denormals. MXCSR.FTZ is ignored. If a source element is denormal relative to input format with MXCSR.DAZ not set, DM masked and at least one of PM or UM unmasked; a SIMD exception will be raised with DE, UE and PE set.</p><p>128-bit version: The source operand is a XMM register. The destination operand is a XMM register or 64-bit memory location. The upper-bits vector register zeroing behavior of VEX prefix encoding still applies if the destination operand is a xmm register. So the upper bits (255:64) of corresponding YMM register are zeroed.</p><p>256-bit version: The source operand is a YMM register. The destination operand is a XMM register or 128-bit memory location. The upper-bits vector register zeroing behavior of VEX prefix encoding still applies if the destina-tion operand is a xmm register. So the upper bits (255:128) of the corresponding YMM register are zeroed.</p><p>Note: VEX.vvvv is reserved (must be 1111b).</p><p>The diagram below illustrates how data is converted from four packed single precision (in 128 bits) to four half precision (in 64 bits) FP values.</p><svg width='594.089985' viewBox='103.440000 809952.000010 396.059990 141.119985' height='211.6799775'><text y='809976.885403' x='193.799' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='41.88265083'>VCVTPS2PH xmm1/mem64, xmm2,  imm8</text><text y='809987.205503' x='113.8798' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='68.81618554'>127                              96</text><text y='809987.205503' x='193.7997' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='68.38018085'>95                                64</text><text y='809987.205503' x='273.7793' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='68.38018085'>63                                32</text><text y='809987.205503' x='353.759' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='67.9670177'>31                                  0</text><text y='809997.585703' x='145.08' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.91487544'>VS3</text><text y='809997.585703' x='225.06' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.91621906'>VS2</text><text y='809997.585703' x='305.04' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.91621906'>VS1</text><text y='809997.585703' x='385.02' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.85575616'>VS0</text><text y='809997.585703' x='443.6975' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='17.89903383'>xmm2</text><text y='810015.705803' x='299.64' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='21.83516862'>convert</text><text y='810018.285703' x='140.1' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='21.83516862'>convert</text><text y='810018.285703' x='219.66' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='21.83516862'>convert</text><text y='810020.865703' x='399.6' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='21.83516862'>convert</text><text y='810070.065803' x='113.8809' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='68.81618554'>127                              96</text><text y='810070.065803' x='193.8008' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='68.38018085'>95                                64</text><text y='810070.065803' x='273.7804' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='33.3419303'>63           48</text><text y='810070.065803' x='313.8001' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='33.29087274'>47           32</text><text y='810070.065803' x='353.7601' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='33.3419303'>31           16</text><text y='810070.065803' x='393.72' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='32.92876715'>15             0</text><text y='810080.445703' x='285.06' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.85575616'>VH3</text><text y='810080.445703' x='325.02' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.91621906'>VH2</text><text y='810080.445703' x='364.98' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.91487544'>VH1</text><text y='810080.445703' x='405.0' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='12.91621906'>VH0</text><text y='810080.446103' x='443.6975' style='font-size:6.718100pt' lengthAdjust='spacingAndGlyphs' textLength='42.07478849'>xmm1/mem64</text><rect y='810008.94' x='297.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='28.44'></rect><rect y='810014.1' x='397.2' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.38' width='28.44'></rect><rect y='810011.52' x='137.76' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.38' width='28.44'></rect><rect y='810011.52' x='217.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.38' width='28.44'></rect><rect y='810073.68' x='391.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='39.96'></rect><rect y='810073.68' x='311.46' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='39.96'></rect><rect y='810073.68' x='271.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='39.96'></rect><rect y='810073.68' x='351.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='40.02'></rect><rect y='809990.82' x='271.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.92'></rect><rect y='810073.68' x='191.52' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='79.98'></rect><rect y='810073.68' x='111.54' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='79.98'></rect><rect y='809990.82' x='191.52' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.98'></rect><rect y='809990.82' x='111.54' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.98'></rect><rect y='809990.82' x='351.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.98'></rect><rect y='810073.68' x='391.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='39.96'></rect><rect y='810073.68' x='311.46' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='39.96'></rect><rect y='810073.68' x='271.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='39.96'></rect><rect y='810073.68' x='351.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='40.02'></rect><rect y='809990.82' x='271.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.92'></rect><rect y='810073.68' x='191.52' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='79.98'></rect><rect y='810073.68' x='111.54' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3199999999' width='79.98'></rect><rect y='809990.82' x='191.52' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.98'></rect><rect y='809990.82' x='111.54' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.98'></rect><rect y='809990.82' x='351.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='10.3200000001' width='79.98'></rect></svg><h3>Figure 4-32.  VCVTPS2PH (128-bit Version)</h3><p>The immediate byte defines several bit fields that controls rounding operation. The effect and encoding of RC field are listed in Table 4-17.</p><h3>Table 4-17.  Immediate Byte Encoding for 16-bit Floating-Point Conversion Instructions</h3><table><tr><th>Bits</th><th>Field Name/value</th><th>Description</th><th>Comment</th></tr><tr><td>Imm[1:0]</td><td>RC=00B</td><td>Round to nearest even</td><td>If Imm[2] = 0</td></tr><tr><td></td><td>RC=01B</td><td>Round down</td><td></td></tr><tr><td></td><td>RC=10B</td><td>Round up</td><td></td></tr><tr><td></td><td>RC=11B</td><td>Truncate</td><td></td></tr><tr><td>Imm[2]</td><td>MS1=0</td><td>Use imm[1:0] for rounding</td><td>Ignore MXCSR.RC</td></tr><tr><td></td><td>MS1=1</td><td>Use MXCSR.RC for rounding</td><td></td></tr><tr><td>Imm[7:3]</td><td>Ignored</td><td>Ignored by processor</td><td></td></tr></table></span>", "url": "VCVTPS2PH.html", "tooltip": "Convert four or eight packed single-precision floating values in first source operand to four or eight packed half-precision (16-bit) floating-point values. The rounding mode is specified using the immediate field (imm8)."},
    "PSUBB": {"html": "<p>Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.</p><p>The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.</p><p>The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.</p><p>Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-nation register remain unchanged.</p><p>VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSUBB:PSUBW:PSUBD.html", "tooltip": "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs."},
    "LDDQU": {"html": "<p>The instruction is <em>functionally similar </em>to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction.</p></span>", "url": "LDDQU.html", "tooltip": "The instruction is <em>functionally similar </em>to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent."},
    "XOR": {"html": "<p>Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory oper-ands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "XOR.html", "tooltip": "Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory oper-ands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same."},
    "PMAXSW": {"html": "<p>Performs a SIMD compare of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of word integers to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMAXSW.html", "tooltip": "Performs a SIMD compare of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of word integers to the destination operand."},
    "CVTPD2DQ": {"html": "<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The result is stored in the low quadword of the destination operand and the high quadword is cleared to all 0s.</p><p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operation is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operation is a YMM register. The upper bits (VLMAX-1:64) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p><svg width='445.5000075' viewBox='133.860000 145054.439980 297.000005 13.500030' height='20.250045'><rect y='145054.44' x='133.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.22'></rect><rect y='145054.44' x='208.08' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.28'></rect><rect y='145054.44' x='282.36' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.28'></rect><rect y='145054.44' x='356.64' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.22'></rect><text y='145062.5535' x='157.5' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X3</text><text y='145062.5535' x='241.86' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X2</text><text y='145062.5535' x='316.2' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.12972555'>X1</text><text y='145062.5535' x='390.3624926' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.07168505'>X0</text></svg><p>SRC</p><p>DEST</p><p>0</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><h3>Figure 3-11.  VCVTPD2DQ (VEX.256 encoded version)</h3></span>", "url": "CVTPD2DQ.html", "tooltip": "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand)."},
    "SCAS": {"html": "<p>In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-oper-ands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be speci-fied explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (AL register for byte comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided to allow documentation. Note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it does not have to specify the correct location. The location is always specified by ES:(E)DI.</p><p>The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).</p><p>After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word oper-ations, and by 4 for doubleword operations.</p><p>SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes, words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes</p><p>some action based on the setting of status flags. See 'REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.</p><p>In 64-bit mode, the instruction’s default address size is 64-bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit no-operand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented or decremented by the current operand size (depending on the value of the DF flag). See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "SCAS:SCASB:SCASW:SCASD.html", "tooltip": "In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix."},
    "LGDT": {"html": "<p>Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.</p><p>In 64-bit mode, the instruction’s operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the summary chart at the beginning of this section for encoding data and limits.</p><p>See 'SGDT—Store Global Descriptor Table Register” in Chapter 4, <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B</em>, for information on storing the contents of the GDTR and IDTR.</p></span>", "url": "LGDT:LIDT.html", "tooltip": "Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros."},
    "XORPS": {"html": "<p>Performs a bitwise logical exclusive-OR of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "XORPS.html", "tooltip": "Performs a bitwise logical exclusive-OR of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the result in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register."},
    "PCMPISTRM": {"html": "<p>The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask stored to XMM0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data).  Each input byte/word is augmented with a valid/invalid tag.  A byte/word is considered valid only if it has a lower index than the least significant null byte/word.  (The least significant null byte/word is also considered invalid.)</p><p>The comparison and aggregation operation are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.</p><p>Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-tion:</p><p>CFlag – Reset if IntRes2 is equal to zero, set otherwise</p><p>ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise</p><p>SFlag – Set if any byte/word of xmm1 is null, reset otherwise</p><p>OFlag – IntRes2[0]</p><p>AFlag – Reset</p><p>PFlag – Reset</p><p>Note: In VEX.128 encoded versions, bits (VLMAX-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PCMPISTRM.html", "tooltip": "The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask stored to XMM0."},
    "MPSADBW": {"html": "<p>(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane. Each SAD word result is calculated between a stationary block_2 (whose offset within the second source operand is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit select control, multiplied by 32 bits.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source operand and destination operand are the same. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. Bits 7:3 of the immediate byte are ignored.</p><p>VEX.128 encoded version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source and desti-nation operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (127:128) of the corresponding YMM register are zeroed. Bits 7:3 of the immediate byte are ignored.</p><p>VEX.256 encoded version: The sum-absolute-difference (SAD) operation is repeated 8 times for MPSADW between the same block_2 (fixed offset within the second source operand) and a variable block_1 (offset is shifted by 8 bits for each SAD operation) in the first source operand. Each 16-bit result of eight SAD operations between block_2 and block_1 is written to the respective word in the lower 128 bits of the destination operand.</p><p>Additionally, VMPSADBW performs another eight SAD operations on block_4 of the second source operand and block_3 of the first source operand. (Imm8[4:3]*32 + 128) specifies the bit offset of block_4 within the second source operand. (Imm[5]*32+128) specifies the initial bit offset of the block_3 within the first source operand. Each 16-bit result of eight SAD operations between block_4 and block_3 is written to the respective word in the upper 128 bits of the destination operand.</p><p>The first source operand is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits 7:6 of the immediate byte are ignored.</p><p>Note: If VMPSADBW is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p><svg width='568.799985' viewBox='111.840000 451582.980010 379.199990 414.119990' height='621.179985'><text y='451606.306926' x='365.7' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='61.0698629'>Imm[4:3]*32+128</text><text y='451614.946526' x='442.08' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>128</text><text y='451615.726426' x='156.0608' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>255</text><text y='451615.906226' x='218.7008' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>224</text><text y='451616.145926' x='292.0805' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>192</text><text y='451649.326726' x='159.8403' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='16.38091403'>Src2</text><text y='451653.106926' x='349.2' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='32.27441976'>Abs. Diff.</text><text y='451656.347026' x='400.6799' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='54.41554106'>Imm[5]*32+128</text><text y='451706.506926' x='158.2207' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='16.45682188'>Src1</text><text y='451735.726326' x='401.5204' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3837525'>144</text><text y='451735.906926' x='440.1' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>128</text><text y='451736.746726' x='173.8808' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>255</text><text y='451766.926726' x='153.8407' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='40.01302531'>Destination</text><text y='451804.546926' x='371.28' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='43.0836976'>Imm[1:0]*32</text><text y='451813.127426' x='447.7199' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='4.4426068'>0</text><text y='451813.967226' x='161.7007' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>127</text><text y='451814.147026' x='224.2808' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='8.88121845'>96</text><text y='451814.326826' x='297.6605' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='8.88121845'>64</text><text y='451847.566726' x='165.4203' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='16.45682188'>Src2</text><text y='451851.286926' x='354.78' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='32.27521879'>Abs. Diff.</text><text y='451854.527026' x='406.3199' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='36.4837098'>Imm[2]*32</text><text y='451901.746226' x='168.6004' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='16.45682188'>Src1</text><text y='451933.967126' x='407.1004' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='8.88121845'>16</text><text y='451934.146926' x='445.68' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='4.4426068'>0</text><text y='451934.926826' x='179.4608' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='13.3198301'>127</text><text y='451967.146326' x='156.6006' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='40.0154224'>Destination</text><rect y='451938.48' x='215.64' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.6'></rect><rect y='451938.48' x='182.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.6'></rect><rect y='451938.48' x='416.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.6'></rect><rect y='451938.48' x='382.68' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.6'></rect><rect y='451938.48' x='349.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.6'></rect><rect y='451938.48' x='315.84' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.6'></rect><rect y='451938.48' x='249.06' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.6'></rect><rect y='451938.48' x='282.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='33.66'></rect><rect y='451740.24' x='243.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.06' width='33.6'></rect><rect y='451740.24' x='210.06' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.06' width='33.6'></rect><rect y='451740.24' x='176.64' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.06' width='33.6'></rect><rect y='451740.24' x='410.46' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.06' width='33.6'></rect><rect y='451740.24' x='377.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.06' width='33.6'></rect><rect y='451740.24' x='310.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.06' width='33.6'></rect><rect y='451740.24' x='276.84' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.06' width='33.6'></rect><rect y='451700.64' x='200.46' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451898.88' x='206.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451670.28' x='345.84' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451618.86' x='158.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='451618.86' x='374.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='451817.1' x='163.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='451817.1' x='235.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='451817.1' x='307.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='451817.1' x='379.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='451618.86' x='230.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='451618.86' x='302.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.06'></rect><path style='stroke:black' d='M373.860000,451611.360000 L373.860000,451615.440000 L374.339980,451615.440000 L374.339980,451611.360000 '></path><path style='stroke:black' d='M318.120000,451618.560000 L318.120000,451636.500000 L318.600010,451636.500000 L318.600010,451618.560000 '></path><path style='stroke:black' d='M157.980000,451618.620000 L157.980000,451636.860000 L158.460000,451636.860000 L158.460000,451618.620000 '></path><path style='stroke:black' d='M229.980000,451618.620000 L229.980000,451636.860000 L230.460010,451636.860000 L230.460010,451618.620000 '></path><path style='stroke:black' d='M301.980000,451618.620000 L301.980000,451636.860000 L302.459980,451636.860000 L302.459980,451618.620000 '></path><path style='stroke:black' d='M301.980000,451618.620000 L301.980000,451636.320000 L302.459980,451636.320000 L302.459980,451618.620000 '></path><path style='stroke:black' d='M374.040000,451618.620000 L374.040000,451636.860000 L374.519980,451636.860000 L374.519980,451618.620000 '></path><path style='stroke:black' d='M158.220000,451618.620020 L158.220000,451619.100000 L230.460000,451619.100000 L230.460000,451618.620020 '></path><path style='stroke:black' d='M230.220000,451618.620020 L230.220000,451619.100000 L302.460000,451619.100000 L302.460000,451618.620020 '></path><path style='stroke:black' d='M302.220000,451618.620020 L302.220000,451619.100000 L374.520000,451619.100000 L374.520000,451618.620020 '></path><path style='stroke:black' d='M302.220000,451618.620020 L302.220000,451619.100000 L373.920000,451619.100000 L373.920000,451618.620020 '></path><path style='stroke:black' d='M374.280000,451618.620020 L374.280000,451619.100000 L446.520000,451619.100000 L446.520000,451618.620020 '></path><path style='stroke:black' d='M229.980000,451618.860000 L229.980000,451637.100000 L230.460010,451637.100000 L230.460010,451618.860000 '></path><path style='stroke:black' d='M301.980000,451618.860000 L301.980000,451637.100000 L302.459980,451637.100000 L302.459980,451618.860000 '></path><path style='stroke:black' d='M373.440000,451618.860000 L373.440000,451636.560000 L373.920010,451636.560000 L373.920010,451618.860000 '></path><path style='stroke:black' d='M374.040000,451618.860000 L374.040000,451637.100000 L374.519980,451637.100000 L374.519980,451618.860000 '></path><path style='stroke:black' d='M446.040000,451618.860000 L446.040000,451637.100000 L446.519980,451637.100000 L446.519980,451618.860000 '></path><path style='stroke:black' d='M354.600000,451618.920000 L354.600000,451636.860000 L355.079980,451636.860000 L355.079980,451618.920000 '></path><path style='stroke:black' d='M336.720000,451618.980000 L336.720000,451636.920000 L337.200010,451636.920000 L337.200010,451618.980000 '></path><path style='stroke:black' d='M301.980000,451636.079960 L301.980000,451636.560000 L373.680000,451636.560000 L373.680000,451636.079960 '></path><path style='stroke:black' d='M157.980000,451636.620020 L157.980000,451637.100000 L230.220000,451637.100000 L230.220000,451636.620020 '></path><path style='stroke:black' d='M229.980000,451636.620020 L229.980000,451637.100000 L302.220000,451637.100000 L302.220000,451636.620020 '></path><path style='stroke:black' d='M301.980000,451636.620020 L301.980000,451637.100000 L374.280000,451637.100000 L374.280000,451636.620020 '></path><path style='stroke:black' d='M374.040000,451636.620020 L374.040000,451637.100000 L446.280000,451637.100000 L446.280000,451636.620020 '></path><path style='stroke:black' d='M317.220000,451640.040000 L317.400000,451639.920000 L317.160000,451639.500000 L316.980000,451639.620000 '></path><path style='stroke:black' d='M325.020000,451640.040000 L325.200000,451639.920000 L324.960000,451639.500000 L324.780000,451639.620000 '></path><path style='stroke:black' d='M340.080000,451639.620000 L339.900000,451639.500000 L339.600000,451639.860000 L339.780000,451639.980000 '></path><path style='stroke:black' d='M317.220000,451640.040000 L316.980000,451639.620000 L214.200000,451694.340000 L214.440000,451694.760000 '></path><path style='stroke:black' d='M325.020000,451640.040000 L324.780000,451639.620000 L237.840000,451690.800000 L238.080000,451691.220000 '></path><path style='stroke:black' d='M340.080000,451639.620000 L339.780000,451639.980000 L370.320000,451665.060000 L370.620000,451664.700000 '></path><path style='stroke:black' d='M334.500000,451640.400000 L334.620000,451640.220000 L334.260000,451639.920000 L334.140000,451640.100000 '></path><path style='stroke:black' d='M384.720000,451651.380000 L384.600000,451650.300000 L384.300000,451649.160000 L384.360000,451649.220000 L383.880000,451648.140000 L383.220000,451647.120000 L383.220000,451647.180000 L382.380000,451646.220000 L382.440000,451646.220000 L381.420000,451645.320000 L380.280000,451644.480000 L380.280000,451644.540000 L379.020000,451643.760000 L377.640000,451643.040000 L377.700000,451643.040000 L376.140000,451642.380000 L374.520000,451641.840000 L372.780000,451641.360000 L370.980000,451641.000000 L371.040000,451641.000000 L369.120000,451640.700000 L367.140000,451640.520000 L365.160000,451640.460000 L363.120000,451640.520000 L363.180000,451640.520000 L361.200000,451640.700000 L359.340000,451641.000000 L357.480000,451641.360000 L355.740000,451641.840000 L355.800000,451641.840000 L354.180000,451642.380000 L352.680000,451643.040000 L351.240000,451643.760000 L349.980000,451644.540000 L350.040000,451644.480000 L348.900000,451645.320000 L347.880000,451646.220000 L347.100000,451647.180000 L347.160000,451647.120000 L346.500000,451648.140000 L345.960000,451649.220000 L345.960000,451649.160000 L345.660000,451650.300000 L345.660000,451650.240000 L345.600000,451651.320000 L345.660000,451652.460000 L345.660000,451652.400000 L345.960000,451653.540000 L345.960000,451653.480000 L346.500000,451654.500000 L347.160000,451655.520000 L347.100000,451655.520000 L347.940000,451656.540000 L347.940000,451656.480000 L348.900000,451657.380000 L350.040000,451658.220000 L349.980000,451658.220000 L351.240000,451659.000000 L352.680000,451659.720000 L352.500000,451660.140000 L352.440000,451660.140000 L351.000000,451659.420000 L349.740000,451658.640000 L349.740000,451658.580000 L348.600000,451657.740000 L347.640000,451656.840000 L347.580000,451656.840000 L346.740000,451655.820000 L346.740000,451655.760000 L346.080000,451654.740000 L345.540000,451653.720000 L345.480000,451653.660000 L345.180000,451652.520000 L345.180000,451652.460000 L345.120000,451651.320000 L345.180000,451650.240000 L345.180000,451650.180000 L345.946000,451646.539000 L349.222000,451644.071000 L352.440000,451642.620000 L352.500000,451642.620000 L354.000000,451641.960000 L354.000000,451641.900000 L355.620000,451641.360000 L357.360000,451640.880000 L359.220000,451640.520000 L359.280000,451640.520000 L361.140000,451640.220000 L363.120000,451640.040000 L365.160000,451639.980000 L367.140000,451640.040000 L369.562000,451640.180000 L372.319000,451640.638000 L374.640000,451641.360000 L374.700000,451641.360000 L376.320000,451641.900000 L376.320000,451641.960000 L377.880000,451642.620000 L380.014000,451643.685000 L382.154000,451644.934000 L383.580000,451646.880000 L383.640000,451646.880000 L384.300000,451647.900000 L384.300000,451647.960000 L384.780000,451649.040000 L385.080000,451650.180000 L385.080000,451650.240000 L385.200000,451651.320000 '></path><path style='stroke:black' d='M334.500000,451640.400000 L334.140000,451640.100000 L300.780000,451680.960000 L301.140000,451681.260000 '></path><path style='stroke:black' d='M328.080000,451640.640000 L328.260000,451640.520000 L327.960000,451640.100000 L327.780000,451640.220000 '></path><path style='stroke:black' d='M331.680000,451640.580000 L331.860000,451640.460000 L331.560000,451640.100000 L331.380000,451640.220000 '></path><path style='stroke:black' d='M328.080000,451640.640000 L327.780000,451640.220000 L260.100000,451687.080000 L260.400000,451687.500000 '></path><path style='stroke:black' d='M331.680000,451640.580000 L331.380000,451640.220000 L282.780000,451681.440000 L283.080000,451681.800000 '></path><path style='stroke:black' d='M337.320000,451641.300000 L337.380000,451641.120000 L336.960000,451640.940000 L336.900000,451641.120000 '></path><path style='stroke:black' d='M337.320000,451641.300000 L336.900000,451641.120000 L321.600000,451675.620000 L322.020000,451675.800000 '></path><path style='stroke:black' d='M339.060000,451641.360010 L339.060000,451641.600000 L339.540010,451641.600000 L339.540010,451641.360010 '></path><path style='stroke:black' d='M339.540000,451641.600000 L339.060000,451641.600000 L340.500000,451673.760000 L340.980000,451673.760000 '></path><path style='stroke:black' d='M352.680000,451659.720000 L354.180000,451660.380000 L354.180000,451660.320000 L355.800000,451660.860000 L355.740000,451660.860000 L357.480000,451661.340000 L359.340000,451661.700000 L361.200000,451662.000000 L363.180000,451662.180000 L363.120000,451662.180000 L367.140000,451662.180000 L369.120000,451662.000000 L371.040000,451661.700000 L370.980000,451661.700000 L372.780000,451661.340000 L374.520000,451660.860000 L376.140000,451660.320000 L376.140000,451660.380000 L377.700000,451659.720000 L377.640000,451659.720000 L379.020000,451659.000000 L380.280000,451658.220000 L381.420000,451657.380000 L382.440000,451656.480000 L382.380000,451656.540000 L383.220000,451655.520000 L383.880000,451654.500000 L383.880000,451654.560000 L384.360000,451653.540000 L384.300000,451653.540000 L384.600000,451652.400000 L384.600000,451652.460000 L384.720000,451651.320000 L384.720000,451651.380000 L385.200000,451651.320000 L385.200000,451651.380000 L384.094000,451663.174000 L362.289000,451664.573000 L354.000000,451660.800000 L352.500000,451660.140000 '></path><path style='stroke:black' d='M406.260000,451661.160000 L406.260000,451665.840000 L406.740010,451665.840000 L406.740010,451661.160000 '></path><path style='stroke:black' d='M370.860000,451665.480000 L371.460000,451663.620000 L371.760000,451662.600000 L372.360000,451663.560000 L376.140000,451669.020000 L377.160000,451670.460000 L375.540000,451669.740000 L369.480000,451667.100000 L368.520000,451666.680000 L369.420000,451666.200000 L369.900000,451666.200000 L375.960000,451668.840000 L375.540000,451669.740000 L375.300000,451669.560000 L371.520000,451664.100000 L372.360000,451663.560000 L372.420000,451663.980000 L371.820000,451665.840000 '></path><path style='stroke:black' d='M371.340000,451665.660000 L371.940000,451663.800000 L375.720000,451669.260000 L369.660000,451666.620000 '></path><path style='stroke:black' d='M370.620000,451664.700000 L370.260000,451665.060000 L371.160000,451665.840000 L371.520000,451665.480000 '></path><path style='stroke:black' d='M370.620000,451664.700000 L370.800000,451664.820000 L370.500000,451665.180000 L370.320000,451665.060000 '></path><path style='stroke:black' d='M369.420000,451666.200000 L371.100000,451665.240000 L371.820000,451665.840000 L371.760000,451666.020000 L371.580000,451666.080000 L369.900000,451667.040000 '></path><path style='stroke:black' d='M379.920000,451688.940000 L379.560000,451689.240000 L417.960000,451731.960000 L418.320000,451731.660000 '></path><path style='stroke:black' d='M369.420000,451693.380000 L368.940000,451693.560000 L382.260000,451729.620000 L382.740000,451729.440000 '></path><path style='stroke:black' d='M348.000000,451697.220000 L347.520000,451697.400000 L358.500000,451730.100000 L358.980000,451729.920000 '></path><path style='stroke:black' d='M409.080000,451712.340000 L409.020000,451711.320000 L409.020000,451711.380000 L408.780000,451710.420000 L408.480000,451709.460000 L408.540000,451709.520000 L408.000000,451708.620000 L408.000000,451708.680000 L407.400000,451707.840000 L406.680000,451707.000000 L405.900000,451706.220000 L405.960000,451706.220000 L405.000000,451705.500000 L405.000000,451705.560000 L403.980000,451704.960000 L402.900000,451704.360000 L402.960000,451704.360000 L401.760000,451703.880000 L400.500000,451703.460000 L399.180000,451703.160000 L399.240000,451703.160000 L397.860000,451702.920000 L396.420000,451702.740000 L394.920000,451702.680000 L393.480000,451702.740000 L393.540000,451702.740000 L392.100000,451702.920000 L390.720000,451703.160000 L389.400000,451703.460000 L389.460000,451703.460000 L388.200000,451703.880000 L387.000000,451704.360000 L385.920000,451704.960000 L384.900000,451705.560000 L384.960000,451705.500000 L384.000000,451706.220000 L383.160000,451707.000000 L382.440000,451707.840000 L382.500000,451707.840000 L381.900000,451708.680000 L381.900000,451708.620000 L381.420000,451709.520000 L381.060000,451710.480000 L381.060000,451710.420000 L380.880000,451711.380000 L380.760000,451712.400000 L380.760000,451712.340000 L380.880000,451713.360000 L381.060000,451714.320000 L381.060000,451714.260000 L381.420000,451715.220000 L381.420000,451715.160000 L381.900000,451716.060000 L382.500000,451716.960000 L382.440000,451716.960000 L383.160000,451717.740000 L383.160000,451717.680000 L384.000000,451718.460000 L384.960000,451719.180000 L384.900000,451719.180000 L385.920000,451719.780000 L385.680000,451720.200000 L384.660000,451719.600000 L384.660000,451719.540000 L383.700000,451718.820000 L381.718000,451717.295000 L380.345000,451714.890000 L380.280000,451712.340000 L380.400000,451711.320000 L380.580000,451710.360000 L380.640000,451710.300000 L381.000000,451709.340000 L381.000000,451709.280000 L381.480000,451708.380000 L382.080000,451707.540000 L382.800000,451706.700000 L382.860000,451706.640000 L383.700000,451705.860000 L384.660000,451705.140000 L385.680000,451704.540000 L386.760000,451703.940000 L386.820000,451703.940000 L388.020000,451703.460000 L388.020000,451703.400000 L389.280000,451702.980000 L390.600000,451702.680000 L390.660000,451702.680000 L392.040000,451702.440000 L393.480000,451702.260000 L394.920000,451702.200000 L396.420000,451702.260000 L396.480000,451702.260000 L397.920000,451702.440000 L399.300000,451702.680000 L400.620000,451702.980000 L400.680000,451702.980000 L401.940000,451703.400000 L401.940000,451703.460000 L403.140000,451703.940000 L405.363000,451705.168000 L406.190000,451705.480000 L407.760000,451707.540000 L407.820000,451707.540000 L408.420000,451708.380000 L408.960000,451709.280000 L408.960000,451709.340000 L409.260000,451710.300000 L409.500000,451711.260000 L409.500000,451711.320000 L409.560000,451712.340000 '></path><path style='stroke:black' d='M328.380000,451702.860000 L327.900000,451702.860000 L328.200000,451728.960000 L328.680000,451728.960000 '></path><path style='stroke:black' d='M311.220000,451707.360000 L310.800000,451707.180000 L300.120000,451730.280000 L300.540000,451730.460000 '></path><path style='stroke:black' d='M294.540000,451711.260000 L294.180000,451710.900000 L273.360000,451730.820000 L273.720000,451731.180000 '></path><path style='stroke:black' d='M385.920000,451719.780000 L387.000000,451720.380000 L388.200000,451720.860000 L388.200000,451720.800000 L389.460000,451721.220000 L389.400000,451721.220000 L390.720000,451721.580000 L392.100000,451721.820000 L393.540000,451721.940000 L393.480000,451721.940000 L394.920000,451722.000000 L396.420000,451721.940000 L397.860000,451721.820000 L399.240000,451721.580000 L399.180000,451721.580000 L400.500000,451721.220000 L401.760000,451720.800000 L401.760000,451720.860000 L402.960000,451720.380000 L402.900000,451720.380000 L403.980000,451719.780000 L405.000000,451719.180000 L405.960000,451718.460000 L405.900000,451718.460000 L406.680000,451717.680000 L406.680000,451717.740000 L407.400000,451716.960000 L408.000000,451716.060000 L408.540000,451715.160000 L408.480000,451715.220000 L408.780000,451714.260000 L409.020000,451713.300000 L409.020000,451713.360000 L409.080000,451712.340000 L409.560000,451712.340000 L409.500000,451713.360000 L409.500000,451713.420000 L409.021000,451716.829000 L406.093000,451719.383000 L403.140000,451720.800000 L401.940000,451721.280000 L400.680000,451721.700000 L400.620000,451721.700000 L399.300000,451722.060000 L397.920000,451722.300000 L396.480000,451722.420000 L396.420000,451722.420000 L394.920000,451722.480000 L393.480000,451722.420000 L391.509000,451722.344000 L389.863000,451721.953000 L388.020000,451721.280000 L386.820000,451720.800000 L386.760000,451720.800000 L385.680000,451720.200000 '></path><path style='stroke:black' d='M274.860000,451715.100000 L274.620000,451714.680000 L244.500000,451733.460000 L244.740000,451733.880000 '></path><path style='stroke:black' d='M250.500000,451720.080000 L250.740000,451720.020000 L250.560000,451719.540000 L250.320000,451719.600000 '></path><path style='stroke:black' d='M250.500000,451720.080000 L250.320000,451719.600000 L206.940000,451735.560000 L207.120000,451736.040000 '></path><path style='stroke:black' d='M382.560000,451730.220000 L384.000000,451728.960000 L384.780000,451728.240000 L384.900000,451729.320000 L385.380000,451735.920000 L385.500000,451737.660000 L384.480000,451736.280000 L380.580000,451730.940000 L379.920000,451730.040000 L380.940000,451730.040000 L381.360000,451730.280000 L385.260000,451735.620000 L384.480000,451736.280000 L384.360000,451735.980000 L383.880000,451729.380000 L384.900000,451729.320000 L384.720000,451729.680000 L383.280000,451730.940000 '></path><path style='stroke:black' d='M328.260000,451729.620000 L330.060000,451728.960000 L331.020000,451728.540000 L330.720000,451729.620000 L328.980000,451735.980000 L328.500000,451737.600000 L328.020000,451735.980000 L326.100000,451729.620000 L325.800000,451728.600000 L326.760000,451728.960000 L327.060000,451729.320000 L328.980000,451735.680000 L328.020000,451735.980000 L328.020000,451735.680000 L329.760000,451729.320000 L330.720000,451729.620000 L330.420000,451729.920000 L328.620000,451730.580000 '></path><path style='stroke:black' d='M358.800000,451730.700000 L360.300000,451729.440000 L361.080000,451728.840000 L361.140000,451729.860000 L361.440000,451736.460000 L361.500000,451738.200000 L360.480000,451736.760000 L356.760000,451731.360000 L356.160000,451730.520000 L357.180000,451730.520000 L357.600000,451730.820000 L361.320000,451736.220000 L360.480000,451736.760000 L360.420000,451736.520000 L360.120000,451729.920000 L361.140000,451729.860000 L360.900000,451730.280000 L359.400000,451731.540000 '></path><path style='stroke:black' d='M272.940000,451731.360000 L274.680000,451732.200000 L275.580000,451732.680000 L274.620000,451733.160000 L268.800000,451736.220000 L267.300000,451737.000000 L268.140000,451735.500000 L271.440000,451729.800000 L271.980000,451728.900000 L272.400000,451729.860000 L272.340000,451730.280000 L269.040000,451735.980000 L268.140000,451735.500000 L268.380000,451735.320000 L274.200000,451732.260000 L274.620000,451733.160000 L274.200000,451733.160000 L272.460000,451732.320000 '></path><path style='stroke:black' d='M299.880000,451730.880000 L301.800000,451731.000000 L302.820000,451731.060000 L302.100000,451731.900000 L297.840000,451736.880000 L296.700000,451738.140000 L296.940000,451736.460000 L297.900000,451729.980000 L298.080000,451728.960000 L298.800000,451729.680000 L298.920000,451730.160000 L297.960000,451736.640000 L296.940000,451736.460000 L297.120000,451736.220000 L301.380000,451731.240000 L302.100000,451731.900000 L301.680000,451732.080000 L299.760000,451731.960000 '></path><path style='stroke:black' d='M326.760000,451728.960000 L328.620000,451729.620000 L328.620000,451730.580000 L328.440000,451730.640000 L328.260000,451730.580000 L326.400000,451729.920000 '></path><path style='stroke:black' d='M328.200000,451728.960000 L328.200000,451730.100000 L328.679980,451730.100000 L328.679980,451728.960000 '></path><path style='stroke:black' d='M328.200000,451728.960010 L328.200000,451729.200000 L328.679980,451729.200000 L328.679980,451728.960010 '></path><path style='stroke:black' d='M382.920000,451730.580000 L384.360000,451729.320000 L384.840000,451735.920000 L380.940000,451730.580000 '></path><path style='stroke:black' d='M328.440000,451730.100000 L330.240000,451729.440000 L328.500000,451735.800000 L326.580000,451729.440000 '></path><path style='stroke:black' d='M382.740000,451729.440000 L382.260000,451729.560000 L382.680000,451730.640000 L383.160000,451730.520000 '></path><path style='stroke:black' d='M382.740000,451729.440000 L382.800000,451729.680000 L382.320000,451729.860000 L382.260000,451729.620000 '></path><path style='stroke:black' d='M298.800000,451729.680000 L300.180000,451731.060000 L299.760000,451731.960000 L299.580000,451731.900000 L298.080000,451730.400000 '></path><path style='stroke:black' d='M418.440000,451732.380000 L419.340000,451730.700000 L419.820000,451729.740000 L420.300000,451730.760000 L423.180000,451736.640000 L423.960000,451738.200000 L422.460000,451737.300000 L416.880000,451733.820000 L415.980000,451733.220000 L416.940000,451732.860000 L417.420000,451732.920000 L423.000000,451736.400000 L422.460000,451737.300000 L422.280000,451737.060000 L419.400000,451731.180000 L420.300000,451730.760000 L420.300000,451731.180000 L419.400000,451732.860000 '></path><path style='stroke:black' d='M272.400000,451729.860000 L273.180000,451731.660000 L272.460000,451732.320000 L272.340000,451732.200000 L272.220000,451732.020000 L271.440000,451730.220000 '></path><path style='stroke:black' d='M359.100000,451731.120000 L360.600000,451729.860000 L360.900000,451736.460000 L357.180000,451731.060000 '></path><path style='stroke:black' d='M358.980000,451729.920000 L358.500000,451730.040000 L358.860000,451731.180000 L359.340000,451731.060000 '></path><path style='stroke:black' d='M358.980000,451729.920000 L359.040000,451730.160000 L358.560000,451730.340000 L358.500000,451730.100000 '></path><path style='stroke:black' d='M272.700000,451731.840000 L274.440000,451732.680000 L268.620000,451735.740000 L271.920000,451730.040000 '></path><path style='stroke:black' d='M299.820000,451731.420000 L301.740000,451731.540000 L297.480000,451736.520000 L298.440000,451730.040000 '></path><path style='stroke:black' d='M380.940000,451730.040000 L382.920000,451730.040000 L383.280000,451730.940000 L383.100000,451731.060000 L382.920000,451731.120000 L380.940000,451731.120000 '></path><path style='stroke:black' d='M300.540000,451730.460000 L300.060000,451730.220000 L299.580000,451731.300000 L300.060000,451731.540000 '></path><path style='stroke:black' d='M300.540000,451730.460000 L300.480000,451730.640000 L300.060000,451730.460000 L300.120000,451730.280000 '></path><path style='stroke:black' d='M357.180000,451730.520000 L359.100000,451730.580000 L359.400000,451731.540000 L359.280000,451731.660000 L359.100000,451731.660000 L357.180000,451731.600000 '></path><path style='stroke:black' d='M273.720000,451731.180000 L273.360000,451730.820000 L272.520000,451731.660000 L272.880000,451732.020000 '></path><path style='stroke:black' d='M273.720000,451731.180000 L273.540000,451731.360000 L273.180000,451731.000000 L273.360000,451730.820000 '></path><path style='stroke:black' d='M418.920000,451732.620000 L419.820000,451730.940000 L422.700000,451736.820000 L417.120000,451733.340000 '></path><path style='stroke:black' d='M243.960000,451733.820000 L245.460000,451735.020000 L246.300000,451735.680000 L245.280000,451735.920000 L238.980000,451737.720000 L237.360000,451738.200000 L238.440000,451736.940000 L242.820000,451732.020000 L243.540000,451731.240000 L243.720000,451732.200000 L243.600000,451732.680000 L239.220000,451737.600000 L238.440000,451736.940000 L238.680000,451736.760000 L244.980000,451734.960000 L245.280000,451735.920000 L244.860000,451735.860000 L243.360000,451734.660000 '></path><path style='stroke:black' d='M418.320000,451731.600000 L417.960000,451731.960000 L418.740000,451732.800000 L419.100000,451732.440000 '></path><path style='stroke:black' d='M418.320000,451731.660000 L418.440000,451731.840000 L418.080000,451732.140000 L417.960000,451731.960000 '></path><path style='stroke:black' d='M416.940000,451732.860000 L418.740000,451732.140000 L419.400000,451732.860000 L419.280000,451733.040000 L419.100000,451733.100000 L417.300000,451733.820000 '></path><path style='stroke:black' d='M243.720000,451732.200000 L244.140000,451734.120000 L243.360000,451734.660000 L243.180000,451734.540000 L243.180000,451734.360000 L242.760000,451732.440000 '></path><path style='stroke:black' d='M243.660000,451734.240000 L245.160000,451735.440000 L238.860000,451737.240000 L243.240000,451732.320000 '></path><path style='stroke:black' d='M206.280000,451735.860000 L207.540000,451737.300000 L208.260000,451738.080000 L207.180000,451738.200000 L200.580000,451738.680000 L198.780000,451738.800000 L200.220000,451737.780000 L205.560000,451733.940000 L206.460000,451733.280000 L206.460000,451734.300000 L206.220000,451734.720000 L200.880000,451738.560000 L200.220000,451737.780000 L200.520000,451737.660000 L207.120000,451737.180000 L207.180000,451738.200000 L206.820000,451738.020000 L205.560000,451736.580000 '></path><path style='stroke:black' d='M244.740000,451733.820000 L244.500000,451733.460000 L243.540000,451734.060000 L243.780000,451734.420000 '></path><path style='stroke:black' d='M244.740000,451733.880000 L244.560000,451734.000000 L244.320000,451733.580000 L244.500000,451733.460000 '></path><path style='stroke:black' d='M205.920000,451736.220000 L207.180000,451737.660000 L200.580000,451738.140000 L205.920000,451734.300000 '></path><path style='stroke:black' d='M206.460000,451734.300000 L206.460000,451736.220000 L205.560000,451736.580000 L205.440000,451736.400000 L205.380000,451736.220000 L205.380000,451734.300000 '></path><path style='stroke:black' d='M207.060000,451736.040000 L206.940000,451735.560000 L205.860000,451735.980000 L205.980000,451736.460000 '></path><path style='stroke:black' d='M207.120000,451736.040000 L206.880000,451736.100000 L206.700000,451735.620000 L206.940000,451735.560000 '></path><path style='stroke:black' d='M176.640000,451739.999990 L176.640000,451740.480000 L210.480000,451740.480000 L210.480000,451739.999990 '></path><path style='stroke:black' d='M210.060000,451739.999990 L210.060000,451740.480000 L243.900000,451740.480000 L243.900000,451739.999990 '></path><path style='stroke:black' d='M243.420000,451739.999990 L243.420000,451740.480000 L277.260000,451740.480000 L277.260000,451739.999990 '></path><path style='stroke:black' d='M276.840000,451739.999990 L276.840000,451740.480000 L310.680000,451740.480000 L310.680000,451739.999990 '></path><path style='stroke:black' d='M310.260000,451739.999990 L310.260000,451740.480000 L344.100000,451740.480000 L344.100000,451739.999990 '></path><path style='stroke:black' d='M343.680000,451739.999990 L343.680000,451740.480000 L377.520000,451740.480000 L377.520000,451739.999990 '></path><path style='stroke:black' d='M377.040000,451739.999990 L377.040000,451740.480000 L410.880000,451740.480000 L410.880000,451739.999990 '></path><path style='stroke:black' d='M410.460000,451739.999990 L410.460000,451740.480000 L444.300000,451740.480000 L444.300000,451739.999990 '></path><path style='stroke:black' d='M176.400000,451740.000000 L176.400000,451758.300000 L176.880000,451758.300000 L176.880000,451740.000000 '></path><path style='stroke:black' d='M209.820000,451740.000000 L209.820000,451758.300000 L210.300010,451758.300000 L210.300010,451740.000000 '></path><path style='stroke:black' d='M243.180000,451740.000000 L243.180000,451758.300000 L243.660010,451758.300000 L243.660010,451740.000000 '></path><path style='stroke:black' d='M276.600000,451740.000000 L276.600000,451758.300000 L277.079980,451758.300000 L277.079980,451740.000000 '></path><path style='stroke:black' d='M310.020000,451740.000000 L310.020000,451758.300000 L310.500010,451758.300000 L310.500010,451740.000000 '></path><path style='stroke:black' d='M343.440000,451740.000000 L343.440000,451758.300000 L343.920010,451758.300000 L343.920010,451740.000000 '></path><path style='stroke:black' d='M376.800000,451740.000000 L376.800000,451758.300000 L377.279980,451758.300000 L377.279980,451740.000000 '></path><path style='stroke:black' d='M410.220000,451740.000000 L410.220000,451758.300000 L410.700010,451758.300000 L410.700010,451740.000000 '></path><path style='stroke:black' d='M210.000000,451740.240000 L210.000000,451758.540000 L210.480000,451758.540000 L210.480000,451740.240000 '></path><path style='stroke:black' d='M243.420000,451740.240000 L243.420000,451758.540000 L243.900000,451758.540000 L243.900000,451740.240000 '></path><path style='stroke:black' d='M276.780000,451740.240000 L276.780000,451758.540000 L277.260010,451758.540000 L277.260010,451740.240000 '></path><path style='stroke:black' d='M310.200000,451740.240000 L310.200000,451758.540000 L310.679980,451758.540000 L310.679980,451740.240000 '></path><path style='stroke:black' d='M343.620000,451740.240000 L343.620000,451758.540000 L344.100010,451758.540000 L344.100010,451740.240000 '></path><path style='stroke:black' d='M343.680000,451740.240000 L377.280000,451740.240000 L377.280000,451758.300000 L343.680000,451758.300000 '></path><path style='stroke:black' d='M377.040000,451740.240000 L377.040000,451758.540000 L377.519980,451758.540000 L377.519980,451740.240000 '></path><path style='stroke:black' d='M410.400000,451740.240000 L410.400000,451758.540000 L410.880010,451758.540000 L410.880010,451740.240000 '></path><path style='stroke:black' d='M443.820000,451740.240000 L443.820000,451758.540000 L444.300010,451758.540000 L444.300010,451740.240000 '></path><path style='stroke:black' d='M176.400000,451758.059990 L176.400000,451758.540000 L210.240000,451758.540000 L210.240000,451758.059990 '></path><path style='stroke:black' d='M209.820000,451758.059990 L209.820000,451758.540000 L243.660000,451758.540000 L243.660000,451758.059990 '></path><path style='stroke:black' d='M243.180000,451758.059990 L243.180000,451758.540000 L277.020000,451758.540000 L277.020000,451758.059990 '></path><path style='stroke:black' d='M276.600000,451758.059990 L276.600000,451758.540000 L310.440000,451758.540000 L310.440000,451758.059990 '></path><path style='stroke:black' d='M310.020000,451758.059990 L310.020000,451758.540000 L343.860000,451758.540000 L343.860000,451758.059990 '></path><path style='stroke:black' d='M343.440000,451758.059990 L343.440000,451758.540000 L377.280000,451758.540000 L377.280000,451758.059990 '></path><path style='stroke:black' d='M376.800000,451758.059990 L376.800000,451758.540000 L410.640000,451758.540000 L410.640000,451758.059990 '></path><path style='stroke:black' d='M410.220000,451758.059990 L410.220000,451758.540000 L444.060000,451758.540000 L444.060000,451758.059990 '></path><path style='stroke:black' d='M379.440000,451809.540010 L379.440000,451809.780000 L379.920010,451809.780000 L379.920010,451809.540010 '></path><path style='stroke:black' d='M379.440000,451809.780000 L379.440000,451813.620000 L379.920010,451813.620000 L379.920010,451809.780000 '></path><path style='stroke:black' d='M323.700000,451816.740000 L323.700000,451834.680000 L324.179980,451834.680000 L324.179980,451816.740000 '></path><path style='stroke:black' d='M163.620000,451816.860000 L163.620000,451835.100000 L164.100000,451835.100000 L164.100000,451816.860000 '></path><path style='stroke:black' d='M235.620000,451816.860000 L235.620000,451835.100000 L236.100000,451835.100000 L236.100000,451816.860000 '></path><path style='stroke:black' d='M307.620000,451816.860000 L307.620000,451835.100000 L308.100010,451835.100000 L308.100010,451816.860000 '></path><path style='stroke:black' d='M307.620000,451816.860000 L307.620000,451834.500000 L308.100010,451834.500000 L308.100010,451816.860000 '></path><path style='stroke:black' d='M379.620000,451816.860000 L379.620000,451835.100000 L380.100010,451835.100000 L380.100010,451816.860000 '></path><path style='stroke:black' d='M163.860000,451816.860020 L163.860000,451817.340000 L236.100000,451817.340000 L236.100000,451816.860020 '></path><path style='stroke:black' d='M235.860000,451816.860020 L235.860000,451817.340000 L308.100000,451817.340000 L308.100000,451816.860020 '></path><path style='stroke:black' d='M307.860000,451816.860020 L307.860000,451817.340000 L380.100000,451817.340000 L380.100000,451816.860020 '></path><path style='stroke:black' d='M307.860000,451816.860020 L307.860000,451817.340000 L379.500000,451817.340000 L379.500000,451816.860020 '></path><path style='stroke:black' d='M379.860000,451816.860020 L379.860000,451817.340000 L452.100000,451817.340000 L452.100000,451816.860020 '></path><path style='stroke:black' d='M235.620000,451817.100000 L235.620000,451835.340000 L236.100000,451835.340000 L236.100000,451817.100000 '></path><path style='stroke:black' d='M307.620000,451817.100000 L307.620000,451835.340000 L308.100010,451835.340000 L308.100010,451817.100000 '></path><path style='stroke:black' d='M360.240000,451817.100000 L360.240000,451835.040000 L360.720010,451835.040000 L360.720010,451817.100000 '></path><path style='stroke:black' d='M379.020000,451817.100000 L379.020000,451834.740000 L379.500010,451834.740000 L379.500010,451817.100000 '></path><path style='stroke:black' d='M379.620000,451817.100000 L379.620000,451835.340000 L380.100010,451835.340000 L380.100010,451817.100000 '></path><path style='stroke:black' d='M451.620000,451817.100000 L451.620000,451835.340000 L452.099980,451835.340000 L452.099980,451817.100000 '></path><path style='stroke:black' d='M342.300000,451817.220000 L342.300000,451835.160000 L342.779980,451835.160000 L342.779980,451817.220000 '></path><path style='stroke:black' d='M307.620000,451834.260020 L307.620000,451834.740000 L379.260000,451834.740000 L379.260000,451834.260020 '></path><path style='stroke:black' d='M163.620000,451834.860020 L163.620000,451835.340000 L235.860000,451835.340000 L235.860000,451834.860020 '></path><path style='stroke:black' d='M235.620000,451834.860020 L235.620000,451835.340000 L307.860000,451835.340000 L307.860000,451834.860020 '></path><path style='stroke:black' d='M307.620000,451834.860020 L307.620000,451835.340000 L379.860000,451835.340000 L379.860000,451834.860020 '></path><path style='stroke:black' d='M379.620000,451834.860020 L379.620000,451835.340000 L451.860000,451835.340000 L451.860000,451834.860020 '></path><path style='stroke:black' d='M390.300000,451849.620000 L390.180000,451848.480000 L389.880000,451847.400000 L389.940000,451847.460000 L389.460000,451846.380000 L388.800000,451845.360000 L388.800000,451845.420000 L387.960000,451844.460000 L387.000000,451843.500000 L387.060000,451843.500000 L385.920000,451842.660000 L385.920000,451842.720000 L384.600000,451841.940000 L383.220000,451841.220000 L383.280000,451841.220000 L381.780000,451840.560000 L380.100000,451840.020000 L378.360000,451839.540000 L376.560000,451839.180000 L376.620000,451839.180000 L374.760000,451838.940000 L372.780000,451838.760000 L370.740000,451838.700000 L368.700000,451838.760000 L368.760000,451838.760000 L366.840000,451838.940000 L364.920000,451839.180000 L363.120000,451839.540000 L361.380000,451840.020000 L361.440000,451840.020000 L359.820000,451840.560000 L358.260000,451841.220000 L356.880000,451841.940000 L355.560000,451842.720000 L355.620000,451842.660000 L354.480000,451843.500000 L353.520000,451844.460000 L352.680000,451845.420000 L352.740000,451845.360000 L352.080000,451846.380000 L351.600000,451847.460000 L351.600000,451847.400000 L351.300000,451848.480000 L351.180000,451849.620000 L351.180000,451849.560000 L351.300000,451850.700000 L351.300000,451850.640000 L351.600000,451851.720000 L352.080000,451852.800000 L352.080000,451852.740000 L352.740000,451853.760000 L352.680000,451853.760000 L353.520000,451854.720000 L353.520000,451854.660000 L354.480000,451855.560000 L355.620000,451856.460000 L355.560000,451856.460000 L356.880000,451857.240000 L358.260000,451857.960000 L358.080000,451858.380000 L358.020000,451858.380000 L356.640000,451857.660000 L355.320000,451856.880000 L355.320000,451856.820000 L354.180000,451855.920000 L353.220000,451855.020000 L353.160000,451855.020000 L352.320000,451854.060000 L352.320000,451854.000000 L351.660000,451852.980000 L351.180000,451851.900000 L351.120000,451851.840000 L350.820000,451850.760000 L350.700000,451849.620000 L350.700000,451849.560000 L350.820000,451848.420000 L350.820000,451848.360000 L351.120000,451847.280000 L351.180000,451847.280000 L351.660000,451846.200000 L351.660000,451846.140000 L352.320000,451845.120000 L353.160000,451844.160000 L353.160000,451844.100000 L354.120000,451843.140000 L354.180000,451843.140000 L355.320000,451842.300000 L356.640000,451841.520000 L358.020000,451840.800000 L358.080000,451840.800000 L359.640000,451840.140000 L359.640000,451840.080000 L361.260000,451839.540000 L369.386000,451836.969000 L383.598000,451837.844000 L389.160000,451845.120000 L389.220000,451845.120000 L389.880000,451846.140000 L389.880000,451846.200000 L390.360000,451847.280000 L390.660000,451848.360000 L390.660000,451848.420000 L390.780000,451849.560000 '></path><path style='stroke:black' d='M322.800000,451838.220000 L322.980000,451838.100000 L322.740000,451837.680000 L322.560000,451837.800000 '></path><path style='stroke:black' d='M330.600000,451838.220000 L330.780000,451838.100000 L330.540000,451837.680000 L330.360000,451837.800000 '></path><path style='stroke:black' d='M345.660000,451837.800000 L345.480000,451837.680000 L345.180000,451838.040000 L345.360000,451838.160000 '></path><path style='stroke:black' d='M322.800000,451838.220000 L322.560000,451837.800000 L219.780000,451892.580000 L220.020000,451893.000000 '></path><path style='stroke:black' d='M330.600000,451838.220000 L330.360000,451837.800000 L243.420000,451889.040000 L243.660000,451889.460000 '></path><path style='stroke:black' d='M345.660000,451837.800000 L345.360000,451838.160000 L375.900000,451863.300000 L376.200000,451862.940000 '></path><path style='stroke:black' d='M340.080000,451838.580000 L340.200000,451838.400000 L339.840000,451838.100000 L339.720000,451838.280000 '></path><path style='stroke:black' d='M340.080000,451838.580000 L339.720000,451838.280000 L306.360000,451879.200000 L306.720000,451879.500000 '></path><path style='stroke:black' d='M333.660000,451838.820000 L333.840000,451838.700000 L333.540000,451838.280000 L333.360000,451838.400000 '></path><path style='stroke:black' d='M337.260000,451838.760000 L337.440000,451838.640000 L337.140000,451838.280000 L336.960000,451838.400000 '></path><path style='stroke:black' d='M333.660000,451838.820000 L333.360000,451838.400000 L265.680000,451885.320000 L265.980000,451885.740000 '></path><path style='stroke:black' d='M337.260000,451838.760000 L336.960000,451838.400000 L288.360000,451879.620000 L288.660000,451879.980000 '></path><path style='stroke:black' d='M342.960000,451839.540000 L343.020000,451839.360000 L342.600000,451839.180000 L342.540000,451839.360000 '></path><path style='stroke:black' d='M342.960000,451839.540000 L342.540000,451839.360000 L327.240000,451873.800000 L327.660000,451873.980000 '></path><path style='stroke:black' d='M344.640000,451839.540010 L344.640000,451839.780000 L345.119980,451839.780000 L345.119980,451839.540010 '></path><path style='stroke:black' d='M345.120000,451839.780000 L344.640000,451839.780000 L346.080000,451871.940000 L346.560000,451871.940000 '></path><path style='stroke:black' d='M358.260000,451857.960000 L359.820000,451858.560000 L359.820000,451858.500000 L361.440000,451859.100000 L361.380000,451859.100000 L363.120000,451859.520000 L364.920000,451859.940000 L366.840000,451860.180000 L368.760000,451860.360000 L368.700000,451860.360000 L370.740000,451860.420000 L372.780000,451860.360000 L374.760000,451860.180000 L376.620000,451859.940000 L376.560000,451859.940000 L378.360000,451859.520000 L380.100000,451859.100000 L381.780000,451858.500000 L381.780000,451858.560000 L383.280000,451857.960000 L383.220000,451857.960000 L384.600000,451857.240000 L385.920000,451856.460000 L387.060000,451855.560000 L388.020000,451854.660000 L387.960000,451854.720000 L388.800000,451853.760000 L389.460000,451852.740000 L389.460000,451852.800000 L389.940000,451851.720000 L389.880000,451851.720000 L390.180000,451850.640000 L390.180000,451850.700000 L390.300000,451849.560000 L390.300000,451849.620000 L390.780000,451849.560000 L390.780000,451849.620000 L389.677000,451861.412000 L367.850000,451862.785000 L359.640000,451858.980000 L358.080000,451858.380000 '></path><path style='stroke:black' d='M411.840000,451859.340010 L411.840000,451859.580000 L412.320010,451859.580000 L412.320010,451859.340010 '></path><path style='stroke:black' d='M411.840000,451859.580000 L411.840000,451864.020000 L412.320010,451864.020000 L412.320010,451859.580000 '></path><path style='stroke:black' d='M376.440000,451863.660000 L377.100000,451861.860000 L377.400000,451860.900000 L378.000000,451861.800000 L381.720000,451867.200000 L382.740000,451868.640000 L381.120000,451867.920000 L375.060000,451865.280000 L374.100000,451864.860000 L375.000000,451864.380000 L375.480000,451864.380000 L381.540000,451867.020000 L381.120000,451867.920000 L380.880000,451867.740000 L377.160000,451862.340000 L378.000000,451861.800000 L378.060000,451862.220000 L377.400000,451864.020000 '></path><path style='stroke:black' d='M376.920000,451863.840000 L377.580000,451862.040000 L381.300000,451867.440000 L375.240000,451864.800000 '></path><path style='stroke:black' d='M376.200000,451862.940000 L375.840000,451863.300000 L376.740000,451864.020000 L377.100000,451863.660000 '></path><path style='stroke:black' d='M376.200000,451862.940000 L376.380000,451863.060000 L376.080000,451863.420000 L375.900000,451863.300000 '></path><path style='stroke:black' d='M375.000000,451864.380000 L376.680000,451863.420000 L377.400000,451864.020000 L377.340000,451864.200000 L377.160000,451864.260000 L375.480000,451865.220000 '></path><path style='stroke:black' d='M385.560000,451887.180000 L385.200000,451887.480000 L423.540000,451930.140000 L423.900000,451929.840000 '></path><path style='stroke:black' d='M375.000000,451891.620000 L374.520000,451891.800000 L387.840000,451927.800000 L388.320000,451927.620000 '></path><path style='stroke:black' d='M353.580000,451895.400000 L353.100000,451895.580000 L364.080000,451928.340000 L364.560000,451928.160000 '></path><path style='stroke:black' d='M414.720000,451910.640000 L414.600000,451909.620000 L414.420000,451908.600000 L414.480000,451908.660000 L414.120000,451907.760000 L413.640000,451906.800000 L413.640000,451906.860000 L413.040000,451906.020000 L412.320000,451905.180000 L412.380000,451905.180000 L411.540000,451904.460000 L410.580000,451903.740000 L410.580000,451903.800000 L409.560000,451903.140000 L408.480000,451902.600000 L408.540000,451902.600000 L407.340000,451902.120000 L406.080000,451901.700000 L404.760000,451901.340000 L404.820000,451901.340000 L403.440000,451901.100000 L402.000000,451900.920000 L399.060000,451900.920000 L399.120000,451900.920000 L397.680000,451901.100000 L396.300000,451901.340000 L394.980000,451901.700000 L395.040000,451901.700000 L393.780000,451902.120000 L392.640000,451902.600000 L391.500000,451903.140000 L390.480000,451903.800000 L390.540000,451903.740000 L389.580000,451904.460000 L388.800000,451905.180000 L388.080000,451906.020000 L388.140000,451906.020000 L387.540000,451906.860000 L387.540000,451906.800000 L387.000000,451907.760000 L386.700000,451908.660000 L386.700000,451908.600000 L386.460000,451909.620000 L386.460000,451909.560000 L386.400000,451910.580000 L386.460000,451911.540000 L386.460000,451911.480000 L386.700000,451912.500000 L387.000000,451913.460000 L387.000000,451913.400000 L387.540000,451914.300000 L388.140000,451915.140000 L388.080000,451915.140000 L388.800000,451915.980000 L388.800000,451915.920000 L389.580000,451916.700000 L390.540000,451917.360000 L390.480000,451917.360000 L391.500000,451918.020000 L391.320000,451918.440000 L391.260000,451918.440000 L383.508000,451913.963000 L384.422000,451905.720000 L392.460000,451902.180000 L393.600000,451901.700000 L393.600000,451901.640000 L394.860000,451901.220000 L396.180000,451900.860000 L396.240000,451900.860000 L397.620000,451900.620000 L399.060000,451900.440000 L402.060000,451900.440000 L403.500000,451900.620000 L404.880000,451900.860000 L406.200000,451901.220000 L406.260000,451901.220000 L407.520000,451901.640000 L407.520000,451901.700000 L408.720000,451902.180000 L410.296000,451902.899000 L412.426000,451904.271000 L413.400000,451905.720000 L413.460000,451905.720000 L414.060000,451906.560000 L414.537000,451907.503000 L415.031000,451908.476000 L415.080000,451909.560000 L415.200000,451910.580000 '></path><path style='stroke:black' d='M334.020000,451901.100000 L333.540000,451901.100000 L333.780000,451927.140000 L334.260000,451927.140000 '></path><path style='stroke:black' d='M316.800000,451905.600000 L316.380000,451905.420000 L305.760000,451928.460000 L306.180000,451928.640000 '></path><path style='stroke:black' d='M300.120000,451909.440000 L299.760000,451909.080000 L278.940000,451929.060000 L279.300000,451929.420000 '></path><path style='stroke:black' d='M391.500000,451918.020000 L393.780000,451919.100000 L393.780000,451919.040000 L395.040000,451919.460000 L394.980000,451919.460000 L396.300000,451919.760000 L397.680000,451920.000000 L399.120000,451920.180000 L399.060000,451920.180000 L400.560000,451920.240000 L402.000000,451920.180000 L403.440000,451920.000000 L404.820000,451919.760000 L404.760000,451919.760000 L406.080000,451919.460000 L407.340000,451919.040000 L407.340000,451919.100000 L408.540000,451918.560000 L408.480000,451918.560000 L409.560000,451918.020000 L410.580000,451917.360000 L411.540000,451916.700000 L412.380000,451915.920000 L412.320000,451915.980000 L413.040000,451915.140000 L413.640000,451914.300000 L414.120000,451913.400000 L414.120000,451913.460000 L414.480000,451912.500000 L414.420000,451912.560000 L414.600000,451911.540000 L414.720000,451910.580000 L414.720000,451910.640000 L415.200000,451910.580000 L415.200000,451910.640000 L415.080000,451911.600000 L414.900000,451912.620000 L414.900000,451912.680000 L414.540000,451913.640000 L414.060000,451914.540000 L414.060000,451914.600000 L413.460000,451915.440000 L413.400000,451915.440000 L412.680000,451916.280000 L411.840000,451917.060000 L411.840000,451917.120000 L410.880000,451917.780000 L410.820000,451917.780000 L408.659000,451919.298000 L406.109000,451920.161000 L403.500000,451920.480000 L402.060000,451920.660000 L402.000000,451920.660000 L399.495000,451920.894000 L396.000000,451920.405000 L393.600000,451919.520000 L391.320000,451918.440000 '></path><path style='stroke:black' d='M280.500000,451913.340000 L280.260000,451912.920000 L250.140000,451931.640000 L250.380000,451932.060000 '></path><path style='stroke:black' d='M256.080000,451918.320000 L256.320000,451918.260000 L256.140000,451917.780000 L255.900000,451917.840000 '></path><path style='stroke:black' d='M256.080000,451918.320000 L255.900000,451917.840000 L212.580000,451933.800000 L212.760000,451934.280000 '></path><path style='stroke:black' d='M388.140000,451928.400000 L389.640000,451927.140000 L390.420000,451926.420000 L390.540000,451927.500000 L391.020000,451934.100000 L391.140000,451935.840000 L390.120000,451934.460000 L386.220000,451929.120000 L385.560000,451928.220000 L386.580000,451928.220000 L387.000000,451928.460000 L390.900000,451933.800000 L390.120000,451934.460000 L390.000000,451934.160000 L389.520000,451927.560000 L390.540000,451927.500000 L390.360000,451927.860000 L388.860000,451929.120000 '></path><path style='stroke:black' d='M333.840000,451927.800000 L335.640000,451927.140000 L336.600000,451926.720000 L336.300000,451927.800000 L334.560000,451934.160000 L334.080000,451935.840000 L333.600000,451934.160000 L331.740000,451927.860000 L331.440000,451926.840000 L332.400000,451927.200000 L332.700000,451927.560000 L334.560000,451933.860000 L333.600000,451934.160000 L333.600000,451933.860000 L335.340000,451927.500000 L336.300000,451927.800000 L336.000000,451928.100000 L334.200000,451928.760000 '></path><path style='stroke:black' d='M278.520000,451929.540000 L280.260000,451930.380000 L281.160000,451930.860000 L280.200000,451931.340000 L274.380000,451934.400000 L272.880000,451935.180000 L273.720000,451933.680000 L277.020000,451927.980000 L277.560000,451927.080000 L277.980000,451928.040000 L277.920000,451928.460000 L274.620000,451934.160000 L273.720000,451933.680000 L273.960000,451933.500000 L279.780000,451930.440000 L280.200000,451931.340000 L279.780000,451931.340000 L278.040000,451930.500000 '></path><path style='stroke:black' d='M364.440000,451928.880000 L365.940000,451927.680000 L366.720000,451927.080000 L366.780000,451928.100000 L367.080000,451934.700000 L367.140000,451936.440000 L366.120000,451935.000000 L362.340000,451929.540000 L361.740000,451928.700000 L362.760000,451928.700000 L363.180000,451929.000000 L366.960000,451934.460000 L366.120000,451935.000000 L366.060000,451934.760000 L365.760000,451928.160000 L366.780000,451928.100000 L366.540000,451928.520000 L365.040000,451929.720000 '></path><path style='stroke:black' d='M305.520000,451929.060000 L307.440000,451929.240000 L308.460000,451929.360000 L307.740000,451930.140000 L303.420000,451935.120000 L302.280000,451936.440000 L302.520000,451934.700000 L303.540000,451928.160000 L303.720000,451927.140000 L304.440000,451927.860000 L304.560000,451928.340000 L303.540000,451934.880000 L302.520000,451934.700000 L302.700000,451934.460000 L307.020000,451929.480000 L307.740000,451930.140000 L307.320000,451930.320000 L305.400000,451930.140000 '></path><path style='stroke:black' d='M333.780000,451927.140000 L333.780000,451928.280000 L334.260010,451928.280000 L334.260010,451927.140000 '></path><path style='stroke:black' d='M333.780000,451927.140010 L333.780000,451927.380000 L334.260010,451927.380000 L334.260010,451927.140010 '></path><path style='stroke:black' d='M332.400000,451927.200000 L334.200000,451927.800000 L334.200000,451928.760000 L334.020000,451928.820000 L332.040000,451928.160000 '></path><path style='stroke:black' d='M388.500000,451928.760000 L390.000000,451927.500000 L390.480000,451934.100000 L386.580000,451928.760000 '></path><path style='stroke:black' d='M334.020000,451928.280000 L335.820000,451927.620000 L334.080000,451933.980000 L332.220000,451927.680000 '></path><path style='stroke:black' d='M388.320000,451927.620000 L387.840000,451927.740000 L388.260000,451928.820000 L388.740000,451928.700000 '></path><path style='stroke:black' d='M388.320000,451927.620000 L388.380000,451927.860000 L387.900000,451928.040000 L387.840000,451927.800000 '></path><path style='stroke:black' d='M304.440000,451927.860000 L305.820000,451929.240000 L305.400000,451930.140000 L305.220000,451930.080000 L303.720000,451928.580000 '></path><path style='stroke:black' d='M424.020000,451930.560000 L424.920000,451928.880000 L425.400000,451927.980000 L425.880000,451928.940000 L428.760000,451934.880000 L429.540000,451936.440000 L428.040000,451935.540000 L422.460000,451932.060000 L421.620000,451931.520000 L422.460000,451931.160000 L423.000000,451931.160000 L428.580000,451934.640000 L428.040000,451935.540000 L427.860000,451935.300000 L424.980000,451929.360000 L425.880000,451928.940000 L425.880000,451929.360000 L424.980000,451931.040000 '></path><path style='stroke:black' d='M277.980000,451928.040000 L278.760000,451929.840000 L278.040000,451930.500000 L277.920000,451930.380000 L277.800000,451930.200000 L277.020000,451928.400000 '></path><path style='stroke:black' d='M364.740000,451929.300000 L366.240000,451928.100000 L366.540000,451934.700000 L362.760000,451929.240000 '></path><path style='stroke:black' d='M364.560000,451928.160000 L364.080000,451928.280000 L364.500000,451929.360000 L364.980000,451929.240000 '></path><path style='stroke:black' d='M364.560000,451928.160000 L364.620000,451928.400000 L364.140000,451928.580000 L364.080000,451928.340000 '></path><path style='stroke:black' d='M278.280000,451930.020000 L280.020000,451930.860000 L274.200000,451933.920000 L277.500000,451928.220000 '></path><path style='stroke:black' d='M305.460000,451929.600000 L307.380000,451929.780000 L303.060000,451934.760000 L304.080000,451928.220000 '></path><path style='stroke:black' d='M386.580000,451928.220000 L388.500000,451928.220000 L388.860000,451929.120000 L388.680000,451929.240000 L388.500000,451929.300000 L386.580000,451929.300000 '></path><path style='stroke:black' d='M306.180000,451928.640000 L305.700000,451928.400000 L305.220000,451929.480000 L305.700000,451929.720000 '></path><path style='stroke:black' d='M306.180000,451928.640000 L306.120000,451928.820000 L305.700000,451928.640000 L305.760000,451928.460000 '></path><path style='stroke:black' d='M362.760000,451928.700000 L364.740000,451928.760000 L365.040000,451929.720000 L364.920000,451929.840000 L364.740000,451929.840000 L362.760000,451929.780000 '></path><path style='stroke:black' d='M279.300000,451929.420000 L278.940000,451929.060000 L278.100000,451929.840000 L278.460000,451930.200000 '></path><path style='stroke:black' d='M279.300000,451929.420000 L279.120000,451929.600000 L278.760000,451929.240000 L278.940000,451929.060000 '></path><path style='stroke:black' d='M424.500000,451930.800000 L425.400000,451929.120000 L428.280000,451935.060000 L422.700000,451931.580000 '></path><path style='stroke:black' d='M249.540000,451932.000000 L251.100000,451933.200000 L251.940000,451933.860000 L250.920000,451934.100000 L244.560000,451935.900000 L242.820000,451936.440000 L244.020000,451935.120000 L248.460000,451930.260000 L249.180000,451929.480000 L249.360000,451930.440000 L249.240000,451930.920000 L244.800000,451935.780000 L244.020000,451935.120000 L244.260000,451934.940000 L250.620000,451933.140000 L250.920000,451934.100000 L250.500000,451934.040000 L248.940000,451932.840000 '></path><path style='stroke:black' d='M423.900000,451929.780000 L423.540000,451930.140000 L424.320000,451930.980000 L424.680000,451930.620000 '></path><path style='stroke:black' d='M423.900000,451929.840000 L424.020000,451930.020000 L423.660000,451930.320000 L423.540000,451930.140000 '></path><path style='stroke:black' d='M422.460000,451931.160000 L424.260000,451930.380000 L424.980000,451931.040000 L424.860000,451931.220000 L424.680000,451931.280000 L422.880000,451932.060000 '></path><path style='stroke:black' d='M249.360000,451930.440000 L249.720000,451932.300000 L248.940000,451932.840000 L248.760000,451932.720000 L248.760000,451932.540000 L248.400000,451930.680000 '></path><path style='stroke:black' d='M249.240000,451932.420000 L250.800000,451933.620000 L244.440000,451935.420000 L248.880000,451930.560000 '></path><path style='stroke:black' d='M211.860000,451934.040000 L213.120000,451935.540000 L213.840000,451936.320000 L212.760000,451936.440000 L206.220000,451936.920000 L204.540000,451936.980000 L205.860000,451936.020000 L211.140000,451932.120000 L212.040000,451931.460000 L212.040000,451932.480000 L211.800000,451932.900000 L206.520000,451936.800000 L205.860000,451936.020000 L206.160000,451935.900000 L212.700000,451935.420000 L212.760000,451936.440000 L212.400000,451936.260000 L211.140000,451934.760000 '></path><path style='stroke:black' d='M250.380000,451932.000000 L250.140000,451931.640000 L249.120000,451932.240000 L249.360000,451932.600000 '></path><path style='stroke:black' d='M250.380000,451932.060000 L250.200000,451932.180000 L249.960000,451931.760000 L250.140000,451931.640000 '></path><path style='stroke:black' d='M211.500000,451934.400000 L212.760000,451935.900000 L206.220000,451936.380000 L211.500000,451932.480000 '></path><path style='stroke:black' d='M212.040000,451932.480000 L212.040000,451934.400000 L211.140000,451934.760000 L211.020000,451934.580000 L210.960000,451934.400000 L210.960000,451932.480000 '></path><path style='stroke:black' d='M212.700000,451934.280000 L212.580000,451933.800000 L211.440000,451934.160000 L211.560000,451934.640000 '></path><path style='stroke:black' d='M212.760000,451934.280000 L212.520000,451934.340000 L212.340000,451933.860000 L212.580000,451933.800000 '></path><path style='stroke:black' d='M182.220000,451938.239990 L182.220000,451938.720000 L216.060000,451938.720000 L216.060000,451938.239990 '></path><path style='stroke:black' d='M215.640000,451938.239990 L215.640000,451938.720000 L249.480000,451938.720000 L249.480000,451938.239990 '></path><path style='stroke:black' d='M249.060000,451938.239990 L249.060000,451938.720000 L282.900000,451938.720000 L282.900000,451938.239990 '></path><path style='stroke:black' d='M282.420000,451938.239990 L282.420000,451938.720000 L316.320000,451938.720000 L316.320000,451938.239990 '></path><path style='stroke:black' d='M315.840000,451938.239990 L315.840000,451938.720000 L349.680000,451938.720000 L349.680000,451938.239990 '></path><path style='stroke:black' d='M349.260000,451938.239990 L349.260000,451938.720000 L383.100000,451938.720000 L383.100000,451938.239990 '></path><path style='stroke:black' d='M382.680000,451938.239990 L382.680000,451938.720000 L416.520000,451938.720000 L416.520000,451938.239990 '></path><path style='stroke:black' d='M416.040000,451938.239990 L416.040000,451938.720000 L449.880000,451938.720000 L449.880000,451938.239990 '></path><path style='stroke:black' d='M181.980000,451938.240000 L181.980000,451956.480000 L182.460010,451956.480000 L182.460010,451938.240000 '></path><path style='stroke:black' d='M215.400000,451938.240000 L215.400000,451956.480000 L215.880000,451956.480000 L215.880000,451938.240000 '></path><path style='stroke:black' d='M248.820000,451938.240000 L248.820000,451956.480000 L249.300000,451956.480000 L249.300000,451938.240000 '></path><path style='stroke:black' d='M282.180000,451938.240000 L282.180000,451956.480000 L282.660010,451956.480000 L282.660010,451938.240000 '></path><path style='stroke:black' d='M315.600000,451938.240000 L315.600000,451956.480000 L316.079980,451956.480000 L316.079980,451938.240000 '></path><path style='stroke:black' d='M349.020000,451938.240000 L349.020000,451956.480000 L349.500010,451956.480000 L349.500010,451938.240000 '></path><path style='stroke:black' d='M382.440000,451938.240000 L382.440000,451956.480000 L382.920010,451956.480000 L382.920010,451938.240000 '></path><path style='stroke:black' d='M415.800000,451938.240000 L415.800000,451956.480000 L416.279980,451956.480000 L416.279980,451938.240000 '></path><path style='stroke:black' d='M215.580000,451938.480000 L215.580000,451956.720000 L216.060000,451956.720000 L216.060000,451938.480000 '></path><path style='stroke:black' d='M249.000000,451938.480000 L249.000000,451956.720000 L249.480000,451956.720000 L249.480000,451938.480000 '></path><path style='stroke:black' d='M282.420000,451938.480000 L282.420000,451956.720000 L282.899980,451956.720000 L282.899980,451938.480000 '></path><path style='stroke:black' d='M315.840000,451938.480000 L315.840000,451956.720000 L316.320010,451956.720000 L316.320010,451938.480000 '></path><path style='stroke:black' d='M349.200000,451938.480000 L349.200000,451956.720000 L349.679980,451956.720000 L349.679980,451938.480000 '></path><path style='stroke:black' d='M382.620000,451938.480000 L382.620000,451956.720000 L383.100010,451956.720000 L383.100010,451938.480000 '></path><path style='stroke:black' d='M416.040000,451938.480000 L416.040000,451956.720000 L416.519980,451956.720000 L416.519980,451938.480000 '></path><path style='stroke:black' d='M449.400000,451938.480000 L449.400000,451956.720000 L449.880010,451956.720000 L449.880010,451938.480000 '></path><path style='stroke:black' d='M181.980000,451956.239990 L181.980000,451956.720000 L215.820000,451956.720000 L215.820000,451956.239990 '></path><path style='stroke:black' d='M215.400000,451956.239990 L215.400000,451956.720000 L249.240000,451956.720000 L249.240000,451956.239990 '></path><path style='stroke:black' d='M248.820000,451956.239990 L248.820000,451956.720000 L282.660000,451956.720000 L282.660000,451956.239990 '></path><path style='stroke:black' d='M282.180000,451956.239990 L282.180000,451956.720000 L316.080000,451956.720000 L316.080000,451956.239990 '></path><path style='stroke:black' d='M315.600000,451956.239990 L315.600000,451956.720000 L349.440000,451956.720000 L349.440000,451956.239990 '></path><path style='stroke:black' d='M349.020000,451956.239990 L349.020000,451956.720000 L382.860000,451956.720000 L382.860000,451956.239990 '></path><path style='stroke:black' d='M382.440000,451956.239990 L382.440000,451956.720000 L416.280000,451956.720000 L416.280000,451956.239990 '></path><path style='stroke:black' d='M415.800000,451956.239990 L415.800000,451956.720000 L449.640000,451956.720000 L449.640000,451956.239990 '></path><rect y='451817.1' x='307.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='17.4' width='71.4'></rect><rect y='451618.86' x='302.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='17.46' width='71.46'></rect></svg><svg width='308.97' viewBox='200.460005 451670.280010 205.980000 48.360000' height='72.54'><path style='stroke:black' d='M340.560000,451674.420000 L342.360000,451673.700000 L343.260000,451673.220000 L343.020000,451674.360000 L341.520000,451680.780000 L341.100000,451682.460000 L340.560000,451680.780000 L338.460000,451674.480000 L338.100000,451673.520000 L339.120000,451673.820000 L339.420000,451674.180000 L341.520000,451680.480000 L340.560000,451680.780000 L340.560000,451680.480000 L342.060000,451674.060000 L343.020000,451674.360000 L342.720000,451674.660000 L340.920000,451675.380000 '></path><path style='stroke:black' d='M339.120000,451673.820000 L340.920000,451674.420000 L340.920000,451675.380000 L340.740000,451675.440000 L338.760000,451674.780000 '></path><path style='stroke:black' d='M340.740000,451674.900000 L342.540000,451674.180000 L341.040000,451680.600000 L338.940000,451674.300000 '></path><path style='stroke:black' d='M321.360000,451676.220000 L323.280000,451676.340000 L324.360000,451676.400000 L323.640000,451677.240000 L319.380000,451682.280000 L318.240000,451683.600000 L318.480000,451681.860000 L319.380000,451675.320000 L319.560000,451674.300000 L320.280000,451675.020000 L320.400000,451675.440000 L319.500000,451681.980000 L318.480000,451681.860000 L318.600000,451681.620000 L322.860000,451676.580000 L323.640000,451677.240000 L323.220000,451677.420000 L321.300000,451677.300000 '></path><path style='stroke:black' d='M325.080000,451674.600000 L385.680000,451674.600000 L385.680000,451692.600000 L325.080000,451692.600000 '></path><path style='stroke:black' d='M320.280000,451675.020000 L321.720000,451676.400000 L321.300000,451677.300000 L321.120000,451677.240000 L321.000000,451677.120000 L319.560000,451675.740000 '></path><path style='stroke:black' d='M321.360000,451676.760000 L323.280000,451676.880000 L319.020000,451681.920000 L319.920000,451675.380000 '></path><path style='stroke:black' d='M322.020000,451675.800000 L321.540000,451675.560000 L321.120000,451676.640000 L321.600000,451676.880000 '></path><path style='stroke:black' d='M322.020000,451675.800000 L321.960000,451675.980000 L321.540000,451675.800000 L321.600000,451675.620000 '></path><path style='stroke:black' d='M300.420000,451681.500000 L302.220000,451682.160000 L303.180000,451682.460000 L302.280000,451683.060000 L296.880000,451686.780000 L295.440000,451687.800000 L296.160000,451686.180000 L298.740000,451680.120000 L299.160000,451679.160000 L299.640000,451680.060000 L299.640000,451680.540000 L297.060000,451686.540000 L296.160000,451686.180000 L296.340000,451685.940000 L301.740000,451682.220000 L302.280000,451683.060000 L301.860000,451683.120000 L300.060000,451682.460000 '></path><path style='stroke:black' d='M282.240000,451681.920000 L283.920000,451682.880000 L284.820000,451683.360000 L283.860000,451683.780000 L277.860000,451686.480000 L276.240000,451687.200000 L277.260000,451685.760000 L280.920000,451680.300000 L281.460000,451679.400000 L281.820000,451680.360000 L281.760000,451680.840000 L278.100000,451686.300000 L277.260000,451685.760000 L277.440000,451685.580000 L283.440000,451682.880000 L283.860000,451683.780000 L283.440000,451683.720000 L281.760000,451682.760000 '></path><path style='stroke:black' d='M299.640000,451680.060000 L300.660000,451681.740000 L300.060000,451682.460000 L299.880000,451682.400000 L299.820000,451682.220000 L298.800000,451680.540000 '></path><path style='stroke:black' d='M300.240000,451681.980000 L302.040000,451682.640000 L296.640000,451686.360000 L299.220000,451680.300000 '></path><path style='stroke:black' d='M281.820000,451680.360000 L282.480000,451682.160000 L281.760000,451682.760000 L281.580000,451682.700000 L281.520000,451682.520000 L280.860000,451680.720000 '></path><path style='stroke:black' d='M282.000000,451682.340000 L283.680000,451683.300000 L277.680000,451686.000000 L281.340000,451680.540000 '></path><path style='stroke:black' d='M301.140000,451681.260000 L300.780000,451680.900000 L300.060000,451681.800000 L300.420000,451682.160000 '></path><path style='stroke:black' d='M301.140000,451681.260000 L301.020000,451681.440000 L300.660000,451681.140000 L300.780000,451680.960000 '></path><path style='stroke:black' d='M283.080000,451681.800000 L282.720000,451681.440000 L281.820000,451682.160000 L282.180000,451682.520000 '></path><path style='stroke:black' d='M283.080000,451681.800000 L282.900000,451681.920000 L282.600000,451681.560000 L282.780000,451681.440000 '></path><path style='stroke:black' d='M259.560000,451687.500000 L261.120000,451688.640000 L261.960000,451689.240000 L260.940000,451689.540000 L254.700000,451691.640000 L253.080000,451692.240000 L254.160000,451690.860000 L258.360000,451685.760000 L259.020000,451684.920000 L259.260000,451685.940000 L259.140000,451686.360000 L254.940000,451691.460000 L254.160000,451690.860000 L254.400000,451690.680000 L260.640000,451688.580000 L260.940000,451689.540000 L260.520000,451689.480000 L258.960000,451688.340000 '></path><path style='stroke:black' d='M259.260000,451685.940000 L259.740000,451687.800000 L258.960000,451688.340000 L258.840000,451688.220000 L258.780000,451688.040000 L258.300000,451686.180000 '></path><path style='stroke:black' d='M259.260000,451687.920000 L260.820000,451689.060000 L254.580000,451691.160000 L258.780000,451686.060000 '></path><path style='stroke:black' d='M260.340000,451687.440000 L260.100000,451687.080000 L259.140000,451687.740000 L259.380000,451688.100000 '></path><path style='stroke:black' d='M260.400000,451687.500000 L260.220000,451687.620000 L259.920000,451687.200000 L260.100000,451687.080000 '></path><path style='stroke:black' d='M237.240000,451691.160000 L238.740000,451692.420000 L239.580000,451693.080000 L238.500000,451693.320000 L232.140000,451694.940000 L230.520000,451695.360000 L231.660000,451694.160000 L236.160000,451689.360000 L236.880000,451688.580000 L237.060000,451689.600000 L236.940000,451690.020000 L232.440000,451694.820000 L231.660000,451694.160000 L231.960000,451693.980000 L238.320000,451692.360000 L238.500000,451693.320000 L238.140000,451693.260000 L236.640000,451692.000000 '></path><path style='stroke:black' d='M379.920000,451688.940000 L379.800000,451688.760000 L379.440000,451689.060000 L379.560000,451689.240000 '></path><path style='stroke:black' d='M237.060000,451689.600000 L237.420000,451691.520000 L236.640000,451692.000000 L236.460000,451691.880000 L236.460000,451691.640000 L236.100000,451689.720000 '></path><path style='stroke:black' d='M236.940000,451691.580000 L238.440000,451692.840000 L232.080000,451694.460000 L236.580000,451689.660000 '></path><path style='stroke:black' d='M238.080000,451691.160000 L237.840000,451690.800000 L236.820000,451691.400000 L237.060000,451691.760000 '></path><path style='stroke:black' d='M238.080000,451691.220000 L237.900000,451691.340000 L237.660000,451690.920000 L237.840000,451690.800000 '></path><path style='stroke:black' d='M213.660000,451694.700000 L215.100000,451696.020000 L215.880000,451696.620000 L214.800000,451696.860000 L208.380000,451698.240000 L206.760000,451698.600000 L207.960000,451697.400000 L212.700000,451692.780000 L213.420000,451692.060000 L213.540000,451693.080000 L213.420000,451693.500000 L208.680000,451698.120000 L207.960000,451697.400000 L208.200000,451697.280000 L214.620000,451695.900000 L214.800000,451696.860000 L214.380000,451696.740000 L212.940000,451695.420000 '></path><path style='stroke:black' d='M213.540000,451693.080000 L213.780000,451695.000000 L212.940000,451695.420000 L212.820000,451695.300000 L212.820000,451695.120000 L212.580000,451693.200000 '></path><path style='stroke:black' d='M213.300000,451695.060000 L214.740000,451696.380000 L208.320000,451697.760000 L213.060000,451693.140000 '></path><path style='stroke:black' d='M369.420000,451693.380000 L369.360000,451693.140000 L368.880000,451693.320000 L368.940000,451693.560000 '></path><path style='stroke:black' d='M214.440000,451694.760000 L214.200000,451694.280000 L213.180000,451694.820000 L213.420000,451695.300000 '></path><path style='stroke:black' d='M214.440000,451694.760000 L214.260000,451694.880000 L214.020000,451694.460000 L214.200000,451694.340000 '></path><path style='stroke:black' d='M348.000000,451697.220000 L347.940000,451696.980000 L347.460000,451697.160000 L347.520000,451697.400000 '></path><path style='stroke:black' d='M311.220000,451707.360000 L311.280000,451707.180000 L310.860000,451707.000000 L310.800000,451707.180000 '></path><path style='stroke:black' d='M294.540000,451711.260000 L294.720000,451711.080000 L294.360000,451710.720000 L294.180000,451710.900000 '></path><path style='stroke:black' d='M274.860000,451715.100000 L275.040000,451714.980000 L274.800000,451714.560000 L274.620000,451714.680000 '></path><rect y='451678.98' x='304.32' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451683.3' x='283.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451692.0' x='241.98' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451687.62' x='262.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451696.32' x='221.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><text y='451713.526926' x='386.52' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='16.43444904'>Sum</text></svg><svg width='309.0600075' viewBox='206.040000 451868.459995 206.040005 48.420015' height='72.6300224999'><path style='stroke:black' d='M346.200000,451872.660000 L348.000000,451871.880000 L348.900000,451871.460000 L348.660000,451872.540000 L347.100000,451878.960000 L346.680000,451880.640000 L346.140000,451878.960000 L344.040000,451872.720000 L343.680000,451871.760000 L344.700000,451872.060000 L345.000000,451872.420000 L347.100000,451878.660000 L346.140000,451878.960000 L346.140000,451878.660000 L347.700000,451872.240000 L348.660000,451872.540000 L348.360000,451872.840000 L346.560000,451873.620000 '></path><path style='stroke:black' d='M346.560000,451871.940000 L346.080000,451871.940000 L346.140000,451873.140000 L346.620000,451873.140000 '></path><path style='stroke:black' d='M344.700000,451872.060000 L346.560000,451872.660000 L346.560000,451873.620000 L346.380000,451873.680000 L346.200000,451873.620000 L344.340000,451873.020000 '></path><path style='stroke:black' d='M346.380000,451873.140000 L348.180000,451872.360000 L346.620000,451878.780000 L344.520000,451872.540000 '></path><path style='stroke:black' d='M326.940000,451874.400000 L328.860000,451874.520000 L329.940000,451874.580000 L329.220000,451875.420000 L325.020000,451880.520000 L323.880000,451881.840000 L324.120000,451880.100000 L325.020000,451873.560000 L325.200000,451872.540000 L325.920000,451873.260000 L326.040000,451873.680000 L325.140000,451880.220000 L324.120000,451880.100000 L324.240000,451879.860000 L328.440000,451874.760000 L329.220000,451875.420000 L328.800000,451875.600000 L326.880000,451875.480000 '></path><path style='stroke:black' d='M325.920000,451873.260000 L327.300000,451874.580000 L326.880000,451875.480000 L326.700000,451875.420000 L326.580000,451875.300000 L325.200000,451873.980000 '></path><path style='stroke:black' d='M326.940000,451874.940000 L328.860000,451875.060000 L324.660000,451880.160000 L325.560000,451873.620000 '></path><path style='stroke:black' d='M327.660000,451873.980000 L327.180000,451873.740000 L326.700000,451874.820000 L327.180000,451875.060000 '></path><path style='stroke:black' d='M327.660000,451873.980000 L327.600000,451874.160000 L327.180000,451873.980000 L327.240000,451873.800000 '></path><path style='stroke:black' d='M306.000000,451879.740000 L307.860000,451880.340000 L308.820000,451880.640000 L307.920000,451881.240000 L302.460000,451885.020000 L301.020000,451886.100000 L301.740000,451884.420000 L304.380000,451878.360000 L304.800000,451877.400000 L305.280000,451878.300000 L305.280000,451878.780000 L302.640000,451884.780000 L301.740000,451884.420000 L301.920000,451884.180000 L307.380000,451880.400000 L307.920000,451881.240000 L307.500000,451881.300000 L305.640000,451880.700000 '></path><path style='stroke:black' d='M287.820000,451880.160000 L289.500000,451881.120000 L290.400000,451881.600000 L289.440000,451882.020000 L283.440000,451884.720000 L281.820000,451885.440000 L282.840000,451884.000000 L286.500000,451878.480000 L287.040000,451877.580000 L287.400000,451878.540000 L287.340000,451879.020000 L283.680000,451884.540000 L282.840000,451884.000000 L283.020000,451883.820000 L289.020000,451881.120000 L289.440000,451882.020000 L289.020000,451881.960000 L287.340000,451881.000000 '></path><path style='stroke:black' d='M305.280000,451878.300000 L306.240000,451879.980000 L305.640000,451880.700000 L305.460000,451880.640000 L305.400000,451880.460000 L304.440000,451878.780000 '></path><path style='stroke:black' d='M287.400000,451878.540000 L288.060000,451880.400000 L287.340000,451881.000000 L287.160000,451880.940000 L287.100000,451880.760000 L286.440000,451878.900000 '></path><path style='stroke:black' d='M305.820000,451880.220000 L307.680000,451880.820000 L302.220000,451884.600000 L304.860000,451878.540000 '></path><path style='stroke:black' d='M287.580000,451880.580000 L289.260000,451881.540000 L283.260000,451884.240000 L286.920000,451878.720000 '></path><path style='stroke:black' d='M306.720000,451879.500000 L306.360000,451879.140000 L305.640000,451880.040000 L306.000000,451880.400000 '></path><path style='stroke:black' d='M306.720000,451879.500000 L306.600000,451879.680000 L306.240000,451879.380000 L306.360000,451879.200000 '></path><path style='stroke:black' d='M288.660000,451879.980000 L288.300000,451879.620000 L287.400000,451880.400000 L287.760000,451880.760000 '></path><path style='stroke:black' d='M288.660000,451879.980000 L288.480000,451880.100000 L288.180000,451879.740000 L288.360000,451879.620000 '></path><path style='stroke:black' d='M265.140000,451885.740000 L266.760000,451886.820000 L267.600000,451887.420000 L266.580000,451887.720000 L260.280000,451889.820000 L258.660000,451890.420000 L259.740000,451889.040000 L263.940000,451883.940000 L264.600000,451883.100000 L264.840000,451884.120000 L264.720000,451884.540000 L260.520000,451889.640000 L259.740000,451889.040000 L259.980000,451888.860000 L266.280000,451886.760000 L266.580000,451887.720000 L266.160000,451887.660000 L264.540000,451886.580000 '></path><path style='stroke:black' d='M264.840000,451884.120000 L265.320000,451886.040000 L264.540000,451886.580000 L264.420000,451886.460000 L264.360000,451886.280000 L263.880000,451884.360000 '></path><path style='stroke:black' d='M264.840000,451886.160000 L266.460000,451887.240000 L260.160000,451889.340000 L264.360000,451884.240000 '></path><path style='stroke:black' d='M265.920000,451885.680000 L265.680000,451885.320000 L264.720000,451885.980000 L264.960000,451886.340000 '></path><path style='stroke:black' d='M265.980000,451885.740000 L265.800000,451885.860000 L265.500000,451885.440000 L265.680000,451885.320000 '></path><path style='stroke:black' d='M242.820000,451889.400000 L244.320000,451890.600000 L245.220000,451891.260000 L244.080000,451891.500000 L237.720000,451893.180000 L236.040000,451893.660000 L237.240000,451892.400000 L241.800000,451887.600000 L242.520000,451886.820000 L242.700000,451887.840000 L242.580000,451888.260000 L238.020000,451893.060000 L237.240000,451892.400000 L237.540000,451892.220000 L243.900000,451890.540000 L244.080000,451891.500000 L243.720000,451891.440000 L242.220000,451890.240000 '></path><path style='stroke:black' d='M385.560000,451887.180000 L385.440000,451887.000000 L385.080000,451887.300000 L385.200000,451887.480000 '></path><path style='stroke:black' d='M242.700000,451887.840000 L243.000000,451889.760000 L242.220000,451890.240000 L242.040000,451890.120000 L242.040000,451889.880000 L241.740000,451887.960000 '></path><path style='stroke:black' d='M242.520000,451889.820000 L244.020000,451891.020000 L237.660000,451892.700000 L242.220000,451887.900000 '></path><path style='stroke:black' d='M243.660000,451889.400000 L243.420000,451889.040000 L242.400000,451889.640000 L242.640000,451890.000000 '></path><path style='stroke:black' d='M243.660000,451889.460000 L243.480000,451889.580000 L243.240000,451889.160000 L243.420000,451889.040000 '></path><path style='stroke:black' d='M219.240000,451892.940000 L220.680000,451894.200000 L221.460000,451894.800000 L220.380000,451895.040000 L213.960000,451896.420000 L212.280000,451896.840000 L213.540000,451895.580000 L218.280000,451891.020000 L219.000000,451890.300000 L219.120000,451891.320000 L219.000000,451891.740000 L214.260000,451896.300000 L213.540000,451895.580000 L213.780000,451895.460000 L220.200000,451894.080000 L220.380000,451895.040000 L219.960000,451894.920000 L218.520000,451893.660000 '></path><path style='stroke:black' d='M219.120000,451891.320000 L219.360000,451893.240000 L218.520000,451893.660000 L218.400000,451893.540000 L218.400000,451893.360000 L218.160000,451891.440000 '></path><path style='stroke:black' d='M218.880000,451893.300000 L220.320000,451894.560000 L213.900000,451895.940000 L218.640000,451891.380000 '></path><path style='stroke:black' d='M375.000000,451891.620000 L374.940000,451891.380000 L374.460000,451891.560000 L374.520000,451891.800000 '></path><path style='stroke:black' d='M220.020000,451893.000000 L219.780000,451892.520000 L218.760000,451893.060000 L219.000000,451893.540000 '></path><path style='stroke:black' d='M220.020000,451893.000000 L219.840000,451893.120000 L219.600000,451892.700000 L219.780000,451892.580000 '></path><path style='stroke:black' d='M353.580000,451895.400000 L353.520000,451895.160000 L353.040000,451895.340000 L353.100000,451895.580000 '></path><path style='stroke:black' d='M316.800000,451905.600000 L316.860000,451905.420000 L316.440000,451905.240000 L316.380000,451905.420000 '></path><path style='stroke:black' d='M300.120000,451909.440000 L300.300000,451909.260000 L299.940000,451908.900000 L299.760000,451909.080000 '></path><path style='stroke:black' d='M280.500000,451913.340000 L280.680000,451913.220000 L280.440000,451912.800000 L280.260000,451912.920000 '></path><rect y='451868.46' x='351.48' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451872.84' x='330.66' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451877.16' x='309.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451881.48' x='289.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451890.18' x='247.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451885.86' x='268.38' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><rect y='451894.56' x='226.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='60.6'></rect><text y='451911.766926' x='392.1' style='font-size:7.990300pt' lengthAdjust='spacingAndGlyphs' textLength='16.43444904'>Sum</text></svg><h3>Figure 3-27.  256-bit VMPSADBW Operation</h3></span>", "url": "MPSADBW.html", "tooltip": "(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane. Each SAD word result is calculated between a stationary block_2 (whose offset within the second source operand is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit select control, multiplied by 32 bits."},
    "AAS": {"html": "<p>Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL register is left with its top four bits set to 0.</p><p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "AAS.html", "tooltip": "Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result."},
    "LODS": {"html": "<p>Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-ridden with a segment override prefix.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the assembly-code level, two forms of this instruction are allowed: the 'explicit-operands” form and the 'no-operands” form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct <strong>type</strong> (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct <strong>location</strong>. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.</p><p>The no-operands form provides 'short forms” of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the desti-nation operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).</p><p>After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p><p>In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.</p><p>The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is  usually necessary before the next transfer can be made. See 'REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B</em>, for a description of the REP prefix.</p></span>", "url": "LODS:LODSB:LODSW:LODSD:LODSQ.html", "tooltip": "Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-ridden with a segment override prefix."},
    "CMPXCHG": {"html": "<p>Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "CMPXCHG.html", "tooltip": "Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode."},
    "PCMPESTRI": {"html": "<p>The instruction compares and processes data from two string fragments based on the encoded value in the Imm8 Control Byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMP-ISTRM”), and generates an index stored to the count register (ECX/RCX).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data).  The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length repre-sents the number of bytes/words which are valid for the respective xmm/m128 data.</p><p>The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).</p><p>The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 (see Section 4.1.4) is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).</p><p>Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-tion:</p><p>CFlag – Reset if IntRes2 is equal to zero, set otherwise</p><p>ZFlag – Set if absolute-value of EDX is &lt; 16 (8), reset otherwise</p><p>SFlag – Set if absolute-value of EAX is &lt; 16 (8), reset otherwise</p><p>OFlag – IntRes2[0]</p><p>AFlag – Reset</p><p>PFlag – Reset</p></span>", "url": "PCMPESTRI.html", "tooltip": "The instruction compares and processes data from two string fragments based on the encoded value in the Imm8 Control Byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMP-ISTRM”), and generates an index stored to the count register (ECX/RCX)."},
    "DIV": {"html": "<p>Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magni-tude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in RAX, the remainder in RDX.</p><p>See the summary chart at the beginning of this section for encoding data and limits. See Table 3-25.</p><h3>Table 3-25.  DIV Action</h3><table><tr><td><p><strong>Maximum</strong></p><p><strong>Operand Size</strong></p><p><strong>Dividend</strong></p><p><strong>Divisor</strong></p><p><strong>Quotient</strong></p><p><strong>Remainder</strong></p><p><strong>Quotient</strong></p><p>Word/byte</p><p>AX</p><p>r/m8</p><p>AL</p><p>AH</p><p>255</p><p>Doubleword/word</p><p>DX:AX</p><p>r/m16</p><p>AX</p><p>DX</p><p>65,535</p><p>Quadword/doubleword</p><p>EDX:EAX</p><p>r/m32</p><p>EAX</p><p>EDX</p><p>2<sup>32</sup> − 1</p><p>Doublequadword/</p><p>RDX:RAX</p><p>r/m64</p><p>RAX</p><p>RDX</p><p>2<sup>64</sup> − 1</p><p>quadword</p></td></tr></table></span>", "url": "DIV.html", "tooltip": "Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). Division using 64-bit operand is available only in 64-bit mode."},
    "VPGATHERDQ": {"html": "<p>The instruction conditionally loads up to 2 or 4 qword values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-fied by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.</p><p>Using dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 qword values from the VSIB addressing memory operand, and updates the destination register.</p><p>This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set).  When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero.  If any traps or interrupts are pending from already gath-ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.</p><p>If the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered.  This instruction sets those parts to zero.  It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.</p><p>VEX.128 version: The instruction will gather two qword values.  For dword indices, only the lower two indices in the vector index register are used.</p><p>VEX.256 version: The instruction will gather four qword values.  For dword indices, only the lower four indices in the vector index register are used.</p><p>Note that:</p></span>", "url": "VPGATHERDQ:VPGATHERQQ.html", "tooltip": "The instruction conditionally loads up to 2 or 4 qword values from memory addresses specified by the memory operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor."},
    "VPBROADCAST": {"html": "<p>Load integer data from the source operand (second operand) and broadcast to all elements of the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The destination operand is a YMM register. The source operand is 8-bit, 16-bit 32-bit, 64-bit memory location or the low 8-bit, 16-bit 32-bit, 64-bit data in an XMM register. VPBROADCASTB/D/W/Q also support XMM register as the source operand.</p><p>VBROADCASTI128: The destination operand is a YMM register. The source operand is 128-bit memory location. Register source encodings for VBROADCASTI128 are reserved and will #UD.</p><p>VPBROADCASTB/W/D/Q is supported in both 128-bit and 256-bit wide versions.</p><p>VBROADCASTI128 is only supported as a 256-bit wide version.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. Attempts to execute any VPBROADCAST* instruction with VEX.W = 1 will cause #UD. If VBROADCASTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception.</p><p>X0</p><p>m32</p><p>DEST</p><p>X0</p><p>X0</p><p>X0</p><p>X0</p><p>X0</p><p>X0</p><p>X0</p><p>X0</p><h3>Figure 4-33.  VPBROADCASTD Operation (VEX.256 encoded version)</h3><p>X0</p><p>m32</p><p>DEST</p><p>0</p><p>0</p><p>0</p><p>0</p><p>X0</p><p>X0</p><p>X0</p><p>X0</p><h3>Figure 4-34.  VPBROADCASTD Operation (128-bit version)</h3><p>m64</p><p>X0</p><p>DEST</p><p>X0</p><p>X0</p><p>X0</p><p>X0</p><h3>Figure 4-35.  VPBROADCASTQ Operation</h3><p>m128i</p><p>X0</p><svg width='445.499985' viewBox='145.860000 876124.379980 296.999990 13.500030' height='20.250045'><rect y='876124.38' x='145.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='148.5'></rect><text y='876134.1135' x='206.64' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text></svg><p>DEST</p><p>X0</p><h3>Figure 4-36.  VBROADCASTI128 Operation</h3></span>", "url": "VPBROADCAST.html", "tooltip": "Load integer data from the source operand (second operand) and broadcast to all elements of the destination operand (first operand)."},
    "MOVLHPS": {"html": "<p>This instruction cannot be used for memory to register moves.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p><strong>128-bit two-argument form:</strong></p><p>Moves two packed single-precision floating-point values from the low quadword of the second XMM argument (second operand) to the high quadword of the first XMM register (first argument). The low quadword of the desti-nation operand is left unchanged. The upper 128 bits of the corresponding YMM destination register are unmodi-fied.</p><p><strong>128-bit three-argument form</strong></p><p>Moves two packed single-precision floating-point values from the low quadword of the third XMM argument (third operand) to the high quadword of the destination (first operand). Copies the low quadword from the second XMM argument (second operand) to the low quadword of the destination (first operand). The upper 128-bits of the destination YMM register are zeroed.</p><p>If VMOVLHPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "MOVLHPS.html", "tooltip": "This instruction cannot be used for memory to register moves."},
    "CBW": {"html": "<p>Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attri-bute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.</p><p>In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.</p></span>", "url": "CBW:CWDE:CDQE.html", "tooltip": "Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register."},
    "VFMADD132PD": {"html": "<p>Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMADD132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand, adds the infi-nite precision intermediate result to the two or four packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFMADD213PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand, adds the infi-nite precision intermediate result to the two or four packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFMADD231PD: Multiplies the two or four packed double-precision floating-point values from the second source to the two or four packed double-precision floating-point values in the third source operand, adds the infinite preci-sion intermediate result to the two or four packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMADD132PD:VFMADD213PD:VFMADD231PD.html", "tooltip": "Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "VPERMQ": {"html": "<p>Use two-bit index values in the immediate byte to select a qword element in the source operand, the resultant qword value from the source operand is copied to the corresponding element of the destination operand in the order of the index field. Note that this instruction permits a qword in the source operand to be copied to multiple locations in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>An attempt to execute VPERMQ encoded with VEX.L= 0 will cause an #UD exception.</p></span>", "url": "VPERMQ.html", "tooltip": "Use two-bit index values in the immediate byte to select a qword element in the source operand, the resultant qword value from the source operand is copied to the corresponding element of the destination operand in the order of the index field. Note that this instruction permits a qword in the source operand to be copied to multiple locations in the destination operand."},
    "FPTAN": {"html": "<p>Computes the tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than ±2<sup>63</sup>. The following table shows the unmasked results obtained when computing the partial tangent of various classes of numbers, assuming that underflow does not occur.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-43.  FPTAN Results</h3><table><tr><th>ST(0) SRC</th><th>ST(0) DEST</th></tr><tr><td>− ∞</td><td>*</td></tr><tr><td>− F</td><td>− F to + F</td></tr><tr><td>− 0</td><td>- 0</td></tr><tr><td>+ 0</td><td>+ 0</td></tr><tr><td>+ F</td><td>− F to + F</td></tr><tr><td>+ ∞</td><td>*</td></tr><tr><td>NaN</td><td>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 2<sup>63</sup> to +2<sup>63</sup> can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π or by using the FPREM instruction with a divisor of 2π. See the section titled 'Pi” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for a discussion of the proper value to use for π in performing such reductions.</p><p>The value 1.0 is pushed onto the register stack after the tangent has been computed to maintain compatibility with the Intel 8087 and Intel287 math coprocessors. This operation also simplifies the calculation of other trigonometric functions. For instance, the cotangent (which is the reciprocal of the tangent) can be computed by executing a FDIVR instruction after the FPTAN instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FPTAN.html", "tooltip": "Computes the tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than ±2<sup>63</sup>. The following table shows the unmasked results obtained when computing the partial tangent of various classes of numbers, assuming that underflow does not occur."},
    "RDTSC": {"html": "<p>Loads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See 'Time Stamp Counter” in Chapter 17 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B</em>, for specific details of the time stamp counter behavior.</p><p>When in protected or virtual 8086 mode, the time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the TSD flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0. (When in real-address mode, the RDTSC instruction is always enabled.)</p><p>The time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.</p><p>The RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the read operation is performed. If software requires RDTSC to be executed only after all previous instructions have completed locally, it can either use RDTSCP (if the processor supports that instruction) or execute the sequence LFENCE;RDTSC.</p><p>This instruction was introduced by the Pentium processor.</p><p>See 'Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p></span>", "url": "RDTSC.html", "tooltip": "Loads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)"},
    "EXTRACTPS": {"html": "<p>Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset spec-ified from imm8. Immediate bits higher than the most significant offset for the vector length are ignored.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The extracted single-precision floating-point value is stored in the low 32-bits of the destination operand</p><p>In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register are filled with zero. REX.W is ignored.</p><p>128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.</p><p>VEX.128 encoded version: When VEX.128.66.0F3A.W1 17 form is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits. VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>The source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the 32-bit floating-point value.</p><p>If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "EXTRACTPS.html", "tooltip": "Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset spec-ified from imm8. Immediate bits higher than the most significant offset for the vector length are ignored."},
    "MASKMOVQ": {"html": "<p>Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask oper-ands are MMX technology registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.</p><p>The MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see 'Caching of Temporal vs. Non-Temporal Data” in Chapter 10, of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation imple-mented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVQ instructions if multiple processors might use different memory types to read/write the destination memory locations.</p><p>This instruction causes a transition from x87 FPU to MMX technology state (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]).</p><p>The behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:</p><p>The MASKMOVQ instruction can be used to improve performance for algorithms that need to merge data on a byte-by-byte basis. It should not cause a read for ownership; doing so generates unnecessary bandwidth since data is to be written directly using the byte-mask without allocating old data prior to the store.</p><p>In 64-bit mode, the memory address is specified by DS:RDI.</p></span>", "url": "MASKMOVQ.html", "tooltip": "Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask oper-ands are MMX technology registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)"},
    "VFNMSUB132PD": {"html": "<p>VFNMSUB132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two or four packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMSUB213PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the two or four packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFMSUB231PD: Multiplies the two or four packed double-precision floating-point values from the second source to the two or four packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two or four packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a</p><p>XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMSUB132PD:VFNMSUB213PD:VFNMSUB231PD.html", "tooltip": "VFNMSUB132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two or four packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand)."},
    "UNPCKLPD": {"html": "<p>Performs an interleaved unpack of the low double-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-25. The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 801892.019995 379.199990 148.320005' height='222.4800075'><text y='801918.527284' x='141.6594' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='801962.867384' x='146.1594' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='802024.847184' x='141.6594' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='802014.96' x='168.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='143.22'></rect><rect y='801906.96' x='168.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.12'></rect><rect y='801951.96' x='168.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.12'></rect><rect y='801906.96' x='312.06' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.18'></rect><rect y='802014.96' x='311.4' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.18'></rect><rect y='801951.96' x='311.22' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='145.02'></rect><path style='stroke:black' d='M168.240000,801906.719990 L168.240000,801907.200000 L312.600000,801907.200000 L312.600000,801906.719990 '></path><path style='stroke:black' d='M312.060000,801906.719990 L312.060000,801907.200000 L456.480000,801907.200000 L456.480000,801906.719990 '></path><path style='stroke:black' d='M168.000000,801906.720000 L168.000000,801924.960000 L168.480000,801924.960000 L168.480000,801906.720000 '></path><path style='stroke:black' d='M311.820000,801906.720000 L311.820000,801924.960000 L312.299980,801924.960000 L312.299980,801906.720000 '></path><path style='stroke:black' d='M312.120000,801906.960000 L312.120000,801925.200000 L312.600010,801925.200000 L312.600010,801906.960000 '></path><path style='stroke:black' d='M456.000000,801906.960000 L456.000000,801925.200000 L456.480010,801925.200000 L456.480010,801906.960000 '></path><path style='stroke:black' d='M168.000000,801924.719990 L168.000000,801925.200000 L312.360000,801925.200000 L312.360000,801924.719990 '></path><path style='stroke:black' d='M311.820000,801924.719990 L311.820000,801925.200000 L456.240000,801925.200000 L456.240000,801924.719990 '></path><path style='stroke:black' d='M168.240000,801951.719990 L168.240000,801952.200000 L312.600000,801952.200000 L312.600000,801951.719990 '></path><path style='stroke:black' d='M311.220000,801951.719990 L311.220000,801952.200000 L456.480000,801952.200000 L456.480000,801951.719990 '></path><path style='stroke:black' d='M168.000000,801951.720000 L168.000000,801969.960000 L168.480000,801969.960000 L168.480000,801951.720000 '></path><path style='stroke:black' d='M310.980000,801951.720000 L310.980000,801969.960000 L311.459980,801969.960000 L311.459980,801951.720000 '></path><path style='stroke:black' d='M312.120000,801951.960000 L312.120000,801970.200000 L312.600010,801970.200000 L312.600010,801951.960000 '></path><path style='stroke:black' d='M456.000000,801951.960000 L456.000000,801970.200000 L456.480010,801970.200000 L456.480010,801951.960000 '></path><path style='stroke:black' d='M168.000000,801969.719990 L168.000000,801970.200000 L312.360000,801970.200000 L312.360000,801969.719990 '></path><path style='stroke:black' d='M310.980000,801969.719990 L310.980000,801970.200000 L456.240000,801970.200000 L456.240000,801969.719990 '></path><path style='stroke:black' d='M168.420000,802014.719990 L168.420000,802015.200000 L311.880000,802015.200000 L311.880000,802014.719990 '></path><path style='stroke:black' d='M311.400000,802014.719990 L311.400000,802015.200000 L455.820000,802015.200000 L455.820000,802014.719990 '></path><path style='stroke:black' d='M168.180000,802014.720000 L168.180000,802032.960000 L168.660000,802032.960000 L168.660000,802014.720000 '></path><path style='stroke:black' d='M311.160000,802014.720000 L311.160000,802032.960000 L311.640010,802032.960000 L311.640010,802014.720000 '></path><path style='stroke:black' d='M311.400000,802014.960000 L311.400000,802033.200000 L311.880010,802033.200000 L311.880010,802014.960000 '></path><path style='stroke:black' d='M455.340000,802014.960000 L455.340000,802033.200000 L455.820010,802033.200000 L455.820010,802014.960000 '></path><path style='stroke:black' d='M168.180000,802032.719990 L168.180000,802033.200000 L311.640000,802033.200000 L311.640000,802032.719990 '></path><path style='stroke:black' d='M311.160000,802032.719990 L311.160000,802033.200000 L455.580000,802033.200000 L455.580000,802032.719990 '></path><text y='802027.007384' x='234.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text><text y='801919.307484' x='234.24' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='801965.207484' x='234.24' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='801920.207584' x='380.9403' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='802027.247584' x='377.6999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='801965.207484' x='380.037792' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.713256'>Y0</text></svg><h3>Figure 4-25.  UNPCKLPD Instruction Low Unpack and Interleave Operation</h3><p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: T second source can be an XMM register or an 128-bit memory location. The destina-tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p></span>", "url": "UNPCKLPD.html", "tooltip": "Performs an interleaved unpack of the low double-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-25. The source operand can be an XMM register or a 128-bit memory location; the destination operand is an XMM register."},
    "PSHUFW": {"html": "<p>Copies words from the source operand (second operand) and inserts them in the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the opera-tion used by the PSHUFD instruction, which is illustrated in Figure 4-12. For the PSHUFW instruction, each 2-bit field in the order operand selects the contents of one word location in the destination operand. The encodings of the order operand fields select words from the source operand to be copied to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register. The order operand is an 8-bit immediate. Note that this instruction permits a word in the source operand to be copied to more than one word location in the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "PSHUFW.html", "tooltip": "Copies words from the source operand (second operand) and inserts them in the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the opera-tion used by the PSHUFD instruction, which is illustrated in Figure 4-12. For the PSHUFW instruction, each 2-bit field in the order operand selects the contents of one word location in the destination operand. The encodings of the order operand fields select words from the source operand to be copied to the destination operand."},
    "MAXSS": {"html": "<p>Compares the low single-precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low doubleword of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "MAXSS.html", "tooltip": "Compares the low single-precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low doubleword of the destination operand."},
    "SUB": {"html": "<p>Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The SUB instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p></span>", "url": "SUB.html", "tooltip": "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format."},
    "CVTPD2PI": {"html": "<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX tech-nology register.</p><p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "CVTPD2PI.html", "tooltip": "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand)."},
    "CVTSD2SS": {"html": "<p>Converts a double-precision floating-point value in the source operand (second operand) to a single-precision floating-point value in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register. The result is stored in the low doubleword of the destination operand, and the upper 3 doublewords are left unchanged. When the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "CVTSD2SS.html", "tooltip": "Converts a double-precision floating-point value in the source operand (second operand) to a single-precision floating-point value in the destination operand (first operand)."},
    "FSIN": {"html": "<p>Computes the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −2<sup>63</sup> to +2<sup>63</sup>. The following table shows the results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-45.  FSIN Results</h3><table><tr><th>SRC (ST(0))</th><th>DEST (ST(0))</th></tr><tr><td>− ∞</td><td>*</td></tr><tr><td>− F</td><td>− 1 to + 1</td></tr><tr><td>− 0</td><td>−0</td></tr><tr><td>+ 0</td><td>+ 0</td></tr><tr><td>+ F</td><td>− 1 to +1</td></tr><tr><td>+ ∞</td><td>*</td></tr><tr><td>NaN</td><td>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 2<sup>63</sup> to +2<sup>63</sup> can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π or by using the FPREM instruction with a divisor of 2π. See the section titled 'Pi” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for a discussion of the proper value to use for π in performing such reductions.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSIN.html", "tooltip": "Computes the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −2<sup>63</sup> to +2<sup>63</sup>. The following table shows the results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur."},
    "PEXT": {"html": "<p>PEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contig-uous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination (the first operand). For each bit set in the MASK, PEXT extracts the corresponding bits from the first source operand and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are zeroed.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>SRC1</p><p>S<sub>31 </sub>S<sub>30 </sub>S<sub>29 </sub>S<sub>28 </sub>S<sub>27</sub></p><p>S<sub>7</sub></p><p>S<sub>6</sub></p><p>S<sub>5</sub></p><p>S<sub>4</sub></p><p>S<sub>3</sub></p><p>S<sub>2</sub></p><p>S<sub>1</sub></p><p>S<sub>0</sub></p><p>SRC2</p><p>0</p><p>0</p><p>0</p><p>0</p><p>1</p><p>0</p><p>1</p><p>0</p><p>1</p><p>0</p><p>1</p><p>0</p><p>0</p><p>(mask)</p><p>S<sub>2</sub></p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>S<sub>7</sub></p><p>S<sub>5</sub></p><p>DEST</p><p>S<sub>28</sub></p><p>bit 0</p><p>bit 31</p><h3>Figure 4-5.  PEXT Example</h3><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "PEXT.html", "tooltip": "PEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contig-uous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination (the first operand). For each bit set in the MASK, PEXT extracts the corresponding bits from the first source operand and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are zeroed."},
    "INS": {"html": "<p>Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attri-bute of the instruction for a 16- or 32-bit I/O port.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the assembly-code level, two forms of this instruction are allowed: the 'explicit-operands” form and the 'no-operands” form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be 'DX,” and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct <strong>type</strong> (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct <strong>location</strong>. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.</p><p>The no-operands form provides 'short forms” of the byte, word, and doubleword versions of the INS instructions. Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).</p><p>After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p><p>The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See 'REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B</em>, for a description of the REP prefix.</p><p>These instructions are only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 16, 'Input/Output,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more information on accessing I/O ports in the I/O address space.</p><p>In 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The operand size is not promoted.</p></span>", "url": "INS:INSB:INSW:INSD.html", "tooltip": "Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attri-bute of the instruction for a 16- or 32-bit I/O port."},
    "ROUNDPD": {"html": "<p>Round the 2 double-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single-precision floating-point value.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-15 lists the encoded values for rounding-mode field).</p><p>The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.</p><p>128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p><svg width='570.2399775' viewBox='111.900005 716833.980010 380.159985 99.060000' height='148.59'><text y='716847.042768' x='168.78' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='3.86976'>8</text><text y='716847.282768' x='407.94' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='3.86976'>3</text><text y='716847.282768' x='424.6203' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='3.86976'>1</text><text y='716847.282768' x='433.079484' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='3.86976'>0</text><text y='716847.463068' x='416.04' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='3.86976'>2</text><text y='716901.767484' x='185.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='148.413636'>P — Precision Mask; 0: normal, 1: inexact</text><text y='716911.787484' x='184.38' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='183.790572'>RS — Rounding select; 1: MXCSR.RC, 0: Imm8.RC</text><text y='716920.607784' x='184.7399' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='80.42244'>RC — Rounding mode</text><rect y='716851.26' x='168.42' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.24' width='237.6'></rect><path style='stroke:black' d='M168.360000,716850.780000 L168.360000,716878.560000 L168.840000,716878.560000 L168.840000,716850.780000 '></path><path style='stroke:black' d='M168.600000,716850.780020 L168.600000,716851.260000 L439.440000,716851.260000 L439.440000,716850.780020 '></path><path style='stroke:black' d='M405.660000,716850.960000 L405.660000,716851.080000 L405.959990,716851.080000 L405.959990,716850.960000 '></path><path style='stroke:black' d='M413.760000,716850.960000 L413.760000,716851.080000 L414.059990,716851.080000 L414.059990,716850.960000 '></path><path style='stroke:black' d='M422.160000,716850.960000 L422.160000,716851.080000 L422.459990,716851.080000 L422.459990,716850.960000 '></path><path style='stroke:black' d='M438.960000,716851.020000 L438.960000,716878.800000 L439.440010,716878.800000 L439.440010,716851.020000 '></path><path style='stroke:black' d='M405.660000,716851.080000 L405.660000,716878.500000 L405.959990,716878.500000 L405.959990,716851.080000 '></path><path style='stroke:black' d='M413.760000,716851.080000 L413.760000,716878.500000 L414.059990,716878.500000 L414.059990,716851.080000 '></path><path style='stroke:black' d='M422.160000,716851.080000 L422.160000,716878.500000 L422.459990,716878.500000 L422.459990,716851.080000 '></path><path style='stroke:black' d='M435.120000,716878.140000 L435.120000,716918.940000 L435.419990,716918.940000 L435.419990,716878.140000 '></path><path style='stroke:black' d='M417.960000,716878.260000 L417.960000,716909.760000 L418.260020,716909.760000 L418.260020,716878.260000 '></path><path style='stroke:black' d='M168.360000,716878.319960 L168.360000,716878.800000 L439.200000,716878.800000 L439.200000,716878.319960 '></path><path style='stroke:black' d='M409.560000,716878.380000 L409.560000,716900.820000 L409.860020,716900.820000 L409.860020,716878.380000 '></path><path style='stroke:black' d='M370.680000,716900.700010 L370.680000,716901.000000 L409.860000,716901.000000 L409.860000,716900.700010 '></path><path style='stroke:black' d='M372.480000,716909.640010 L372.480000,716909.940000 L418.260000,716909.940000 L418.260000,716909.640010 '></path><path style='stroke:black' d='M276.120000,716918.819950 L276.120000,716919.120000 L435.420000,716919.120000 L435.420000,716918.819950 '></path><text y='716866.607484' x='269.82' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='34.179936'>Reserved</text></svg><h3>Figure 4-20.  Bit Control Fields of Immediate Byte for ROUNDxx Instruction</h3><h3>Table 4-15.  Rounding Modes and Encoding of Rounding Control (RC) Field</h3><table><tr><th>Rounding Mode</th><th>RC Field Setting</th><th>Description</th></tr><tr><td>Round to nearest (even)</td><td>00B</td><td>Rounded result is the closest to the infinitely precise result. If two values are equally close, the result is the even value (i.e., the integer value with the least-significant bit of zero).</td></tr><tr><td>Round down (toward −∞)</td><td>01B</td><td>Rounded result is closest to but no greater than the infinitely precise result.</td></tr><tr><td>Round up (toward +∞)</td><td>10B</td><td>Rounded result is closest to but no less than the infinitely precise result.</td></tr><tr><td>Round toward zero (Truncate)</td><td>11B</td><td>Rounded result is closest to but no greater in absolute value than the infinitely precise result.</td></tr></table></span>", "url": "ROUNDPD.html", "tooltip": "Round the 2 double-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single-precision floating-point value."},
    "MUL": {"html": "<p>Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location. The action of this instruction and the location of the result depends on the opcode and the operand size as shown in Table 3-66.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.</p><p>See the summary chart at the beginning of this section for encoding data and limits.</p><h3>Table 3-66.  MUL Results</h3><table><tr><th>Operand Size</th><th>Source 1</th><th>Source 2</th><th>Destination</th></tr><tr><td>Byte</td><td>AL</td><td>r/m8</td><td>AX</td></tr><tr><td>Word</td><td>AX</td><td>r/m16</td><td>DX:AX</td></tr><tr><td>Doubleword</td><td>EAX</td><td>r/m32</td><td>EDX:EAX</td></tr><tr><td>Quadword</td><td>RAX</td><td>r/m64</td><td>RDX:RAX</td></tr></table></span>", "url": "MUL.html", "tooltip": "Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location. The action of this instruction and the location of the result depends on the opcode and the operand size as shown in Table 3-66."},
    "SUBSD": {"html": "<p>Subtracts the low double-precision floating-point value in the source operand (second operand) from the low double-precision floating-point value in the destination operand (first operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "SUBSD.html", "tooltip": "Subtracts the low double-precision floating-point value in the source operand (second operand) from the low double-precision floating-point value in the destination operand (first operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar double-precision floating-point operation."},
    "PDEP": {"html": "<p>PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits from the first source operand and deposit them in the destination operand at the corresponding bit locations that are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>SRC1</p><p>S<sub>31 </sub>S<sub>30 </sub>S<sub>29 </sub>S<sub>28 </sub>S<sub>27</sub></p><p>S<sub>7</sub></p><p>S<sub>6</sub></p><p>S<sub>5</sub></p><p>S<sub>4</sub></p><p>S<sub>3</sub></p><p>S<sub>2</sub></p><p>S<sub>1</sub></p><p>S<sub>0</sub></p><p>SRC2</p><p>0</p><p>0</p><p>0</p><p>1</p><p>0</p><p>1</p><p>0</p><p>1</p><p>0</p><p>0</p><p>1</p><p>0</p><p>0</p><p>(mask)</p><p>DEST</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>0</p><p>S<sub>1</sub></p><p>S<sub>0</sub></p><p>S<sub>3</sub></p><p>S<sub>2</sub></p><p>bit 0</p><p>bit 31</p><h3>Figure 4-4.  PDEP Example</h3><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "PDEP.html", "tooltip": "PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits from the first source operand and deposit them in the destination operand at the corresponding bit locations that are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero."},
    "FCHS": {"html": "<p>Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magni-tude or vice versa. The following table shows the results obtained when changing the sign of various classes of numbers.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-30.  FCHS Results</h3><table><tr><th>ST(0) SRC</th><th>ST(0) DEST</th></tr><tr><td>− ∞</td><td>+ ∞</td></tr><tr><td>− F</td><td>+ F</td></tr><tr><td>− 0</td><td>+ 0</td></tr><tr><td>+ 0</td><td>− 0</td></tr><tr><td>+ F</td><td>− F</td></tr><tr><td>+ ∞</td><td>− ∞</td></tr><tr><td>NaN</td><td>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>*</p><p>F means finite floating-point value.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FCHS.html", "tooltip": "Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magni-tude or vice versa. The following table shows the results obtained when changing the sign of various classes of numbers."},
    "Jcc": {"html": "<p>Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (<em>cc</em>) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the J<em>cc </em>instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-tion pointer in the EIP register). A relative offset (<em>rel8</em>, <em>rel16,</em> or <em>rel32</em>) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.</p><p>The conditions for each J<em>cc</em> mnemonic are given in the 'Description” column of the table on the preceding page. The terms 'less” and 'greater” are used for comparisons of signed integers and the terms 'above” and 'below” are used for unsigned integers.</p><p>Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.</p><p>The J<em>cc</em> instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the J<em>cc</em> instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:</p><p>JZ FARLABEL;</p><p>To accomplish this far jump, use the following two instructions:</p><p>JNZ BEYOND;</p><p>JMP FARLABEL;</p><p>BEYOND:</p><p>The JRCXZ, JECXZ and JCXZ instructions differ from other J<em>cc</em> instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 2<sup>64</sup>, 2<sup>32</sup> or 64K times (not zero times).</p><p>All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.</p><p>In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</p></span>", "url": "Jcc.html", "tooltip": "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (<em>cc</em>) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the J<em>cc </em>instruction."},
    "VPGATHERDD": {"html": "<p>The instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-fied by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.</p><p>Using qword indices, the instruction conditionally loads up to 2 or 4 dword values from the VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destina-tion register are zero’ed with qword indices.</p><p>This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set).  When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero.  If any traps or interrupts are pending from already gath-ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.</p><p>If the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered.  This instruction sets those parts to zero.  It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.</p><p>VEX.128 version: For dword indices, the instruction will gather four dword values.  For qword indices, the instruc-tion will gather two values and zeroes the upper 64 bits of the destination.</p><p>VEX.256 version: For dword indices, the instruction will gather eight dword values.  For qword indices, the instruc-tion will gather four values and zeroes the upper 128 bits of the destination.</p><p>Note that:</p></span>", "url": "VPGATHERDD:VPGATHERQD.html", "tooltip": "The instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor."},
    "VFMSUB132PD": {"html": "<p>Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMSUB132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, subtracts the two or four packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFMSUB213PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infi-nite precision intermediate result, subtracts the two or four packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFMSUB231PD: Multiplies the two or four packed double-precision floating-point values from the second source to the two or four packed double-precision floating-point values in the third source operand. From the infinite preci-sion intermediate result, subtracts the two or four packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMSUB132PD:VFMSUB213PD:VFMSUB231PD.html", "tooltip": "Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "FBLD": {"html": "<p>Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of −0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits (AH through FH). Attempting to load an invalid encoding produces an undefined result.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FBLD.html", "tooltip": "Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of −0."},
    "PSHUFLW": {"html": "<p>Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. The 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-12. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note that this instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.</p><p>Note: VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSHUFLW.html", "tooltip": "Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. The 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-12. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane."},
    "MOVMSKPS": {"html": "<p>Extracts the sign bits from the packed single-precision floating-point values in the source operand (second operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand beyond the mask are filled with zeros.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.</p><p>128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.</p><p>VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "MOVMSKPS.html", "tooltip": "Extracts the sign bits from the packed single-precision floating-point values in the source operand (second operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand beyond the mask are filled with zeros."},
    "XSAVES": {"html": "<p>Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The format of the XSAVE area is detailed in Section 13.4, 'XSAVE Area,” of <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>.</p><p>Section 13.10, 'Operation of XSAVES,” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em> provides a detailed description of the operation of the XSAVES instruction. The following items provide a high-level outline:</p><p>Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</p><p>1.</p><p>There is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, the init optimization does not apply and XSAVEC will save SSE state as long as RFBM[1] = 1 and the modified optimization is not being applied.</p><p>2.</p><p>There is an exception for state component 1 (SSE). MXCSR is part of SSE state, but XINUSE[1] may be 0 even if MXCSR does not have its initial value of 1F80H. In this case, XSAVES sets XSTATE_BV[1] to 1 as long as RFBM[1] = 1.</p></span>", "url": "XSAVES.html", "tooltip": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0."},
    "ROUNDSD": {"html": "<p>Round the DP FP value in the lower qword of the source operand (second operand) using the rounding mode spec-ified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a double-precision floating-point input to an integer value and returns the integer result as a double precision floating-point value in the lowest position. The upper double precision floating-point value in the destination is retained.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-20. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-15 lists the encoded values for rounding-mode field).</p><p>The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "ROUNDSD.html", "tooltip": "Round the DP FP value in the lower qword of the source operand (second operand) using the rounding mode spec-ified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a double-precision floating-point input to an integer value and returns the integer result as a double precision floating-point value in the lowest position. The upper double precision floating-point value in the destination is retained."},
    "HSUBPS": {"html": "<p>Subtracts the single-precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and stores the result in the first dword of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Subtracts the single-precision floating-point value in the fourth dword of the destination operand from the third dword of the destination operand and stores the result in the second dword of the destination operand.</p><p>Subtracts the single-precision floating-point value in the second dword of the source operand from the first dword of the source operand and stores the result in the third dword of the destination operand.</p><p>Subtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword of the source operand and stores the result in the fourth dword of the destination operand.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>See Figure 3-21 for HSUBPS; see Figure 3-22 for VHSUBPS.</p><svg width='558.09' viewBox='115.440000 294723.000000 372.060000 239.700000' height='359.55'><text y='294741.682214' x='231.2468' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='105.3559507'>HSUBPS xmm1, xmm2/m128</text><text y='294762.195814' x='434.4048' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.0009'>xmm2/</text><text y='294766.996314' x='176.6646' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='294766.996314' x='246.9424' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='294766.996314' x='314.4451' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='294766.996314' x='384.1678' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='294771.796114' x='434.4048' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0087503'>m128</text><text y='294826.392114' x='434.4048' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='294826.392514' x='176.6646' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='294826.392514' x='246.9424' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='294826.392514' x='314.4451' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='294826.392514' x='384.1678' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='294885.243914' x='171.7344' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.008773'>xmm2/m128</text><text y='294885.243914' x='239.8121' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.008773'>xmm2/m128</text><text y='294889.863814' x='434.4048' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='32.3052114'>RESULT:</text><text y='294890.044214' x='304.1747' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='46.481743'>xmm1[95:64] -</text><text y='294890.044214' x='373.6374' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='42.437955'>xmm1[31:0] -</text><text y='294894.844314' x='166.644' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='50.525531'>[95:64] - xmm2/</text><text y='294894.844314' x='236.6818' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='46.481743'>[31:0] - xmm2/</text><text y='294899.464114' x='434.4048' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='294899.644614' x='304.3747' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='46.081728'>xmm1[127:96]</text><text y='294899.644614' x='373.8272' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='42.03794'>xmm1[63:32]</text><text y='294904.444614' x='169.5641' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='44.474395'>m128[127:96]</text><text y='294904.444614' x='239.6019' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.430607'>m128[63:32]</text><text y='294929.052814' x='177.2198' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='294929.052814' x='246.95281489' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='294929.052814' x='309.9545' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='294929.052814' x='388.677452' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='294954.061009' x='456.4347' style='font-size:6.000100pt' lengthAdjust='spacingAndGlyphs' textLength='26.3464391'>OM15996</text><rect y='294723.723' x='120.792' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='216.009' width='361.139'></rect><rect y='294723.723' x='120.792' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='216.009' width='361.139'></rect><path style='stroke:black' d='M259.173000,294777.725000 L259.173000,294788.975000 L135.418000,294788.975000 L135.418000,294858.728000 L191.670000,294858.728000 L191.670000,294864.548000 '></path><path style='stroke:black' d='M394.179000,294777.725000 L394.179000,294799.096000 L146.669000,294799.096000 L146.669000,294854.228000 L259.174000,294854.228000 L259.174000,294864.548000 '></path><path style='stroke:black' d='M191.107000,294777.725000 L191.107000,294788.975000 '></path><path style='stroke:black' d='M326.676000,294777.725000 L326.676000,294799.106000 '></path><path style='stroke:black' d='M259.173000,294849.728000 L259.173000,294837.118000 '></path><path style='stroke:black' d='M191.670000,294837.122000 L191.670000,294849.733000 L326.675000,294849.733000 L326.675000,294864.413000 '></path><path style='stroke:black' d='M326.676000,294837.122000 L326.676000,294845.232000 L394.179000,294845.232000 L394.179000,294864.413000 '></path><path style='stroke:black' d='M394.178000,294847.347000 L394.178000,294837.127000 '></path><path style='stroke:black' d='M328.716000,294864.413000 L326.676000,294868.493000 L324.636000,294864.413000 L328.716000,294864.413000 '></path><path style='stroke:black' d='M396.218000,294864.413000 L394.178000,294868.493000 L392.138000,294864.413000 L396.218000,294864.413000 '></path><path style='stroke:black' d='M193.710000,294864.549000 L191.670000,294868.629000 L189.630000,294864.549000 L193.710000,294864.549000 '></path><path style='stroke:black' d='M261.213000,294864.549000 L259.173000,294868.629000 L257.133000,294864.549000 L261.213000,294864.549000 '></path><rect y='294750.724' x='360.427' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294810.121' x='360.427' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294750.724' x='225.422' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294810.121' x='225.422' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294750.724' x='292.924' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294810.121' x='292.924' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294750.724' x='156.794' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='294810.121' x='156.794' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='294868.492' x='360.427' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='294868.492' x='225.422' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='294868.492' x='292.924' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='294868.492' x='156.794' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='68.628'></rect><rect y='294750.724' x='360.427' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294810.121' x='360.427' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294750.724' x='225.422' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294810.121' x='225.422' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294750.724' x='292.924' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294810.121' x='292.924' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='294750.724' x='156.794' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='294810.121' x='156.794' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='294868.492' x='360.427' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='294868.492' x='225.422' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='294868.492' x='292.924' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='294868.492' x='156.794' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='68.628'></rect></svg><h3>Figure 3-21.  HSUBPS—Packed Single-FP Horizontal Subtract</h3><p>X7</p><p>X6</p><p>X5</p><p>X4</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>SRC1</p><p>Y7</p><p>Y6</p><p>Y5</p><p>Y4</p><p>Y3</p><p>Y2</p><p>Y1</p><p>Y0</p><p>SRC2</p><p>DEST</p><p>Y6-Y7</p><p>Y4-Y5</p><p>X6-X7</p><p>X4-X5</p><p>Y2-Y3</p><p>X2-X3</p><p>X0-X1</p><h3>Figure 3-22.  VHSUBPS operation</h3><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "HSUBPS.html", "tooltip": "Subtracts the single-precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and stores the result in the first dword of the destination operand."},
    "MOVLPD": {"html": "<p>This instruction cannot be used for register to register or memory to memory moves.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p><strong>128-bit Legacy SSE load:</strong></p><p>Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. The upper 128-bits of the corresponding YMM destination register are preserved.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p><strong>VEX.128 encoded load:</strong></p><p>Loads a double-precision floating-point value from the source 64-bit memory operand (third operand), merges it with the upper 64-bits of the first source XMM register (second operand), and stores it in the low 128-bits of the destination XMM register (first operand). The upper 128-bits of the destination YMM register are zeroed.</p><p><strong>128-bit store:</strong></p><p>Stores a double-precision floating-point value from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).</p><p>Note: VMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as the existing 66 0F 13 store. For VMOVLPD (store) (VEX.128.66.0F 13 /r) instruction version, VEX.vvvv is reserved and must be 1111b other-wise instruction will #UD.</p><p>If VMOVLPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "MOVLPD.html", "tooltip": "This instruction cannot be used for register to register or memory to memory moves."},
    "MOVDQU": {"html": "<p>128-bit versions:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand may be unaligned on a 16-byte boundary without causing a general-protection exception (#GP) to be generated.<sup>1</sup></p><p>To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the MOVDQA instruction.</p><p>While executing in 16-bit addressing mode, a linear address for a 128-bit data access that overlaps the end of a 16-bit segment is not allowed and is defined as reserved behavior. A specific processor implementation may or may not generate a general-protection exception (#GP) in this situation, and the address that spans the end of the segment may or may not wrap around to the beginning of the segment.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>When the source or destination operand is a memory operand, the operand may be unaligned to any alignment without causing a general-protection exception (#GP) to be generated</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory</p><p>1.</p><p>If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an alignment-check exception (#AC) may or may not be generated (depending on processor implementation) when the operand is not aligned on an 8-byte boundary.</p><p>location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "MOVDQU.html", "tooltip": "128-bit versions:"},
    "MOV-2": {"html": "<p>Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose register or vice versa. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. (See Section 17.2, 'Debug Registers”, of the <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 3A</em>, for a detailed description of the flags and fields in the debug registers.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The instructions must be executed at privilege level 0 or in real-address mode.</p><p>When the debug extension (DE) flag in register CR4 is clear, these instructions operate on debug registers in a manner that is compatible with Intel386 and Intel486 processors. In this mode, references to DR4 and DR5 refer to DR6 and DR7, respectively. When the DE flag in CR4 is set, attempts to reference DR4 and DR5 result in an undefined opcode (#UD) exception. (The CR4 register was added to the IA-32 Architecture beginning with the Pentium processor.)</p><p>At the opcode level, the <em>reg</em> field within the ModR/M byte specifies which of the debug registers is loaded or read. The two bits in the <em>mod </em>field are ignored. The <em>r/m</em> field specifies the general-purpose register loaded or read.</p><p>In 64-bit mode, the instruction’s default operation size is 64 bits. Use of the REX.B prefix permits access to addi-tional registers (R8–R15). Use of the REX.W or 66H prefix is ignored. Use of the REX.R prefix causes an invalid-opcode exception. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOV-2.html", "tooltip": "Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose register or vice versa. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. (See Section 17.2, 'Debug Registers”, of the <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 3A</em>, for a detailed description of the flags and fields in the debug registers.)"},
    "POPA": {"html": "<p>Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attri-bute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used (using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms (POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment’s segment descriptor determines the operand-size attribute.)</p><p>This instruction executes as described in non-64-bit modes. It is not valid in 64-bit mode.</p></span>", "url": "POPA:POPAD.html", "tooltip": "Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI, SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP register is incremented after each register is loaded."},
    "BSR": {"html": "<p>Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "BSR.html", "tooltip": "Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined."},
    "PINSRB": {"html": "<p>Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the desti-nation register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destina-tion operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, other-wise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.</p></span>", "url": "PINSRB:PINSRD:PINSRQ.html", "tooltip": "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the desti-nation register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destina-tion operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location."},
    "ENTER": {"html": "<p>Creates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that is, the number of bytes of dynamic storage allocated on the stack for the procedure). The second operand (nesting level operand) gives the lexical nesting level (0 to 31) of the procedure. The nesting level determines the number of stack frame pointers that are copied into the 'display area” of the new stack frame from the preceding frame. Both of these operands are immediate values.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The stack-size attribute determines whether the BP (16 bits), EBP (32 bits), or RBP (64 bits) register specifies the current frame pointer and whether SP (16 bits), ESP (32 bits), or RSP (64 bits) specifies the stack pointer. In 64-bit mode, stack-size attribute is always 64-bits.</p><p>The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame.</p><p>If the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack, copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These additional frame pointers provide the called procedure with access points to other nested frames on the stack. See 'Procedure Calls for Block-Structured Languages” in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more information about the actions of the ENTER instruction.</p><p>The ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the current stack segment) would do so.</p><p>In 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded.</p></span>", "url": "ENTER.html", "tooltip": "Creates a stack frame for a procedure. The first operand (size operand) specifies the size of the stack frame (that is, the number of bytes of dynamic storage allocated on the stack for the procedure). The second operand (nesting level operand) gives the lexical nesting level (0 to 31) of the procedure. The nesting level determines the number of stack frame pointers that are copied into the 'display area” of the new stack frame from the preceding frame. Both of these operands are immediate values."},
    "BTR": {"html": "<p>Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>See also: <strong>Bit(BitBase, BitOffset) </strong>on page 3-10.</p><p>Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-tion with the displacement field of the memory operand. See 'BT—Bit Test” in this chapter for more information on this addressing mechanism.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "BTR.html", "tooltip": "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:"},
    "PINSRW": {"html": "<p>Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other words in the destination register are left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, other-wise the instruction will #UD.</p></span>", "url": "PINSRW.html", "tooltip": "Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other words in the destination register are left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location."},
    "VMASKMOV": {"html": "<p>Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.</p><p>The second source operand is a memory address for the load form of these instruction. The destination operand is a memory address for the store form of these instructions. The other operands are both XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).</p><p>Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.</p><p>Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.</p><p>Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.</p><p>VMASKMOV should not be used to access memory mapped I/O and un-cached memory as the access and the ordering of the individual loads or stores it does is implementation specific.</p><p>In cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an imple-mentation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.</p><p>Note: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.</p><p>Note: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field.</p></span>", "url": "VMASKMOV.html", "tooltip": "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand."},
    "CLC": {"html": "<p>Clears the CF flag in the EFLAGS register. Operation is the same in all modes.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "CLC.html", "tooltip": "Clears the CF flag in the EFLAGS register. Operation is the same in all modes."},
    "POPF": {"html": "<p>Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD instructions.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD. Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to determine the size of values to pop from the stack.</p><p>The effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See the Table 4-12 and key below for details.</p><p>When operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equiv-alent to privilege level 0), all non-reserved flags in the EFLAGS register except RF<sup>1</sup>, VIP, VIF, and VM may be modi-fied. VIP, VIF and VM remain unaffected.</p><p>When operating in protected, compatibility, or 64-bit mode with a privilege level greater than 0, but less than or equal to IOPL, all flags can be modified except the IOPL field and RF<sup>1</sup>, IF, VIP, VIF, and VM; these remain unaf-fected. The AC and ID flags can only be modified if the operand-size attribute is 32. The interrupt flag (IF) is altered only when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insufficient privilege, an exception does not occur but privileged bits do not change.</p><p>When operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0), the POPF/POPFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), POPF (but not POPFD) can be executed in virtual-8086 mode with IOPL &lt; 3.</p><p>In 64-bit mode, use REX.W to pop the top of stack to RFLAGS. The mnemonic assigned is POPFQ (note that the 32-bit operand is not encodable). POPFQ pops 64 bits from the stack, loads the lower 32 bits into RFLAGS, and zero extends the upper bits of RFLAGS.</p><p>See Chapter 3 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for more informa-tion about the EFLAGS registers.</p><p>1.</p><p>RF is always zero after the execution of POPF. This is because POPF, like all instructions, clears RF as it begins to execute.</p><h3>Table 4-12.  Effect of POPF/POPFD on the EFLAGS Register</h3><svg width='770.76' viewBox='45.119990 614673.000010 513.840000 300.000000' height='450.0'><text y='614683.11282' x='351.0596' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='19.043472'>Flags</text><text y='614693.13252' x='64.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='19.580526'>Mode</text><text y='614693.13252' x='108.175488' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='30.391032'>Operand</text><text y='614693.13252' x='147.9598' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='13.248396'>CPL</text><text y='614693.13252' x='171.004444' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.309524'>IOPL</text><rect y='614718.0' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614718.0' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614718.0' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614718.0' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614718.0' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614718.0' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614718.0' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614718.0' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614718.0' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614718.0' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614718.0' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614718.0' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614718.0' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614718.0' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614718.0' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614718.0' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614733.0' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='19.8'></rect><rect y='614733.0' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='20.4'></rect><rect y='614733.0' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='21.0'></rect><rect y='614733.0' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='18.84'></rect><rect y='614733.0' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='19.98'></rect><rect y='614733.0' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='19.2'></rect><rect y='614733.0' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='30.6'></rect><rect y='614733.0' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='19.8'></rect><rect y='614733.0' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='19.8'></rect><rect y='614733.0' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='18.0'></rect><rect y='614733.0' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='18.3'></rect><rect y='614733.0' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='17.7'></rect><rect y='614733.0' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='17.4'></rect><rect y='614733.0' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='18.6'></rect><rect y='614733.0' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='19.8'></rect><rect y='614733.0' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='19.98' width='18.6'></rect><rect y='614752.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614752.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614752.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614752.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614752.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614752.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614752.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614752.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614752.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614752.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614752.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614752.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614752.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614752.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614752.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614752.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614767.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614767.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614767.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614767.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614767.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614767.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614767.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614767.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614767.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614767.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614767.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614767.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614767.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614767.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614767.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614767.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614782.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614782.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614782.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614782.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614782.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614782.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614782.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614782.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614782.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614782.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614782.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614782.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614782.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614782.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614782.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614782.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614797.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614797.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614797.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614797.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614797.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614797.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614797.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614797.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614797.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614797.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614797.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614797.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614797.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614797.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614797.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614797.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614812.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614812.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614812.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614812.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614812.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614812.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614812.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614812.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614812.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614812.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614812.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614812.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614812.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614812.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614812.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614812.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614827.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614827.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614827.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614827.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614827.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614827.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614827.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614827.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614827.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614827.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614827.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614827.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614827.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614827.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614827.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614827.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614842.98' x='103.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='39.54'></rect><rect y='614842.98' x='143.16' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='22.86'></rect><rect y='614842.98' x='166.02' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='26.22'></rect><rect y='614842.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614842.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614842.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614842.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614842.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614842.98' x='292.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614842.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614842.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614842.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614842.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614842.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614842.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614842.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614842.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614842.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614842.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614842.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614857.98' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='19.8'></rect><rect y='614857.98' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='20.4'></rect><rect y='614857.98' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='21.0'></rect><rect y='614857.98' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='18.84'></rect><rect y='614857.98' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='19.98'></rect><rect y='614857.98' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='19.2'></rect><rect y='614857.98' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='30.6'></rect><rect y='614857.98' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='19.8'></rect><rect y='614857.98' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='19.8'></rect><rect y='614857.98' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='18.0'></rect><rect y='614857.98' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='18.3'></rect><rect y='614857.98' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='17.7'></rect><rect y='614857.98' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='17.4'></rect><rect y='614857.98' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='18.6'></rect><rect y='614857.98' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='19.8'></rect><rect y='614857.98' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0600000001' width='18.6'></rect><rect y='614873.04' x='103.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='39.54'></rect><rect y='614873.04' x='143.16' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='22.86'></rect><rect y='614873.04' x='166.02' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='26.22'></rect><rect y='614873.04' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614873.04' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614873.04' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614873.04' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614873.04' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614873.04' x='292.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614873.04' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614873.04' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614873.04' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614873.04' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614873.04' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614873.04' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614873.04' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614873.04' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614873.04' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614873.04' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614873.04' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614888.04' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614888.04' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614888.04' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614888.04' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614888.04' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614888.04' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614888.04' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614888.04' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614888.04' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614888.04' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614888.04' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614888.04' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614888.04' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614888.04' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614888.04' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614888.04' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614903.04' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='19.8'></rect><rect y='614903.04' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='20.4'></rect><rect y='614903.04' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='21.0'></rect><rect y='614903.04' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='18.84'></rect><rect y='614903.04' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='19.98'></rect><rect y='614903.04' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='19.2'></rect><rect y='614903.04' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='30.6'></rect><rect y='614903.04' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='19.8'></rect><rect y='614903.04' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='19.8'></rect><rect y='614903.04' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='18.0'></rect><rect y='614903.04' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='18.3'></rect><rect y='614903.04' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='17.7'></rect><rect y='614903.04' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='17.4'></rect><rect y='614903.04' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='18.6'></rect><rect y='614903.04' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='19.8'></rect><rect y='614903.04' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='24.96' width='18.6'></rect><rect y='614928.0' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614928.0' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614928.0' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614928.0' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614928.0' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614928.0' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614928.0' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614928.0' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614928.0' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614928.0' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614928.0' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614928.0' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614928.0' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614928.0' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614928.0' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614928.0' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614943.0' x='103.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='39.54'></rect><rect y='614943.0' x='143.16' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='22.86'></rect><rect y='614943.0' x='166.02' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='26.22'></rect><rect y='614943.0' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614943.0' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614943.0' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614943.0' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614943.0' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614943.0' x='292.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614943.0' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614943.0' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614943.0' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614943.0' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614943.0' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614943.0' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614943.0' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614943.0' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614943.0' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614943.0' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614943.0' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614958.0' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614958.0' x='212.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='20.4'></rect><rect y='614958.0' x='232.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='21.0'></rect><rect y='614958.0' x='253.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.84'></rect><rect y='614958.0' x='272.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.98'></rect><rect y='614958.0' x='311.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.2'></rect><rect y='614958.0' x='330.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='30.6'></rect><rect y='614958.0' x='360.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614958.0' x='380.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614958.0' x='400.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.0'></rect><rect y='614958.0' x='418.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.3'></rect><rect y='614958.0' x='436.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.7'></rect><rect y='614958.0' x='454.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='17.4'></rect><rect y='614958.0' x='471.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><rect y='614958.0' x='490.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='19.8'></rect><rect y='614958.0' x='510.3' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.0' width='18.6'></rect><text y='614728.142744' x='199.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614728.142744' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614728.142744' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614728.142744' x='260.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614728.142744' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614728.142744' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='343.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614728.142744' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='200.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614743.142744' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614743.142744' x='260.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614743.142744' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='343.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614743.142744' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='199.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614763.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614763.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614763.182844' x='260.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614763.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614763.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='343.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614763.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='199.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614778.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614778.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614778.182844' x='260.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614778.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614778.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614778.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='406.92' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614778.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614778.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='199.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614793.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614793.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614793.182844' x='260.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614793.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614793.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614793.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614793.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='200.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614808.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614808.182844' x='260.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614808.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='343.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614808.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='200.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614823.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614823.182844' x='260.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614823.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614823.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='406.92' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614823.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614823.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='200.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614838.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614838.182844' x='260.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614838.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614838.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614838.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614853.182844' x='118.74' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.34857'>16</text><text y='614853.182844' x='152.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.6683'>3</text><text y='614853.182844' x='173.22' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='11.869452'>0-2</text><text y='614853.182844' x='199.62' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='219.72' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='240.42' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='260.34' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='279.78' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='299.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='318.18' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='343.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='368.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='388.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='406.98' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='425.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='443.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='460.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='478.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='497.8799' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614853.182844' x='517.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614868.182844' x='199.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614868.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614868.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614868.182844' x='260.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614868.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614868.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614868.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614868.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614883.182844' x='118.74' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.34857'>32</text><text y='614883.182844' x='152.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.6683'>3</text><text y='614883.182844' x='173.22' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='11.869452'>0-2</text><text y='614883.182844' x='199.62' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='219.72' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='240.42' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='260.34' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='279.78' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='299.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='318.18' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='343.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='368.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='388.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='406.98' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='425.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='443.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='460.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='478.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='497.8799' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614883.182844' x='517.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614898.182844' x='200.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614898.182844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614898.182844' x='260.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614898.182844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614898.182844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614898.182844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614913.182844' x='198.18' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.937706'>N/</text><text y='614923.142644' x='199.6204' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='218.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.937706'>N/</text><text y='614923.142644' x='219.7204' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='237.0' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='11.89818'>SV/</text><text y='614923.142644' x='240.4202' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='258.9' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.937706'>N/</text><text y='614923.142644' x='260.3404' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='278.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.997556'>N/</text><text y='614923.142644' x='279.7802' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='317.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.039158'>S/</text><text y='614923.142644' x='318.1798' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='339.06' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='12.994632'>N/X</text><text y='614913.182844' x='367.26' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.039158'>S/</text><text y='614923.142644' x='368.2798' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='387.06' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.039158'>S/</text><text y='614923.142644' x='388.0798' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='405.48' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.997556'>N/</text><text y='614923.142644' x='406.9802' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='424.14' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.039158'>S/</text><text y='614923.142644' x='425.1598' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='442.14' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.039158'>S/</text><text y='614923.142644' x='443.1598' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='459.72' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='6.979308'>S/</text><text y='614923.142644' x='460.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='477.72' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='6.979308'>S/</text><text y='614923.142644' x='478.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='496.92' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='6.979308'>S/</text><text y='614923.142644' x='497.88' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614913.182844' x='516.1199' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='7.039158'>S/</text><text y='614923.142644' x='517.0799' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614938.142844' x='199.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614938.142844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614938.142844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614938.142844' x='260.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614938.142844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614938.142844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614938.142844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614938.142844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614953.142844' x='118.74' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.34857'>32</text><text y='614953.142844' x='152.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.6683'>3</text><text y='614953.142844' x='173.22' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='11.869452'>0-2</text><text y='614953.142844' x='199.62' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='219.72' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='240.42' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='260.34' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='279.78' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='299.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='318.18' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='343.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='368.28' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='388.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='406.98' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='425.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='443.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='460.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='478.68' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='497.8799' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614953.142844' x='517.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.01942'>X</text><text y='614968.142844' x='200.04' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='219.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614968.142844' x='240.36' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614968.142844' x='260.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='279.66' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614968.142844' x='318.54' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='342.96' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='5.187'>N</text><text y='614968.142844' x='368.64' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='388.44' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='407.4' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='425.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='443.52' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='461.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='479.1' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='498.2999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text><text y='614968.142844' x='517.4999' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='4.23738'>S</text></svg><p><strong>Notes</strong></p><p><strong>21</strong></p><p><strong>20</strong></p><p><strong>19</strong></p><p><strong>18</strong></p><p><strong>17</strong></p><p><strong>16</strong></p><p><strong>14</strong></p><p><strong>13:12</strong></p><p><strong>11</strong></p><p><strong>10</strong></p><p><strong>9</strong></p><p><strong>8</strong></p><p><strong>7</strong></p><p><strong>6</strong></p><p><strong>4</strong></p><p><strong>2</strong></p><p><strong>0</strong></p><p><strong>Size</strong></p><p><strong>ID</strong></p><p><strong>VIP</strong></p><p><strong>VIF</strong></p><p><strong>AC</strong></p><p><strong>VM</strong></p><p><strong>RF</strong></p><p><strong>NT</strong></p><p><strong>IOPL</strong></p><p><strong>OF</strong></p><p><strong>DF</strong></p><p><strong>IF</strong></p><p><strong>TF</strong></p><p><strong>SF</strong></p><p><strong>ZF</strong></p><p><strong>AF</strong></p><p><strong>PF</strong></p><p><strong>CF</strong></p><p><strong>Real-Address</strong></p><p>16</p><p>0</p><p>0-3</p><p>0</p><p><strong>Mode (CR0.PE</strong></p><p>32</p><p>0</p><p>0-3</p><p>0</p><p><strong>= 0)</strong></p><p><strong>Protected,</strong></p><p>16</p><p>0</p><p>0-3</p><p>0</p><p><strong>Compatibility,</strong></p><p>16</p><p>1-3</p><p>&lt;CPL</p><p>0</p><p><strong>and 64-Bit</strong></p><p><strong>Modes</strong></p><p>16</p><p>1-3</p><p>≥CPL</p><p>0</p><p>32, 64</p><p>0</p><p>0-3</p><p>0</p><p><strong>(CR0.PE = 1, EFLAGS.VM =</strong></p><p>32, 64</p><p>1-3</p><p>&lt;CPL</p><p>0</p><p><strong>0)</strong></p><p>32, 64</p><p>1-3</p><p>≥CPL</p><p>0</p><p>1</p><p><strong>Virtual-8086 (CR0.PE = 1,</strong></p><p>16</p><p>3</p><p>3</p><p>0</p><p><strong>EFLAGS.VM =</strong></p><p>1</p><p><strong>1,</strong></p><p><strong>CR4.VME = 0)</strong></p><p>32</p><p>3</p><p>3</p><p>0</p><p>2</p><p><strong>VME</strong></p><p>16</p><p>3</p><p>0-2</p><p>0/</p><p><strong>(CR0.PE = 1,</strong></p><p>X</p><p><strong>EFLAGS.VM =</strong></p><p>16</p><p>3</p><p>3</p><p>0</p><p><strong>1,</strong></p><p>1</p><p><strong>CR4.VME = 1)</strong></p><p>32</p><p>3</p><p>3</p><p>0</p><p><strong>NOTES:</strong></p><p>1. #GP fault - no flag update</p><p>2. #GP fault with no flag update if VIP=1 in EFLAGS register and IF=1 in FLAGS value on stack</p><svg width='416.7900225' viewBox='45.119990 615030.419995 277.860015 96.000000' height='144.0'><text y='615041.166' x='176.52' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='15.1236'>Key</text><rect y='615046.38' x='45.12' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='16.02' width='58.5'></rect><text y='615057.2202' x='107.6397' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='74.4759'>Updated from stack</text><rect y='615062.4' x='45.12' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='16.02' width='58.5'></rect><text y='615073.1802' x='107.6397' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='178.479'>Updated from IF (bit 9) in FLAGS value on stack</text><rect y='615078.42' x='45.12' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='15.96' width='58.5'></rect><text y='615089.2002' x='107.64' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='71.5752'>No change in value</text><rect y='615094.38' x='45.12' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='16.02' width='58.5'></rect><text y='615105.2202' x='107.64' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='70.839'>No EFLAGS update</text><text y='615121.1457' x='71.64' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='5.535'>0</text><text y='615121.1799' x='107.64' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='59.04'>Value is cleared</text><text y='615057.186' x='71.88' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='5.013'>S</text><text y='615073.146' x='69.0' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='10.7685'>SV</text><text y='615089.166' x='71.28' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='6.21'>N</text><text y='615105.186' x='71.46' style='font-size:9.000000pt' lengthAdjust='spacingAndGlyphs' textLength='5.796'>X</text></svg></span>", "url": "POPF:POPFD:POPFQ.html", "tooltip": "Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD instructions."},
    "PREFETCHW": {"html": "<p>Fetches the cache line of data from memory that contains the byte specified with the source operand to a location in the 1st or 2nd level cache and invalidates all other cached instances of the line.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand is a byte memory location. If the line selected is already present in the lowest level cache and is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are ignored.</p><p>The PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor and invalidates any other cached copy in anticipation of the line being written to in the future.</p><p>The characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.</p><p>It should be noted that processors are free to speculatively fetch and cache data with exclusive ownership from system memory regions that permit such accesses (that is, the WB memory type). A PREFETCHW instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHW instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHW instruction is also unordered with respect to CLFLUSH instructions, other PREFETCHW instructions, or any other general instruction</p><p>It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.</p><p>This instruction's operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "PREFETCHW.html", "tooltip": "Fetches the cache line of data from memory that contains the byte specified with the source operand to a location in the 1st or 2nd level cache and invalidates all other cached instances of the line."},
    "SLDT": {"html": "<p>Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The desti-nation operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be executed in protected mode.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Outside IA-32e mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon, and P6 family processors. They are undefined for Pentium, Intel486, and Intel386 processors. When the destina-tion operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.</p><p>In compatibility mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). The behavior of SLDT with a 64-bit register is to zero-extend the 16-bit selector and store it in the register. If the desti-nation is memory and operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit quantity, regardless of the operand size</p></span>", "url": "SLDT.html", "tooltip": "Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The desti-nation operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be executed in protected mode."},
    "ANDPS": {"html": "<p>Performs a bitwise logical AND of the four or eight packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "ANDPS.html", "tooltip": "Performs a bitwise logical AND of the four or eight packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand."},
    "MOVLPS": {"html": "<p>This instruction cannot be used for register to register or memory to memory moves.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p><strong>128-bit Legacy SSE load:</strong></p><p>Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. The upper 128-bits of the corresponding YMM destination register are preserved.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p><strong>VEX.128 encoded load:</strong></p><p>Loads two packed single-precision floating-point values from the source 64-bit memory operand (third operand), merges them with the upper 64-bits of the first source XMM register (second operand), and stores them in the low 128-bits of the destination XMM register (first operand). The upper 128-bits of the destination YMM register are zeroed.</p><p><strong>128-bit store:</strong></p><p>Loads two packed single-precision floating-point values from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).</p><p>Note: VMOVLPS (store) (VEX.128.0F 13 /r) is legal and has the same behavior as the existing 0F 13 store. For VMOVLPS (store) (VEX.128.0F 13 /r) instruction version, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.</p><p>If VMOVLPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "MOVLPS.html", "tooltip": "This instruction cannot be used for register to register or memory to memory moves."},
    "PADDUSB": {"html": "<p>Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destina-tion operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The (V)PADDUSB instruction adds packed unsigned byte integers. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destina-tion operand.</p><p>The (V)PADDUSW instruction adds packed unsigned word integers. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.</p><p>These instructions can operate on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX tech-</p><p>nology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PADDUSB:PADDUSW.html", "tooltip": "Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destina-tion operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs."},
    "FSCALE": {"html": "<p>Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of the destination operand. The destination and source operands are floating-point values located in registers ST(0) and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2. The following table shows the results obtained when scaling various classes of numbers, assuming that neither overflow nor underflow occurs.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-44.  FSCALE Results</h3><table><tr><th colspan='2'>ST(1)</th><th colspan='2'>ST(1)</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>ST(0)</th><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>− F</td><td colspan='2'>− F</td><td colspan='2'>− F</td><td colspan='2'>− F</td><td colspan='2'>− ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ F</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ F</td><td colspan='2'>+ F</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>In most cases, only the exponent is changed and the mantissa (significand) remains unchanged. However, when the value being scaled in ST(0) is a denormal value, the mantissa is also changed and the result may turn out to be a normalized number. Similarly, if overflow or underflow results from a scale operation, the resulting mantissa will differ from the source’s mantissa.</p><p>The FSCALE instruction can also be used to reverse the action of the FXTRACT instruction, as shown in the following example:</p><p>FXTRACT;</p><p>FSCALE;</p><p>FSTP ST(1);</p><p>In this example, the FXTRACT instruction extracts the significand and exponent from the value in ST(0) and stores them in ST(0) and ST(1) respectively. The FSCALE then scales the significand in ST(0) by the exponent in ST(1), recreating the original value before the FXTRACT operation was performed. The FSTP ST(1) instruction overwrites the exponent (extracted by the FXTRACT instruction) with the recreated value, which returns the stack to its orig-inal state with only one register [ST(0)] occupied.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSCALE.html", "tooltip": "Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of the destination operand. The destination and source operands are floating-point values located in registers ST(0) and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2. The following table shows the results obtained when scaling various classes of numbers, assuming that neither overflow nor underflow occurs."},
    "CVTPD2PS": {"html": "<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operation is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operation is a YMM register. The upper bits (VLMAX-1:64) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>SRC</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>DEST</p><p>0</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><h3>Figure 3-12.  VCVTPD2PS (VEX.256 encoded version)</h3></span>", "url": "CVTPD2PS.html", "tooltip": "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand)."},
    "MINSS": {"html": "<p>Compares the low single-precision floating-point values in the first source operand and the second source operand and returns the minimum value to the low doubleword of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source operand be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "MINSS.html", "tooltip": "Compares the low single-precision floating-point values in the first source operand and the second source operand and returns the minimum value to the low doubleword of the destination operand."},
    "RSM": {"html": "<p>Returns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SMM interrupt. The processor’s state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restora-tion, it enters the shutdown state. The following invalid information can cause a shutdown:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The contents of the model-specific registers are not affected by a return from SMM.</p><p>The SMM state map used by RSM supports resuming processor context for non-64-bit modes and 64-bit mode.</p><p>See Chapter 34, 'System Management Mode,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C</em>, for more information about SMM and the behavior of the RSM instruction.</p></span>", "url": "RSM.html", "tooltip": "Returns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SMM interrupt. The processor’s state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restora-tion, it enters the shutdown state. The following invalid information can cause a shutdown:"},
    "FLD1": {"html": "<p>Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log<sub>2</sub>10, log<sub>2</sub>e, π, log<sub>10</sub>2, and log<sub>e</sub>2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>See the section titled 'Pi” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for a description of the π constant.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html", "tooltip": "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log<sub>2</sub>10, log<sub>2</sub>e, π, log<sub>10</sub>2, and log<sub>e</sub>2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up."},
    "FUCOM": {"html": "<p>Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-51.  FUCOM/FUCOMP/FUCOMPP Results</h3><table><tr><th>Comparison Results*</th><th>C3</th><th>C2</th><th>C0</th></tr><tr><td>ST0 &gt; ST(i)</td><td>0</td><td>0</td><td>0</td></tr><tr><td>ST0 &lt; ST(i)</td><td>0</td><td>0</td><td>1</td></tr><tr><td>ST0 = ST(i)</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Unordered</td><td>1</td><td>1</td><td>1</td></tr></table><p><strong>NOTES:</strong></p><p>*</p><p>Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</p><p>An unordered comparison checks the class of the numbers being compared (see 'FXAM—Examine ModR/M” in this chapter). The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP instructions. The only difference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmetic-operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception when either or both of the operands are a NaN value of any kind or are in an unsupported format.</p><p>As with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic-operand exception being raised, the condition code flags are set only if the exception is masked.</p><p>The FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FUCOM:FUCOMP:FUCOMPP.html", "tooltip": "Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0."},
    "VEXTRACTF128": {"html": "<p>Extracts 128-bits of packed floating-point values from the source operand (second operand) at an 128-bit offset from imm8[0] into the destination operand (first operand). The destination may be either an XMM register or an 128-bit memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>The high 7 bits of the immediate are ignored.</p><p>If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception.</p></span>", "url": "VEXTRACTF128.html", "tooltip": "Extracts 128-bits of packed floating-point values from the source operand (second operand) at an 128-bit offset from imm8[0] into the destination operand (first operand). The destination may be either an XMM register or an 128-bit memory location."},
    "CALL": {"html": "<p>Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used to execute four types of calls:</p><p>The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See 'Calling Procedures Using Call and RET” in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for additional information on near, far, and inter-privilege-level calls. See Chapter 7, 'Task Management,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for infor-mation on performing task switches with the CALL instruction.</p><p><strong>Near Call. </strong>When executing a near call, the processor pushes the value of the EIP register (which contains the offset of the instruction following the CALL instruction) on the stack (for use later as a return-instruction pointer). The processor then branches to the address in the current code segment specified by the target operand. The target operand specifies either an absolute offset in the code segment (an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current value of the instruction pointer in the EIP register; this value points to the instruction following the CALL instruction). The CS register is not changed on near calls.</p><p>For a near call absolute, an absolute offset is specified indirectly in a general-purpose register or a memory location (<em>r/m16</em>, <em>r/m32, or r/m64</em>). The operand-size attribute determines the size of the target operand (16, 32 or 64 bits). When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits. Absolute offsets are loaded directly into the EIP(RIP) register. If the operand size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits. When accessing an absolute offset indirectly using the stack pointer [ESP] as the base register, the base value used is the value of the ESP before the instruction executes.</p><p>A relative offset (<em>rel16</em> or <em>rel32</em>) is generally specified as a label in assembly code. But at the machine code level, it is encoded as a signed, 16- or 32-bit immediate value. This value is added to the value in the EIP(RIP) register. In 64-bit mode the relative offset is always a 32-bit immediate value which is sign extended to 64-bits before it is added to the value in the RIP register for the target calculation. As with absolute offsets, the operand-size attribute determines the size of the target operand (16, 32, or 64 bits). In 64-bit mode the target operand will always be 64-bits because the operand size is forced to 64-bits for near branches.</p><p><strong>Far Calls in Real-Address or Virtual-8086 Mode.</strong> When executing a far call in real- address or virtual-8086 mode, the processor pushes the current value of both the CS and EIP registers on the stack for use as a return-instruction pointer. The processor then performs a 'far branch” to the code segment and offset specified with the target operand for the called procedure. The target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). With the pointer method, the segment and offset of the called procedure is encoded in the instruction using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address immediate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.</p><p><strong>Far Calls in Protected Mode.</strong> When the processor is operating in protected mode, the CALL instruction can be used to perform the following types of far calls:</p><p>In protected mode, the processor always uses the segment selector part of the far address to access the corre-sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of call operation to be performed.</p><p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The operand- size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register; the offset from the instruction is loaded into the EIP register.</p><p>A call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making calls between 16-bit and 32-bit code segments.</p><p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a call gate. The segment selector specified by the target operand identifies the call gate. The target</p><p>operand can specify the call gate segment selector either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p><p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, no stack switch occurs.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack, an optional set of parameters from the calling proce-dures stack, and the segment selector and instruction pointer for the calling procedure’s code segment. (A value in the call gate descriptor determines how many parameters to copy to the new stack.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p><p>Executing a task switch with the CALL instruction is similar to executing a call through a call gate. The target operand specifies the segment selector of the task gate for the new task activated by the switch (the offset in the target operand is ignored). The task gate in turn points to the TSS for the new task, which contains the segment selectors for the task’s code and stack segments. Note that the TSS also contains the EIP value for the next instruc-tion that was to be executed before the calling task was suspended. This instruction pointer value is loaded into the EIP register to re-start the calling task.</p><p>The CALL instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 7, 'Task Management,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for information on the mechanics of a task switch.</p><p>When you execute at task switch with a CALL instruction, the nested task flag (NT) is set in the EFLAGS register and the new TSS’s previous task link field is loaded with the old task’s TSS selector. Code is expected to suspend this nested task by executing an IRET instruction which, because the NT flag is set, automatically uses the previous task link to return to the calling task. (See 'Task Linking” in Chapter 7 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for information on nested tasks.) Switching tasks with the CALL instruc-tion differs in this regard from JMP instruction. JMP does not set the NT flag and therefore does not expect an IRET instruction to suspend the task.</p><p><strong>Mixing 16-Bit and 32-Bit Calls.</strong> When making far calls between 16-bit and 32-bit code segments, use a call gate. If the far call is from a 32-bit code segment to a 16-bit code segment, the call should be made from the first 64 KBytes of the 32-bit code segment. This is because the operand-size attribute of the instruction is set to 16, so only a 16-bit return address offset can be saved. Also, the call should be made using a 16-bit call gate so that 16-bit values can be pushed on the stack. See Chapter 21, 'Mixing 16-Bit and 32-Bit Code,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B</em>, for more information.</p><p><strong>Far Calls in Compatibility Mode.</strong> When the processor is operating in compatibility mode, the CALL instruction can be used to perform the following types of far calls:</p><p>Note that a CALL instruction can not be used to cause a task switch in compatibility mode since task switches are not supported in IA-32e mode.</p><p>In compatibility mode, the processor always uses the segment selector part of the far address to access the corre-sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.</p><p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in compatibility mode is very similar to one carried out in protected mode. The target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register and the offset from the instruction is loaded into the EIP register. The differ-ence is that 64-bit mode may be entered. This specified by the L bit in the new code segment descriptor.</p><p>Note that a 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the L bit set, causing an entry to 64-bit mode.</p><p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target operand can specify the call gate segment selector either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p><p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch. (Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. The full value of RSP is used for the offset, of which the upper 32-bits are undefined.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack and the segment selector and instruction pointer for the calling procedure’s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p><p><strong>Near/(Far) Calls in 64-bit Mode.</strong> When the processor is operating in 64-bit mode, the CALL instruction can be used to perform the following types of far calls:</p><p>Note that in this mode the CALL instruction can not be used to cause a task switch in 64-bit mode since task switches are not supported in IA-32e mode.</p><p>In 64-bit mode, the processor always uses the segment selector part of the far address to access the corresponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate) and access rights determine the type of call operation to be performed.</p><p>If the selected descriptor is for a code segment, a far call to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far call to the same privilege level in 64-bit mode is very similar to one carried out in compatibility mode. The target operand specifies an absolute far address indirectly with a memory location (<em>m16:16, m16:32</em> or <em>m16:64</em>). The form of CALL with a direct specification of absolute far address is not defined in 64-bit mode. The operand-size attribute determines the size of the offset (16, 32, or 64 bits) in the far address. The new code segment selector and its descriptor are loaded into the CS register; the offset from the instruction is loaded into the EIP register. The new code segment may specify entry either into compati-bility or 64-bit mode, based on the L bit value.</p><p>A 64-bit call gate (described in the next paragraph) can also be used to perform a far call to a code segment at the same privilege level. However, using this mechanism requires that the target code segment descriptor have the L bit set.</p><p>When executing an inter-privilege-level far call, the code segment for the procedure being called must be accessed through a 64-bit call gate. The segment selector specified by the target operand identifies the call gate. The target operand can only specify the call gate segment selector indirectly with a memory location (<em>m16:16, m16:32</em> or <em>m16:64</em>). The processor obtains the segment selector for the new code segment and the new instruction pointer (offset) from the 16-byte call gate descriptor. (The offset from the target operand is ignored when a call gate is used.)</p><p>On inter-privilege-level calls, the processor switches to the stack for the privilege level of the called procedure. The segment selector for the new stack segment is set to NULL. The new stack pointer is specified in the TSS for the currently running task. The branch to the new code segment occurs after the stack switch.</p><p>Note that when using a call gate to perform a far call to a segment at the same privilege level, an implicit stack switch occurs as a result of entering 64-bit mode. The SS selector is unchanged, but stack segment accesses use a segment base of 0x0, the limit is ignored, and the default stack size is 64-bits. (The full value of RSP is used for the</p><p>offset.) On the new stack, the processor pushes the segment selector and stack pointer for the calling procedure’s stack and the segment selector and instruction pointer for the calling procedure’s code segment. (Parameter copy is not supported in IA-32e mode.) Finally, the processor branches to the address of the procedure being called within the new code segment.</p></span>", "url": "CALL.html", "tooltip": "Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location."},
    "FLD": {"html": "<p>Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, double-precision, or double extended-precision floating-point format. If the source operand is in single-precision or double-precision floating-point format, it is automatically converted to the double extended-precision floating-point format before being pushed on the stack.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FLD.html", "tooltip": "Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, double-precision, or double extended-precision floating-point format. If the source operand is in single-precision or double-precision floating-point format, it is automatically converted to the double extended-precision floating-point format before being pushed on the stack."},
    "PCMPESTRM": {"html": "<p>The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and gener-ates a mask stored to XMM0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length repre-sents the number of bytes/words which are valid for the respective xmm/m128 data.</p><p>The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).</p><p>The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.</p><p>Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-tion:</p><p>CFlag – Reset if IntRes2 is equal to zero, set otherwise</p><p>ZFlag – Set if absolute-value of EDX is &lt; 16 (8), reset otherwise</p><p>SFlag – Set if absolute-value of EAX is &lt; 16 (8), reset otherwise</p><p>OFlag –IntRes2[0]</p><p>AFlag – Reset</p><p>PFlag – Reset</p><p>Note: In VEX.128 encoded versions, bits (VLMAX-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PCMPESTRM.html", "tooltip": "The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and gener-ates a mask stored to XMM0."},
    "PMINUD": {"html": "<p>Compares packed unsigned dword integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMINUD.html", "tooltip": "Compares packed unsigned dword integers in the destination operand (first operand) and the source operand (second operand), and returns the minimum for each packed value in the destination operand."},
    "FPATAN": {"html": "<p>Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +π.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently, not just on the sign of the ratio Y/X. This is because a point (−X,Y) is in the second quadrant, resulting in an angle between π/2 and π, while a point (X,−Y) is in the fourth quadrant, resulting in an angle between 0 and −π/2. A point (−X,−Y) is in the third quadrant, giving an angle between −π/2 and −π.</p><p>The following table shows the results obtained when computing the arctangent of various classes of numbers, assuming that underflow does not occur.</p><h3>Table 3-40.  FPATAN Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>ST(0)</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>− 0</td><td colspan='2'>+ 0</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>− 3π/4*</td><td colspan='2'>− π/2</td><td colspan='2'>− π/2</td><td colspan='2'>− π/2</td><td colspan='2'>− π/2</td><td colspan='2'>− π/4*</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>ST(1)</th><td colspan='2'>− F</td><td colspan='2'>-p</td><td colspan='2'>−π to −π/2</td><td colspan='2'>−π/2</td><td colspan='2'>−π/2</td><td colspan='2'>−π/2 to −0</td><td colspan='2'>- 0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− 0</td><td colspan='2'>-p</td><td colspan='2'>-p</td><td colspan='2'>-p*</td><td colspan='2'>− 0*</td><td colspan='2'>− 0</td><td colspan='2'>− 0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ 0</td><td colspan='2'>+p</td><td colspan='2'>+ p</td><td colspan='2'>+ π*</td><td colspan='2'>+ 0*</td><td colspan='2'>+ 0</td><td colspan='2'>+ 0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ F</td><td colspan='2'>+p</td><td colspan='2'>+π to +π/2</td><td colspan='2'>+ π/2</td><td colspan='2'>+π/2</td><td colspan='2'>+π/2 to +0</td><td colspan='2'>+ 0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ ∞</td><td colspan='2'>+3π/4*</td><td colspan='2'>+π/2</td><td colspan='2'>+π/2</td><td colspan='2'>+π/2</td><td colspan='2'>+ π/2</td><td colspan='2'>+ π/4*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Table 8-10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, specifies that the ratios 0/0 and ∞/∞ generate the floating-point invalid arithmetic-operation exception and, if this exception is masked, the floating-point QNaN indefi-nite value is returned. With the FPATAN instruction, the 0/0 or ∞/∞ value is actually not calculated using division. Instead, the arc-tangent of the two variables is derived from a standard mathematical formulation that is generalized to allow complex numbers as arguments. In this complex variable formulation, arctangent(0,0) etc. has well defined values. These values are needed to develop a library to compute transcendental functions with complex arguments, based on the FPU functions that only allow floating-point values as arguments.</p><p>There is no restriction on the range of source operands that FPATAN can accept.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FPATAN.html", "tooltip": "Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +π."},
    "STMXCSR": {"html": "<p>Stores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p><p>VEX.L must be 0, otherwise instructions will #UD.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "STMXCSR.html", "tooltip": "Stores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s."},
    "SETcc": {"html": "<p>Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (<em>cc</em>) indicates the condition being tested for.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The terms 'above” and 'below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms 'greater” and 'less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.</p><p>Many of the SET<em>cc</em> instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, 'EFLAGS Condition Codes,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, shows the alternate mnemonics for various test conditions.</p><p>Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SET<em>cc</em> instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.</p><p>In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.</p></span>", "url": "SETcc.html", "tooltip": "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (<em>cc</em>) indicates the condition being tested for."},
    "VEXTRACTI128": {"html": "<p>Extracts 128-bits of packed integer values from the source operand (second operand) at a 128-bit offset from imm8[0] into the destination operand (first operand). The destination may be either an XMM register or a 128-bit memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>The high 7 bits of the immediate are ignored.</p><p>An attempt to execute VEXTRACTI128 encoded with VEX.L= 0 will cause an #UD exception.</p></span>", "url": "VEXTRACTI128.html", "tooltip": "Extracts 128-bits of packed integer values from the source operand (second operand) at a 128-bit offset from imm8[0] into the destination operand (first operand). The destination may be either an XMM register or a 128-bit memory location."},
    "AESIMC": {"html": "<p>Perform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory loca-tion.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the 'Equivalent Inverse Cipher” (defined in FIPS 197).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "AESIMC.html", "tooltip": "Perform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory loca-tion."},
    "WRFSBASE": {"html": "<p>Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.</p><p>This instruction is supported only in 64-bit mode.</p></span>", "url": "WRFSBASE:WRGSBASE.html", "tooltip": "Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field."},
    "DIVSS": {"html": "<p>Divides the low single-precision floating-point value in the first source operand by the low single-precision floating-point value in the second source operand, and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers. The three high-order doublewords of the destination are copied from the same dwords of the first source operand. See Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an overview of a scalar single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "DIVSS.html", "tooltip": "Divides the low single-precision floating-point value in the first source operand by the low single-precision floating-point value in the second source operand, and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers. The three high-order doublewords of the destination are copied from the same dwords of the first source operand. See Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an overview of a scalar single-precision floating-point operation."},
    "STC": {"html": "<p>Sets the CF flag in the EFLAGS register. Operation is the same in all modes.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "STC.html", "tooltip": "Sets the CF flag in the EFLAGS register. Operation is the same in all modes."},
    "FXSAVE": {"html": "<p>Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory loca-tion specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Bytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.</p><p>The operation of FXSAVE in non-64-bit modes is described first.</p></span>", "url": "FXSAVE.html", "tooltip": "Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory loca-tion specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode."},
    "VPSLLVD": {"html": "<p>Shifts the bits in the individual data elements (doublewords, or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 31 (for double-words), or 63 (for a quadword), then the destination data element are written with 0.</p><p>VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory location.</p></span>", "url": "VPSLLVD:VPSLLVQ.html", "tooltip": "Shifts the bits in the individual data elements (doublewords, or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0)."},
    "HLT": {"html": "<p>Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology, only the logical processor that executes the instruction is halted. The other logical processors in the physical processor remain active, unless they are each individually halted by executing a HLT instruction.</p><p>The HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode, the privilege level of a program or procedure must be 0 to execute the HLT instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "HLT.html", "tooltip": "Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction."},
    "PSUBQ": {"html": "<p>Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note that the (V)PSUBQ instruction can operate on either unsigned or signed (two’s complement notation) inte-gers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values upon which it operates.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-nation register remain unchanged.</p><p>VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSUBQ.html", "tooltip": "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored)."},
    "LDS": {"html": "<p>Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.</p><p>Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to the segment occurs.)</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "LDS:LES:LFS:LGS:LSS.html", "tooltip": "Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand."},
    "PHMINPOSUW": {"html": "<p>Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand).  The word index of the minimum value is stored in bits 16-18 of the destination operand.  The remaining upper bits of the destination are set to zero.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PHMINPOSUW.html", "tooltip": "Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand).  The word index of the minimum value is stored in bits 16-18 of the destination operand.  The remaining upper bits of the destination are set to zero."},
    "CMPPD": {"html": "<p>Performs a SIMD compare of the packed double-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of the pairs of packed values. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. The comparison predicate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed (see Table 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. Two comparisons are performed with results written to bits 127:0 of the destination operand.</p><h3>Table 3-7.  Comparison Predicate for CMPPD and CMPPS Instructions</h3><table><tr><th>Predi-cate</th><th>imm8 Encoding</th><th>Description</th><th>Relation where: A Is 1st Operand B Is 2nd Operand</th><th>Emulation</th><th>Result if NaN Operand</th><th>QNaN Oper-and Signals Invalid</th></tr><tr><td>EQ</td><td>000B</td><td>Equal</td><td>A = B</td><td></td><td>False</td><td>No</td></tr><tr><td>LT</td><td>001B</td><td>Less-than</td><td>A &lt; B</td><td></td><td>False</td><td>Yes</td></tr><tr><td>LE</td><td>010B</td><td>Less-than-or-equal</td><td>A ≤ B</td><td></td><td>False</td><td>Yes</td></tr><tr><td></td><td></td><td>Greater than</td><td>A &gt; B</td><td>Swap Operands, Use LT</td><td>False</td><td>Yes</td></tr><tr><td></td><td></td><td>Greater-than-or-equal</td><td>A ≥ B</td><td>Swap Operands, Use LE</td><td>False</td><td>Yes</td></tr><tr><td>UNORD</td><td>011B</td><td>Unordered</td><td>A, B = Unordered</td><td></td><td>True</td><td>No</td></tr><tr><td>NEQ</td><td>100B</td><td>Not-equal</td><td>A ≠ B</td><td></td><td>True</td><td>No</td></tr><tr><td>NLT</td><td>101B</td><td>Not-less-than</td><td>NOT(A &lt; B)</td><td></td><td>True</td><td>Yes</td></tr></table><h3>Table 3-7.  Comparison Predicate for CMPPD and CMPPS Instructions  (Contd.)</h3><table><tr><th>Predi-cate</th><th>imm8 Encoding</th><th>Description</th><th>Relation where: A Is 1st Operand B Is 2nd Operand</th><th>Emulation</th><th>Result if NaN Operand</th><th>QNaN Oper-and Signals Invalid</th></tr><tr><td>NLE</td><td>110B</td><td>Not-less-than-or-equal</td><td>NOT(A ≤ B)</td><td></td><td>True</td><td>Yes</td></tr><tr><td></td><td></td><td>Not-greater-than</td><td>NOT(A &gt; B)</td><td>Swap Operands, Use NLT</td><td>True</td><td>Yes</td></tr><tr><td></td><td></td><td>Not-greater-than-or-equal</td><td>NOT(A ≥ B)</td><td>Swap Operands, Use NLE</td><td>True</td><td>Yes</td></tr><tr><td>ORD</td><td>111B</td><td>Ordered</td><td>A , B = Ordered</td><td></td><td>False</td><td>No</td></tr></table><p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN.</p><p>A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p><p>Note that the processors with 'CPUID.1H:ECX.AVX =0” do not implement the greater-than, greater-than-or-equal, not-greater-than, and not-greater-than-or-equal relations. These comparisons can be made either by using the inverse relationship (that is, use the 'not-less-than-or-equal” to make a 'greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in Table 3-7 under the heading Emula-tion.</p><p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPPD instruction, for processors with 'CPUID.1H:ECX.AVX =0”. See Table 3-8. Compiler should treat reserved Imm8 values as illegal syntax.</p><h3>Table 3-8.  Pseudo-Op and CMPPD Implementation</h3><p>:</p><table><tr><th>Pseudo-Op</th><th>CMPPD Implementation</th></tr><tr><td>CMPEQPD<em> xmm1, xmm2</em></td><td>CMPPD <em>xmm1, xmm2, 0</em></td></tr><tr><td>CMPLTPD<em> xmm1, xmm2</em></td><td>CMPPD <em>xmm1, xmm2, 1</em></td></tr><tr><td>CMPLEPD <em>xmm1, xmm2</em></td><td>CMPPD <em>xmm1, xmm2, 2</em></td></tr><tr><td>CMPUNORDPD <em>xmm1, xmm2</em></td><td>CMPPD <em>xmm1, xmm2, 3</em></td></tr><tr><td>CMPNEQPD <em>xmm1, xmm2</em></td><td>CMPPD<em> xmm1, xmm2, 4</em></td></tr><tr><td>CMPNLTPD<em> xmm1, xmm2</em></td><td>CMPPD <em>xmm1, xmm2, 5</em></td></tr><tr><td>CMPNLEPD <em>xmm1, xmm2</em></td><td>CMPPD <em>xmm1, xmm2, 6</em></td></tr><tr><td>CMPORDPD<em> xmm1, xmm2</em></td><td>CMPPD <em>xmm1, xmm2, 7</em></td></tr></table><p>The greater-than relations that the processor does not implement, require more than one instruction to emulate in software and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p><strong>Enhanced Comparison Predicate for VEX-Encoded VCMPPD</strong></p><p>VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destina-tion YMM register are zeroed. Two comparisons are performed with results written to bits 127:0 of the destination operand.</p><p>VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Four comparisons are performed with results written to the destination operand.</p><p>The comparison predicate operand is an 8-bit immediate:</p><h3>Table 3-9.  Comparison Predicate for VCMPPD and VCMPPS Instructions</h3><table><tr><th>Predicate</th><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td></tr><tr><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td></td><th>A &gt;B</th><th>A &lt; B</th><th>A = B</th><th>Unordered<sup>1</sup></th><th>on QNAN</th></tr><tr><td>EQ_OQ (EQ)</td><td>0H</td><td>Equal (ordered, non-signaling)</td><td>False</td><td>False</td><td>True</td><td>False</td><td>No</td></tr><tr><td>LT_OS (LT)</td><td>1H</td><td>Less-than (ordered, signaling)</td><td>False</td><td>True</td><td>False</td><td>False</td><td>Yes</td></tr><tr><td>LE_OS (LE)</td><td>2H</td><td>Less-than-or-equal (ordered, signaling)</td><td>False</td><td>True</td><td>True</td><td>False</td><td>Yes</td></tr><tr><td>UNORD_Q (UNORD)</td><td>3H</td><td>Unordered (non-signaling)</td><td>False</td><td>False</td><td>False</td><td>True</td><td>No</td></tr><tr><td>NEQ_UQ (NEQ)</td><td>4H</td><td>Not-equal (unordered, non-signaling)</td><td>True</td><td>True</td><td>False</td><td>True</td><td>No</td></tr><tr><td>NLT_US (NLT)</td><td>5H</td><td>Not-less-than (unordered, signaling)</td><td>True</td><td>False</td><td>True</td><td>True</td><td>Yes</td></tr><tr><td>NLE_US (NLE)</td><td>6H</td><td>Not-less-than-or-equal (unordered, signaling)</td><td>True</td><td>False</td><td>False</td><td>True</td><td>Yes</td></tr><tr><td>ORD_Q (ORD)</td><td>7H</td><td>Ordered (non-signaling)</td><td>True</td><td>True</td><td>True</td><td>False</td><td>No</td></tr><tr><td>EQ_UQ</td><td>8H</td><td>Equal (unordered, non-signaling)</td><td>False</td><td>False</td><td>True</td><td>True</td><td>No</td></tr><tr><td>NGE_US (NGE)</td><td>9H</td><td>Not-greater-than-or-equal (unordered, signaling)</td><td>False</td><td>True</td><td>False</td><td>True</td><td>Yes</td></tr><tr><td>NGT_US (NGT)</td><td>AH</td><td>Not-greater-than (unordered, sig-naling)</td><td>False</td><td>True</td><td>True</td><td>True</td><td>Yes</td></tr><tr><td>FALSE_OQ(FALSE)</td><td>BH</td><td>False (ordered, non-signaling)</td><td>False</td><td>False</td><td>False</td><td>False</td><td>No</td></tr><tr><td>NEQ_OQ</td><td>CH</td><td>Not-equal (ordered, non-signaling)</td><td>True</td><td>True</td><td>False</td><td>False</td><td>No</td></tr><tr><td>GE_OS (GE)</td><td>DH</td><td>Greater-than-or-equal (ordered, sig-naling)</td><td>True</td><td>False</td><td>True</td><td>False</td><td>Yes</td></tr><tr><td>GT_OS (GT)</td><td>EH</td><td>Greater-than (ordered, signaling)</td><td>True</td><td>False</td><td>False</td><td>False</td><td>Yes</td></tr><tr><td>TRUE_UQ(TRUE)</td><td>FH</td><td>True (unordered, non-signaling)</td><td>True</td><td>True</td><td>True</td><td>True</td><td>No</td></tr><tr><td>EQ_OS</td><td>10H</td><td>Equal (ordered, signaling)</td><td>False</td><td>False</td><td>True</td><td>False</td><td>Yes</td></tr><tr><td>LT_OQ</td><td>11H</td><td>Less-than (ordered, nonsignaling)</td><td>False</td><td>True</td><td>False</td><td>False</td><td>No</td></tr><tr><td>LE_OQ</td><td>12H</td><td>Less-than-or-equal (ordered, non-signaling)</td><td>False</td><td>True</td><td>True</td><td>False</td><td>No</td></tr><tr><td>UNORD_S</td><td>13H</td><td>Unordered (signaling)</td><td>False</td><td>False</td><td>False</td><td>True</td><td>Yes</td></tr><tr><td>NEQ_US</td><td>14H</td><td>Not-equal (unordered, signaling)</td><td>True</td><td>True</td><td>False</td><td>True</td><td>Yes</td></tr><tr><td>NLT_UQ</td><td>15H</td><td>Not-less-than (unordered, nonsig-naling)</td><td>True</td><td>False</td><td>True</td><td>True</td><td>No</td></tr><tr><td>NLE_UQ</td><td>16H</td><td>Not-less-than-or-equal (unordered, nonsignaling)</td><td>True</td><td>False</td><td>False</td><td>True</td><td>No</td></tr><tr><td>ORD_S</td><td>17H</td><td>Ordered (signaling)</td><td>True</td><td>True</td><td>True</td><td>False</td><td>Yes</td></tr><tr><td>EQ_US</td><td>18H</td><td>Equal (unordered, signaling)</td><td>False</td><td>False</td><td>True</td><td>True</td><td>Yes</td></tr></table><h3>Table 3-9.  Comparison Predicate for VCMPPD and VCMPPS Instructions  (Contd.)</h3><table><tr><th>Predicate</th><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td></tr><tr><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td><p><strong>imm8</strong></p><p><strong>Description</strong></p><p><strong>Result: A Is 1st Operand, B Is 2nd Operand</strong></p><p><strong>Signals #IA</strong></p><p><strong>Value</strong></p></td><td></td><th>A &gt;B</th><th>A &lt; B</th><th>A = B</th><th>Unordered<sup>1</sup></th><th>on QNAN</th></tr><tr><td>NGE_UQ</td><td>19H</td><td>Not-greater-than-or-equal (unor-dered, nonsignaling)</td><td>False</td><td>True</td><td>False</td><td>True</td><td>No</td></tr><tr><td>NGT_UQ</td><td>1AH</td><td>Not-greater-than (unordered, non-signaling)</td><td>False</td><td>True</td><td>True</td><td>True</td><td>No</td></tr><tr><td>FALSE_OS</td><td>1BH</td><td>False (ordered, signaling)</td><td>False</td><td>False</td><td>False</td><td>False</td><td>Yes</td></tr><tr><td>NEQ_OS</td><td>1CH</td><td>Not-equal (ordered, signaling)</td><td>True</td><td>True</td><td>False</td><td>False</td><td>Yes</td></tr><tr><td>GE_OQ</td><td>1DH</td><td>Greater-than-or-equal (ordered, nonsignaling)</td><td>True</td><td>False</td><td>True</td><td>False</td><td>No</td></tr><tr><td>GT_OQ</td><td>1EH</td><td>Greater-than (ordered, nonsignal-ing)</td><td>True</td><td>False</td><td>False</td><td>False</td><td>No</td></tr><tr><td>TRUE_US</td><td>1FH</td><td>True (unordered, signaling)</td><td>True</td><td>True</td><td>True</td><td>True</td><td>Yes</td></tr></table><p><strong>NOTES:</strong></p><p>1. If either operand A or B is a NAN.</p><p>Processors with 'CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-9, soft-ware emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPPD instruction. See Table 3-10, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. Compiler should treat reserved Imm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic inter-face.</p><h3>Table 3-10.  Pseudo-Op and VCMPPD Implementation</h3><p>:</p><table><tr><th>Pseudo-Op</th><th>CMPPD Implementation</th></tr><tr><td>VCMPEQPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 0</em></td></tr><tr><td>VCMPLTPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 1</em></td></tr><tr><td>VCMPLEPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 2</em></td></tr><tr><td>VCMPUNORDPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 3</em></td></tr><tr><td>VCMPNEQPD <em>reg1, reg2, reg3</em></td><td>VCMPPD<em> reg1, reg2, reg3, 4</em></td></tr><tr><td>VCMPNLTPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 5</em></td></tr><tr><td>VCMPNLEPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 6</em></td></tr><tr><td>VCMPORDPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 7</em></td></tr><tr><td>VCMPEQ_UQPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 8</em></td></tr><tr><td>VCMPNGEPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 9</em></td></tr><tr><td>VCMPNGTPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 0AH</em></td></tr><tr><td>VCMPFALSEPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 0BH</em></td></tr><tr><td>VCMPNEQ_OQPD <em>reg1, reg2, reg3</em></td><td>VCMPPD<em> reg1, reg2, reg3, 0CH</em></td></tr><tr><td>VCMPGEPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 0DH</em></td></tr><tr><td>VCMPGTPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 0EH</em></td></tr><tr><td>VCMPTRUEPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 0FH</em></td></tr><tr><td>VCMPEQ_OSPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 10H</em></td></tr><tr><td>VCMPLT_OQPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 11H</em></td></tr><tr><td>VCMPLE_OQPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 12H</em></td></tr></table><h3>Table 3-10.  Pseudo-Op and VCMPPD Implementation</h3><table><tr><th>Pseudo-Op</th><th>CMPPD Implementation</th></tr><tr><td>VCMPUNORD_SPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 13H</em></td></tr><tr><td>VCMPNEQ_USPD <em>reg1, reg2, reg3</em></td><td>VCMPPD<em> reg1, reg2, reg3, 14H</em></td></tr><tr><td>VCMPNLT_UQPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 15H</em></td></tr><tr><td>VCMPNLE_UQPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 16H</em></td></tr><tr><td>VCMPORD_SPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 17H</em></td></tr><tr><td>VCMPEQ_USPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 18H</em></td></tr><tr><td>VCMPNGE_UQPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 19H</em></td></tr><tr><td>VCMPNGT_UQPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 1AH</em></td></tr><tr><td>VCMPFALSE_OSPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 1BH</em></td></tr><tr><td>VCMPNEQ_OSPD <em>reg1, reg2, reg3</em></td><td>VCMPPD<em> reg1, reg2, reg3, 1CH</em></td></tr><tr><td>VCMPGE_OQPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 1DH</em></td></tr><tr><td>VCMPGT_OQPD <em>reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 1EH</em></td></tr><tr><td>VCMPTRUE_USPD<em> reg1, reg2, reg3</em></td><td>VCMPPD <em>reg1, reg2, reg3, 1FH</em></td></tr></table></span>", "url": "CMPPD.html", "tooltip": "Performs a SIMD compare of the packed double-precision floating-point values in the source operand (second operand) and the destination operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed on each of the pairs of packed values. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "MOVAPD": {"html": "<p>Moves 2 or 4 double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM or YMM register from an 128-bit or 256-bit memory location, to store the contents of an XMM or YMM register into a 128-bit or 256-bit memory location, or to move data between two XMM or two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>To move double-precision floating-point values to and from unaligned memory locations, use the (V)MOVUPD instruction.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit versions: Moves 128 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register destination are zeroed.</p><p>VEX.256 encoded version: Moves 256 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruc-tion.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "MOVAPD.html", "tooltip": "Moves 2 or 4 double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM or YMM register from an 128-bit or 256-bit memory location, to store the contents of an XMM or YMM register into a 128-bit or 256-bit memory location, or to move data between two XMM or two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary or a general-protection exception (#GP) will be generated."},
    "FSTCW": {"html": "<p>Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSTCW:FNSTCW.html", "tooltip": "Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not."},
    "PMAXUB": {"html": "<p>Performs a SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of byte integers to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMAXUB.html", "tooltip": "Performs a SIMD compare of the packed unsigned byte integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum value for each pair of byte integers to the destination operand."},
    "PMULLW": {"html": "<p>Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destina-tion operand. (Figure 4-8 shows this operation when using 64-bit operands.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><svg width='568.799985' viewBox='111.840000 603577.980010 379.199990 117.839970' height='176.759955'><text y='603598.907584' x='202.3212' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='603625.667684' x='202.3212' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='603656.087784' x='144.1198' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='22.189986'>TEMP</text><text y='603680.987384' x='203.4009' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='603588.6' x='241.08' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='603588.6' x='277.44' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='603588.6' x='313.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='603671.04' x='277.38' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='603671.04' x='313.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='603671.04' x='240.96' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='603588.6' x='350.16' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='603671.04' x='350.1' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='603644.64' x='242.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='603644.64' x='170.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='603644.64' x='314.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='603644.64' x='386.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><path style='stroke:black' d='M169.800000,603644.400000 L169.800000,603662.640000 L170.280010,603662.640000 L170.280010,603644.400000 '></path><path style='stroke:black' d='M241.800000,603644.400000 L241.800000,603662.640000 L242.280000,603662.640000 L242.280000,603644.400000 '></path><path style='stroke:black' d='M313.800000,603644.400000 L313.800000,603662.640000 L314.280010,603662.640000 L314.280010,603644.400000 '></path><path style='stroke:black' d='M385.800000,603644.400000 L385.800000,603662.640000 L386.279980,603662.640000 L386.279980,603644.400000 '></path><path style='stroke:black' d='M170.040000,603644.400020 L170.040000,603644.880000 L242.280000,603644.880000 L242.280000,603644.400020 '></path><path style='stroke:black' d='M242.040000,603644.400020 L242.040000,603644.880000 L314.280000,603644.880000 L314.280000,603644.400020 '></path><path style='stroke:black' d='M314.040000,603644.400020 L314.040000,603644.880000 L386.280000,603644.880000 L386.280000,603644.400020 '></path><path style='stroke:black' d='M386.040000,603644.400020 L386.040000,603644.880000 L458.280000,603644.880000 L458.280000,603644.400020 '></path><path style='stroke:black' d='M241.800000,603644.640000 L241.800000,603662.880000 L242.280000,603662.880000 L242.280000,603644.640000 '></path><path style='stroke:black' d='M313.800000,603644.640000 L313.800000,603662.880000 L314.280010,603662.880000 L314.280010,603644.640000 '></path><path style='stroke:black' d='M385.800000,603644.640000 L385.800000,603662.880000 L386.279980,603662.880000 L386.279980,603644.640000 '></path><path style='stroke:black' d='M457.800000,603644.640000 L457.800000,603662.880000 L458.279980,603662.880000 L458.279980,603644.640000 '></path><path style='stroke:black' d='M169.800000,603662.399960 L169.800000,603662.880000 L242.040000,603662.880000 L242.040000,603662.399960 '></path><path style='stroke:black' d='M241.800000,603662.399960 L241.800000,603662.880000 L314.040000,603662.880000 L314.040000,603662.399960 '></path><path style='stroke:black' d='M313.800000,603662.399960 L313.800000,603662.880000 L386.040000,603662.880000 L386.040000,603662.399960 '></path><path style='stroke:black' d='M385.800000,603662.399960 L385.800000,603662.880000 L458.040000,603662.880000 L458.040000,603662.399960 '></path><text y='603599.567484' x='252.6' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='603599.567484' x='288.122172' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='603599.567484' x='325.144584' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='603682.645488' x='281.97864' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='26.06868'>Z2[15:0]</text><text y='603682.645488' x='318.99192' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='26.06868'>Z1[15:0]</text><text y='603682.645488' x='246.42' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='25.99908'>Z3[15:0]</text><text y='603599.567484' x='361.624356' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='603682.645488' x='355.40664' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='26.00604'>Z0[15:0]</text><text y='603655.307784' x='254.947686' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.193038'>Z2 = X2 ∗ Y2</text><text y='603655.307784' x='181.8597' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.148304'>Z3 = X3 ∗ Y3</text><text y='603655.307784' x='328.259956' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.125208'>Z1 = X1 ∗ Y1</text><text y='603655.307784' x='397.251056' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='46.202588'>Z0 = X0 ∗ Y0</text></svg><svg width='218.2500075' viewBox='241.020000 603614.819980 145.500005 18.000030' height='27.000045'><rect y='603614.82' x='241.02' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='603614.82' x='277.38' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='603614.82' x='313.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='603614.82' x='350.16' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><text y='603626.867384' x='255.78' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='603626.867384' x='291.302172' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='603626.867384' x='328.324584' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='603626.867384' x='364.804356' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text></svg><h3>Figure 4-9.  PMULLU Instruction Operation Using 64-bit Operands</h3></span>", "url": "PMULLW.html", "tooltip": "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destina-tion operand. (Figure 4-8 shows this operation when using 64-bit operands.)"},
    "HSUBPD": {"html": "<p>The HSUBPD instruction subtracts horizontally the packed DP FP numbers of both operands.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Subtracts the double-precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.</p><p>Subtracts the double-precision floating-point value in the high quadword of the source operand from the low quad-word of the source operand and stores the result in the high quadword of the destination operand.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>See Figure 3-19 for HSUBPD; see Figure 3-20 for VHSUBPD.</p><svg width='501.93' viewBox='135.360000 291927.540000 334.620000 206.940000' height='310.41'><text y='291944.578446' x='242.085' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='102.8126328'>HSUBPD xmm1, xmm2/m128</text><text y='291964.512746' x='429.8883' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='21.1627334'>xmm2</text><text y='291969.177746' x='213.8383' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='28.0977658'>[127:64]</text><text y='291969.177746' x='349.3623' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='19.4522994'>[63:0]</text><text y='291973.842446' x='429.8883' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='21.6058913'>/m128</text><text y='292016.190446' x='429.8883' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='21.1627334'>xmm1</text><text y='292016.190746' x='213.8383' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='28.0977658'>[127:64]</text><text y='292016.190746' x='349.3623' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='19.4522994'>[63:0]</text><text y='292068.378446' x='429.8887' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='24.1948664'>Result:</text><text y='292068.378846' x='194.4013' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='66.9712658'>xmm2/m128[63:0] -</text><text y='292073.043646' x='310.6925' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='96.7872403'>xmm1[63:0] - xmm1[127:64]</text><text y='292077.708046' x='429.8887' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='21.1627334'>xmm1</text><text y='292077.708446' x='192.4576' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='70.8663905'>xmm2/m128[127:64]</text><text y='292096.015746' x='213.8484' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='28.0977658'>[127:64]</text><text y='292096.015746' x='353.74479686' style='font-size:7.774700pt' lengthAdjust='spacingAndGlyphs' textLength='19.4522994'>[63:0]</text><text y='292126.064858' x='439.8024' style='font-size:5.831000pt' lengthAdjust='spacingAndGlyphs' textLength='25.603921'>OM15995</text><rect y='291928.219' x='136.052' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='179.305' width='327.998'></rect><rect y='291928.218' x='136.052' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='179.305' width='327.998'></rect><rect y='291953.364' x='293.491' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='291953.365' x='293.491' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='291953.364' x='162.291' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='291953.365' x='162.291' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292000.378' x='293.491' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292000.378' x='162.291' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292057.23' x='162.291' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292057.231' x='162.291' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292057.23' x='293.491' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292057.231' x='293.491' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292000.377' x='293.491' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect><rect y='292000.377' x='162.291' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='26.24' width='131.199'></rect></svg><h3>Figure 3-19.  HSUBPD—Packed Double-FP Horizontal Subtract</h3><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>SRC1</p><p>Y3</p><p>Y2</p><p>Y1</p><p>Y0</p><p>SRC2</p><p>DEST</p><p>Y2 - Y3</p><p>X2 - X3</p><p>Y0 - Y1</p><p>X0 - X1</p><h3>Figure 3-20.  VHSUBPD operation</h3><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "HSUBPD.html", "tooltip": "The HSUBPD instruction subtracts horizontally the packed DP FP numbers of both operands."},
    "MOVSX": {"html": "<p>Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>). The size of the converted value depends on the operand-size attribute.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOVSX:MOVSXD.html", "tooltip": "Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>). The size of the converted value depends on the operand-size attribute."},
    "UNPCKHPD": {"html": "<p>Performs an interleaved unpack of the high double-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-23.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 798713.039995 379.199990 150.300000' height='225.45'><text y='798741.527284' x='141.1794' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='798785.867384' x='145.6195' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='798847.847184' x='141.1794' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='798837.96' x='167.88' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='143.28'></rect><rect y='798729.96' x='311.58' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.12'></rect><rect y='798729.96' x='167.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.18'></rect><rect y='798774.96' x='167.7' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.18'></rect><rect y='798837.96' x='310.92' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.18'></rect><rect y='798774.96' x='310.68' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='145.02'></rect><path style='stroke:black' d='M167.700000,798729.719990 L167.700000,798730.200000 L312.120000,798730.200000 L312.120000,798729.719990 '></path><path style='stroke:black' d='M311.580000,798729.719990 L311.580000,798730.200000 L455.940000,798730.200000 L455.940000,798729.719990 '></path><path style='stroke:black' d='M167.460000,798729.720000 L167.460000,798747.960000 L167.940010,798747.960000 L167.940010,798729.720000 '></path><path style='stroke:black' d='M311.340000,798729.720000 L311.340000,798747.960000 L311.820010,798747.960000 L311.820010,798729.720000 '></path><path style='stroke:black' d='M311.640000,798729.960000 L311.640000,798748.200000 L312.119980,798748.200000 L312.119980,798729.960000 '></path><path style='stroke:black' d='M455.460000,798729.960000 L455.460000,798748.200000 L455.940010,798748.200000 L455.940010,798729.960000 '></path><path style='stroke:black' d='M167.460000,798747.719990 L167.460000,798748.200000 L311.880000,798748.200000 L311.880000,798747.719990 '></path><path style='stroke:black' d='M311.340000,798747.719990 L311.340000,798748.200000 L455.700000,798748.200000 L455.700000,798747.719990 '></path><path style='stroke:black' d='M167.700000,798774.719990 L167.700000,798775.200000 L312.120000,798775.200000 L312.120000,798774.719990 '></path><path style='stroke:black' d='M310.680000,798774.719990 L310.680000,798775.200000 L455.940000,798775.200000 L455.940000,798774.719990 '></path><path style='stroke:black' d='M167.460000,798774.720000 L167.460000,798792.960000 L167.940010,798792.960000 L167.940010,798774.720000 '></path><path style='stroke:black' d='M310.440000,798774.720000 L310.440000,798792.960000 L310.920010,798792.960000 L310.920010,798774.720000 '></path><path style='stroke:black' d='M311.640000,798774.960000 L311.640000,798793.200000 L312.119980,798793.200000 L312.119980,798774.960000 '></path><path style='stroke:black' d='M455.460000,798774.960000 L455.460000,798793.200000 L455.940010,798793.200000 L455.940010,798774.960000 '></path><path style='stroke:black' d='M239.220000,798792.480010 L239.220000,798792.720000 L239.700000,798792.720000 L239.700000,798792.480010 '></path><path style='stroke:black' d='M167.460000,798792.719990 L167.460000,798793.200000 L311.880000,798793.200000 L311.880000,798792.719990 '></path><path style='stroke:black' d='M310.440000,798792.719990 L310.440000,798793.200000 L455.700000,798793.200000 L455.700000,798792.719990 '></path><path style='stroke:black' d='M239.220000,798792.720000 L239.220000,798830.640000 L239.700000,798830.640000 L239.700000,798792.720000 '></path><path style='stroke:black' d='M239.220000,798830.400000 L239.220000,798831.540000 L239.700000,798831.540000 L239.700000,798830.400000 '></path><path style='stroke:black' d='M167.880000,798837.719990 L167.880000,798838.200000 L311.400000,798838.200000 L311.400000,798837.719990 '></path><path style='stroke:black' d='M310.920000,798837.719990 L310.920000,798838.200000 L455.340000,798838.200000 L455.340000,798837.719990 '></path><path style='stroke:black' d='M167.640000,798837.720000 L167.640000,798855.960000 L168.120000,798855.960000 L168.120000,798837.720000 '></path><path style='stroke:black' d='M310.680000,798837.720000 L310.680000,798855.960000 L311.160010,798855.960000 L311.160010,798837.720000 '></path><path style='stroke:black' d='M310.920000,798837.960000 L310.920000,798856.200000 L311.399980,798856.200000 L311.399980,798837.960000 '></path><path style='stroke:black' d='M454.860000,798837.960000 L454.860000,798856.200000 L455.339980,798856.200000 L455.339980,798837.960000 '></path><path style='stroke:black' d='M167.640000,798855.719990 L167.640000,798856.200000 L311.160000,798856.200000 L311.160000,798855.719990 '></path><path style='stroke:black' d='M310.680000,798855.719990 L310.680000,798856.200000 L455.100000,798856.200000 L455.100000,798855.719990 '></path><text y='798850.007384' x='234.48' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='798743.207584' x='380.4603' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='798742.307484' x='233.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='798788.207484' x='233.76' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='798850.247584' x='377.2199' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='798788.207484' x='379.557792' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text></svg><h3>Figure 4-23.  UNPCKHPD Instruction High Unpack and Interleave Operation</h3><p>When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p></span>", "url": "UNPCKHPD.html", "tooltip": "Performs an interleaved unpack of the high double-precision floating-point values from the source operand (second operand) and the destination operand (first operand). See Figure 4-23."},
    "DAA": {"html": "<p>Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addi-tion) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the CF and AF flags are set accordingly.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "DAA.html", "tooltip": "Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addi-tion) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the CF and AF flags are set accordingly."},
    "SQRTPD": {"html": "<p>Performs a SIMD computation of the square roots of the two packed double-precision floating-point values in the source operand (second operand) stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "SQRTPD.html", "tooltip": "Performs a SIMD computation of the square roots of the two packed double-precision floating-point values in the source operand (second operand) stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation."},
    "MULSD": {"html": "<p>Multiplies the low double-precision floating-point value in the source operand (second operand) by the low double-precision floating-point value in the destination operand (first operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustra-tion of a scalar double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "MULSD.html", "tooltip": "Multiplies the low double-precision floating-point value in the source operand (second operand) by the low double-precision floating-point value in the destination operand (first operand), and stores the double-precision floating-point result in the destination operand. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. The high quadword of the destination operand remains unchanged. See Figure 11-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustra-tion of a scalar double-precision floating-point operation."},
    "VINSERTI128": {"html": "<p>Performs an insertion of 128-bits of packed integer data from the second source operand (third operand) into an the destination operand (first operand) at a 128-bit offset from imm8[0]. The remaining portions of the destination are written by the corresponding fields of the first source operand (second operand). The second source operand can be either an XMM register or a 128-bit memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The high 7 bits of the immediate are ignored.</p><p>VEX.L must be 1; an attempt to execute this instruction with VEX.L=0 will cause #UD.</p></span>", "url": "VINSERTI128.html", "tooltip": "Performs an insertion of 128-bits of packed integer data from the second source operand (third operand) into an the destination operand (first operand) at a 128-bit offset from imm8[0]. The remaining portions of the destination are written by the corresponding fields of the first source operand (second operand). The second source operand can be either an XMM register or a 128-bit memory location."},
    "PADDB": {"html": "<p>Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Adds the packed byte, word, doubleword, or quadword integers in the first source operand to the second source operand and stores the result in the destination operand. When a result is too large to be represented in the</p><p>8/16/32 integer (overflow), the result is wrapped around and the low bits are written to the destination element (that is, the carry is ignored).</p><p>Note that these instructions can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.</p><p>These instructions can operate on either 64-bit, 128-bit or 256-bit operands. When operating on 64-bit operands, the destination operand must be an MMX technology register and the source operand can be either an MMX tech-nology register or a 64-bit memory location. In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PADDB:PADDW:PADDD.html", "tooltip": "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs."},
    "VZEROALL": {"html": "<p>The instruction zeros contents of all XMM or YMM registers.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note: VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified.</p></span>", "url": "VZEROALL.html", "tooltip": "The instruction zeros contents of all XMM or YMM registers."},
    "MOVSHDUP": {"html": "<p>The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision elements in positions 1 and 3 are duplicated. When the register-register form of this operation is used, the same operation is performed but with data coming from the 128-bit source register. See Figure 3-25.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='560.88' viewBox='117.660000 439987.500000 373.920000 166.740000' height='250.11'><text y='440005.422533' x='223.0967' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='120.9096834'>MOVSHDUP xmm1, xmm2/m128</text><text y='440026.346133' x='444.2234' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='24.4806'>xmm2/</text><text y='440031.241533' x='151.8219' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='29.4909628'>[127:96]</text><text y='440031.241533' x='232.129' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='24.9538916'>[95:64]</text><text y='440031.241533' x='310.1614' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='24.9538916'>[63:32]</text><text y='440031.241533' x='390.4582' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='20.4168204'>[31:0]</text><text y='440036.138333' x='444.2234' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='20.4086602'>m128</text><text y='440076.535933' x='143.825' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='47.0029824'>xmm1[127:96]</text><text y='440076.535933' x='223.8464' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='42.878352'>xmm1[95:64]</text><text y='440076.535933' x='301.8787' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='42.878352'>xmm1[63:32]</text><text y='440076.535933' x='381.9103' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='38.7537216'>xmm1[31:0]</text><text y='440081.427433' x='444.2234' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='32.9508876'>RESULT:</text><text y='440086.328133' x='144.825' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='44.9406672'>xmm2/</text><text y='440086.328133' x='223.8568' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='42.878352'>xmm2/</text><text y='440086.328133' x='302.8883' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='40.8160368'>xmm2/</text><text y='440086.328133' x='382.9103' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='36.6914064'>xmm2/</text><text y='440091.219733' x='444.2234' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='22.2120644'>xmm1</text><text y='440096.120433' x='144.6106' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='45.363516'>m128[127:96]</text><text y='440096.120433' x='222.6431' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='45.363516'>m128[127:96]</text><text y='440096.120433' x='302.674' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='41.2388856'>m128[63:32]</text><text y='440096.120433' x='380.707' style='font-size:7.418400pt' lengthAdjust='spacingAndGlyphs' textLength='41.2388856'>m128[63:32]</text><text y='440114.960333' x='151.8325' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='29.4909628'>[127:96]</text><text y='440114.960333' x='232.13947626' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='24.9538916'>[95:64]</text><text y='440114.960333' x='310.17138876' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='24.9538916'>[63:32]</text><text y='440114.960333' x='390.46775676' style='font-size:8.160200pt' lengthAdjust='spacingAndGlyphs' textLength='20.4168204'>[31:0]</text><text y='440145.415673' x='459.5796' style='font-size:6.120100pt' lengthAdjust='spacingAndGlyphs' textLength='26.8733591'>OM15998</text><rect y='439988.251' x='118.375' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='142.294' width='367.211'></rect><rect y='439988.251' x='118.375' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='142.294' width='367.211'></rect><rect y='440014.644' x='361.653' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440014.644' x='283.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440014.644' x='127.555' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440014.644' x='205.588' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440063.988' x='361.653' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect><rect y='440063.988' x='283.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect><rect y='440063.988' x='127.555' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect><rect y='440063.988' x='205.588' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect><rect y='440014.644' x='361.653' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440014.644' x='283.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440014.644' x='127.555' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440014.644' x='205.588' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.541' width='78.032'></rect><rect y='440063.988' x='361.653' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect><rect y='440063.988' x='283.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect><rect y='440063.988' x='127.555' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect><rect y='440063.988' x='205.588' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='39.016' width='78.032'></rect></svg><h3>Figure 3-25.  MOVSHDUP—Move Packed Single-FP High and Duplicate</h3><p>In 64-bit mode, use of the REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "MOVSHDUP.html", "tooltip": "The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision elements in positions 1 and 3 are duplicated. When the register-register form of this operation is used, the same operation is performed but with data coming from the 128-bit source register. See Figure 3-25."},
    "MASKMOVDQU": {"html": "<p>Stores selected bytes from the source operand (first operand) into an 128-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask oper-ands are XMM registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.</p><p>The MASKMOVDQU instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see 'Caching of Temporal vs. Non-Temporal Data” in Chapter 10, of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing opera-tion implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVDQU instructions if multiple processors might use different memory types to read/write the destination memory loca-tions.</p><p>Behavior with a mask of all 0s is as follows:</p><p>The MASKMOVDQU instruction can be used to improve performance of algorithms that need to merge data on a byte-by-byte basis. MASKMOVDQU should not cause a read for ownership; doing so generates unnecessary band-width since data is to be written directly using the byte-mask without allocating old data prior to the store.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>If VMASKMOVDQU is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p><p>1.ModRM.MOD = 011B required</p></span>", "url": "MASKMOVDQU.html", "tooltip": "Stores selected bytes from the source operand (first operand) into an 128-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask oper-ands are XMM registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)"},
    "PMULUDQ": {"html": "<p>Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The source operand can be an unsigned doubleword integer stored in the low doubleword of an MMX technology register or a 64-bit memory location. The destination operand can be an unsigned doubleword integer stored in the low doubleword an MMX technology register. The result is an unsigned quadword integer stored in the destination an MMX technology register. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).</p><p>For 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the compu-tation.</p><p>128-bit Legacy SSE version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation.The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation.The first</p><p>source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is four packed unsigned doubleword integers stored in the first (low), third, fifth and seventh doublewords of a YMM register or a 256-bit memory location. For 256-bit memory operands, 256 bits are fetched from memory, but only the first, third, fifth and seventh doublewords are used in the computation.The first source operand is four packed unsigned doubleword integers stored in the first, third, fifth and seventh doublewords of an YMM register. The destination contains four packed unaligned quadword integers stored in an YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMULUDQ.html", "tooltip": "Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand."},
    "FSUBR": {"html": "<p>Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.</p><p>The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.</p><p>The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtrac-tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.</p><p>The FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.</p><p>The following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC − DEST = result).</p><p>When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.</p><p>When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-operation exception is generated.</p><h3>Table 3-49.  FSUBR/FSUBRP/FISUBR Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>SRC</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>−F or −I</td><td colspan='2'>−0</td><td colspan='2'>+0</td><td colspan='2'>+F or +I</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>− F</td><td colspan='2'>− ∞</td><td colspan='2'>±F or ±0</td><td colspan='2'>−DEST</td><td colspan='2'>−DEST</td><td colspan='2'>+ F</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>DEST</th><td colspan='2'>− 0</td><td colspan='2'>− ∞</td><td colspan='2'>SRC</td><td colspan='2'>±0</td><td colspan='2'>+ 0</td><td colspan='2'>SRC</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ 0</td><td colspan='2'>− ∞</td><td colspan='2'>SRC</td><td colspan='2'>− 0</td><td colspan='2'>±0</td><td colspan='2'>SRC</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ F</td><td colspan='2'>− ∞</td><td colspan='2'>− F</td><td colspan='2'>−DEST</td><td colspan='2'>−DEST</td><td colspan='2'>±F or ±0</td><td colspan='2'>+ ∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+ ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>− ∞</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>I</p><p>Means integer.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSUBR:FSUBRP:FISUBR.html", "tooltip": "Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format."},
    "SYSCALL": {"html": "<p>SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX). (The WRMSR instruction ensures that the IA32_LSTAR MSR always contain a canonical address.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>SYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK MSR (MSR address C0000084H); specifically, the processor clears in RFLAGS every bit corresponding to a bit that is set in the IA32_FMASK MSR.</p><p>SYSCALL loads the CS and SS selectors with values derived from bits 47:32 of the IA32_STAR MSR. However, the CS and SS descriptor caches are <strong>not</strong> loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the respon-sibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values corre-spond to the fixed values loaded into the descriptor caches; the SYSCALL instruction does not ensure this correspondence.</p><p>The SYSCALL instruction does not save the stack pointer (RSP). If the OS system-call handler will change the stack pointer, it is the responsibility of software to save the previous value of the stack pointer. This might be done prior to executing SYSCALL, with software restoring the stack pointer with the instruction following SYSCALL (which will be executed after SYSRET). Alternatively, the OS system-call handler may save the stack pointer and restore it before executing SYSRET.</p></span>", "url": "SYSCALL.html", "tooltip": "SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX). (The WRMSR instruction ensures that the IA32_LSTAR MSR always contain a canonical address.)"},
    "CVTTPD2PI": {"html": "<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "CVTTPD2PI.html", "tooltip": "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register."},
    "VFMADDSUB132PD": {"html": "<p>VFMADDSUB132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMADDSUB213PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFMADDSUB231PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMADDSUB132PD:VFMADDSUB213PD:VFMADDSUB231PD.html", "tooltip": "VFMADDSUB132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infi-nite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand)."},
    "PMULLD": {"html": "<p>Performs four signed multiplications from four pairs of signed dword integers and stores the lower 32 bits of the four 64-bit products in the destination operand (first operand). Each dword element in the destination operand is multiplied with the corresponding dword element of the source operand (second operand) to obtain a 64-bit inter-mediate product.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMULLD.html", "tooltip": "Performs four signed multiplications from four pairs of signed dword integers and stores the lower 32 bits of the four 64-bit products in the destination operand (first operand). Each dword element in the destination operand is multiplied with the corresponding dword element of the source operand (second operand) to obtain a 64-bit inter-mediate product."},
    "PMADDUBSW": {"html": "<p>(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corre-sponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same oper-ation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMADDUBSW.html", "tooltip": "(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corre-sponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same oper-ation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},
    "PUNPCKHBW": {"html": "<p>Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destina-tion operand (first operand) and source operand (second operand) into the destination operand. Figure 4-16 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 667000.980010 379.199990 97.260000' height='145.89'><text y='667021.907684' x='126.3602' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.864932'>SRC</text><text y='667022.267584' x='454.26' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='667084.787684' x='140.3404' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='667011.0' x='307.98' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.0'></rect><rect y='667011.06' x='145.68' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.0'></rect><path style='stroke:black' d='M316.980000,667029.000000 L317.220000,667028.940000 L317.040000,667028.460000 L316.800000,667028.520000 '></path><path style='stroke:black' d='M353.400000,667029.000000 L353.580000,667028.880000 L353.340000,667028.460000 L353.160000,667028.580000 '></path><path style='stroke:black' d='M370.560000,667029.000000 L370.740000,667028.880000 L370.500000,667028.460000 L370.320000,667028.580000 '></path><path style='stroke:black' d='M316.980000,667029.000000 L316.800000,667028.520000 L198.120000,667070.940000 L198.300000,667071.420000 '></path><path style='stroke:black' d='M334.620000,667029.000000 L334.800000,667028.940000 L334.620000,667028.520000 L334.440000,667028.580000 '></path><path style='stroke:black' d='M334.620000,667029.000000 L334.440000,667028.580000 L234.960000,667070.580000 L235.140000,667071.000000 '></path><path style='stroke:black' d='M353.400000,667029.000000 L353.160000,667028.580000 L269.520000,667070.160000 L269.760000,667070.580000 '></path><path style='stroke:black' d='M370.560000,667029.000000 L370.320000,667028.580000 L304.500000,667069.500000 L304.740000,667069.920000 '></path><path style='stroke:black' d='M171.840000,667029.180000 L171.720000,667029.000000 L171.360000,667029.300000 L171.480000,667029.480000 '></path><path style='stroke:black' d='M190.020000,667029.120000 L189.840000,667029.000000 L189.540000,667029.360000 L189.720000,667029.480000 '></path><path style='stroke:black' d='M155.820000,667029.240000 L155.760000,667029.060000 L155.340000,667029.240000 L155.400000,667029.420000 '></path><path style='stroke:black' d='M190.020000,667029.120000 L189.720000,667029.480000 L238.920000,667069.140000 L239.220000,667068.780000 '></path><path style='stroke:black' d='M171.840000,667029.180000 L171.480000,667029.480000 L203.520000,667068.060000 L203.880000,667067.760000 '></path><path style='stroke:black' d='M155.820000,667029.240000 L155.400000,667029.420000 L170.220000,667066.740000 L170.640000,667066.560000 '></path><path style='stroke:black' d='M209.280000,667029.660000 L209.100000,667029.540000 L208.860000,667029.960000 L209.040000,667030.080000 '></path><path style='stroke:black' d='M209.280000,667029.660000 L209.040000,667030.080000 L273.240000,667069.980000 L273.480000,667069.560000 '></path><path style='stroke:black' d='M170.460000,667067.220000 L171.660000,667066.140000 L172.440000,667065.360000 L172.560000,667066.500000 L173.160000,667072.080000 L173.280000,667073.820000 L172.260000,667072.440000 L168.840000,667068.000000 L168.180000,667067.160000 L169.200000,667067.100000 L169.620000,667067.340000 L173.040000,667071.780000 L172.260000,667072.440000 L172.140000,667072.140000 L171.540000,667066.560000 L172.560000,667066.500000 L172.380000,667066.860000 L171.180000,667067.940000 '></path><path style='stroke:black' d='M203.940000,667068.420000 L204.780000,667067.040000 L205.200000,667066.080000 L205.680000,667067.100000 L207.960000,667072.200000 L208.680000,667073.820000 L207.240000,667072.800000 L202.620000,667069.620000 L201.720000,667069.080000 L202.680000,667068.720000 L203.160000,667068.780000 L207.780000,667071.960000 L207.240000,667072.800000 L207.060000,667072.620000 L204.780000,667067.520000 L205.680000,667067.100000 L205.620000,667067.520000 L204.780000,667068.900000 '></path><path style='stroke:black' d='M170.820000,667067.580000 L172.020000,667066.500000 L172.620000,667072.080000 L169.200000,667067.640000 '></path><path style='stroke:black' d='M170.640000,667066.560000 L170.160000,667066.680000 L170.580000,667067.640000 L171.060000,667067.520000 '></path><path style='stroke:black' d='M170.640000,667066.560000 L170.700000,667066.740000 L170.280000,667066.920000 L170.220000,667066.740000 '></path><path style='stroke:black' d='M239.400000,667069.440000 L239.940000,667067.880000 L240.180000,667066.860000 L240.840000,667067.820000 L244.080000,667072.380000 L245.100000,667073.760000 L243.480000,667073.100000 L238.320000,667070.940000 L237.360000,667070.520000 L238.260000,667070.040000 L238.680000,667070.040000 L243.840000,667072.200000 L243.480000,667073.100000 L243.240000,667072.920000 L240.000000,667068.360000 L240.840000,667067.820000 L240.900000,667068.240000 L240.360000,667069.800000 '></path><path style='stroke:black' d='M169.200000,667067.100000 L170.820000,667067.040000 L171.180000,667067.940000 L171.000000,667068.060000 L170.820000,667068.120000 L169.200000,667068.180000 '></path><path style='stroke:black' d='M204.360000,667068.660000 L205.200000,667067.280000 L207.480000,667072.380000 L202.860000,667069.200000 '></path><path style='stroke:black' d='M273.780000,667070.160000 L274.080000,667068.540000 L274.200000,667067.520000 L274.980000,667068.360000 L278.760000,667072.500000 L279.840000,667073.760000 L278.220000,667073.280000 L272.820000,667071.780000 L271.800000,667071.540000 L272.640000,667070.880000 L273.120000,667070.820000 L278.520000,667072.320000 L278.220000,667073.280000 L277.980000,667073.160000 L274.200000,667069.020000 L274.980000,667068.360000 L275.040000,667068.780000 L274.740000,667070.400000 '></path><path style='stroke:black' d='M304.020000,667069.860000 L305.280000,667070.880000 L306.120000,667071.540000 L305.100000,667071.780000 L299.760000,667073.280000 L298.080000,667073.760000 L299.220000,667072.500000 L302.940000,667068.360000 L303.660000,667067.580000 L303.840000,667068.540000 L303.720000,667069.020000 L300.000000,667073.160000 L299.220000,667072.500000 L299.460000,667072.320000 L304.800000,667070.820000 L305.100000,667071.780000 L304.680000,667071.720000 L303.420000,667070.700000 '></path><path style='stroke:black' d='M203.880000,667067.700000 L203.520000,667068.060000 L204.180000,667068.840000 L204.540000,667068.480000 '></path><path style='stroke:black' d='M203.880000,667067.760000 L204.000000,667067.940000 L203.640000,667068.240000 L203.520000,667068.060000 '></path><path style='stroke:black' d='M239.880000,667069.620000 L240.420000,667068.060000 L243.660000,667072.620000 L238.500000,667070.460000 '></path><path style='stroke:black' d='M269.040000,667070.460000 L270.240000,667071.600000 L270.960000,667072.260000 L269.940000,667072.440000 L264.420000,667073.460000 L262.680000,667073.820000 L264.000000,667072.620000 L268.140000,667068.840000 L268.920000,667068.120000 L268.980000,667069.140000 L268.800000,667069.560000 L264.660000,667073.340000 L264.000000,667072.620000 L264.240000,667072.500000 L269.760000,667071.480000 L269.940000,667072.440000 L269.520000,667072.320000 L268.320000,667071.180000 '></path><path style='stroke:black' d='M202.680000,667068.720000 L204.180000,667068.180000 L204.780000,667068.900000 L204.720000,667069.080000 L204.540000,667069.140000 L203.040000,667069.680000 '></path><path style='stroke:black' d='M234.360000,667070.820000 L235.500000,667072.020000 L236.220000,667072.800000 L235.140000,667072.920000 L229.560000,667073.580000 L227.820000,667073.760000 L229.200000,667072.680000 L233.580000,667069.200000 L234.420000,667068.540000 L234.480000,667069.560000 L234.240000,667069.980000 L229.860000,667073.460000 L229.200000,667072.680000 L229.500000,667072.560000 L235.080000,667071.900000 L235.140000,667072.920000 L234.780000,667072.740000 L233.640000,667071.540000 '></path><path style='stroke:black' d='M303.840000,667068.540000 L304.200000,667070.160000 L303.420000,667070.700000 L303.240000,667070.580000 L303.240000,667070.400000 L302.880000,667068.780000 '></path><path style='stroke:black' d='M274.260000,667070.280000 L274.560000,667068.660000 L278.340000,667072.800000 L272.940000,667071.300000 '></path><path style='stroke:black' d='M303.720000,667070.280000 L304.980000,667071.300000 L299.640000,667072.800000 L303.360000,667068.660000 '></path><path style='stroke:black' d='M239.220000,667068.780000 L238.860000,667069.140000 L239.700000,667069.800000 L240.060000,667069.440000 '></path><path style='stroke:black' d='M239.220000,667068.780000 L239.400000,667068.900000 L239.100000,667069.260000 L238.920000,667069.140000 '></path><path style='stroke:black' d='M197.580000,667071.180000 L198.660000,667072.440000 L199.320000,667073.280000 L198.240000,667073.340000 L192.660000,667073.700000 L190.920000,667073.760000 L192.360000,667072.740000 L196.860000,667069.500000 L197.760000,667068.900000 L197.760000,667069.920000 L197.520000,667070.340000 L192.960000,667073.580000 L192.360000,667072.740000 L192.600000,667072.680000 L198.180000,667072.320000 L198.240000,667073.340000 L197.820000,667073.160000 L196.740000,667071.900000 '></path><path style='stroke:black' d='M268.980000,667069.140000 L269.220000,667070.760000 L268.320000,667071.180000 L268.200000,667071.060000 L268.200000,667070.880000 L268.020000,667069.260000 '></path><path style='stroke:black' d='M238.260000,667070.040000 L239.640000,667069.200000 L240.360000,667069.800000 L240.300000,667069.980000 L240.120000,667070.040000 L238.740000,667070.880000 '></path><path style='stroke:black' d='M268.680000,667070.820000 L269.880000,667071.960000 L264.360000,667072.980000 L268.500000,667069.200000 '></path><path style='stroke:black' d='M304.740000,667069.860000 L304.500000,667069.500000 L303.600000,667070.100000 L303.840000,667070.460000 '></path><path style='stroke:black' d='M304.740000,667069.920000 L304.560000,667070.040000 L304.320000,667069.620000 L304.500000,667069.500000 '></path><path style='stroke:black' d='M234.000000,667071.180000 L235.140000,667072.380000 L229.560000,667073.040000 L233.940000,667069.560000 '></path><path style='stroke:black' d='M234.480000,667069.560000 L234.540000,667071.180000 L233.640000,667071.540000 L233.520000,667071.360000 L233.460000,667071.180000 L233.400000,667069.560000 '></path><path style='stroke:black' d='M273.480000,667069.560000 L273.240000,667069.920000 L274.140000,667070.460000 L274.380000,667070.100000 '></path><path style='stroke:black' d='M273.480000,667069.560000 L273.660000,667069.680000 L273.420000,667070.100000 L273.240000,667069.980000 '></path><path style='stroke:black' d='M272.640000,667070.880000 L273.960000,667069.860000 L274.740000,667070.400000 L274.740000,667070.580000 L274.560000,667070.700000 L273.240000,667071.720000 '></path><path style='stroke:black' d='M197.160000,667071.540000 L198.240000,667072.800000 L192.660000,667073.160000 L197.220000,667069.920000 '></path><path style='stroke:black' d='M197.760000,667069.920000 L197.700000,667071.540000 L196.740000,667071.900000 L196.680000,667071.720000 L196.620000,667071.540000 L196.680000,667069.920000 '></path><path style='stroke:black' d='M269.760000,667070.580000 L269.520000,667070.100000 L268.560000,667070.580000 L268.800000,667071.060000 '></path><path style='stroke:black' d='M269.760000,667070.580000 L269.580000,667070.700000 L269.340000,667070.280000 L269.520000,667070.160000 '></path><path style='stroke:black' d='M235.140000,667071.000000 L234.900000,667070.520000 L233.880000,667070.940000 L234.120000,667071.420000 '></path><path style='stroke:black' d='M235.140000,667071.000000 L234.960000,667071.060000 L234.780000,667070.640000 L234.960000,667070.580000 '></path><path style='stroke:black' d='M198.240000,667071.420000 L198.120000,667070.940000 L197.100000,667071.300000 L197.220000,667071.780000 '></path><path style='stroke:black' d='M198.300000,667071.420000 L198.060000,667071.480000 L197.880000,667071.000000 L198.120000,667070.940000 '></path><text y='667022.207684' x='312.7802' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X7</text><text y='667022.207684' x='329.876552' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X6</text><text y='667022.207684' x='349.135484' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X5</text><text y='667022.207684' x='366.1201' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X4</text><text y='667022.267584' x='384.0608' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='667022.267584' x='401.157152' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='667022.267584' x='420.416084' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='667022.267584' x='437.4007' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.717246'>X0</text><text y='667022.867684' x='149.8805' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y7</text><text y='667022.867684' x='166.976852' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y6</text><text y='667022.867684' x='186.235784' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y5</text><text y='667022.867684' x='203.2204' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y4</text><text y='667023.467784' x='221.7005' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='667023.467784' x='238.796852' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='667023.467784' x='258.055784' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='667023.467784' x='275.0404' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text></svg><svg width='216.0000075' viewBox='163.860000 667073.580005 144.000005 18.120005' height='27.1800075001'><rect y='667073.7' x='163.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='144.0'></rect><text y='667084.547484' x='168.1204' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y7</text><text y='667084.547484' x='185.8803' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X7</text><text y='667084.547484' x='203.459032' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y6</text><text y='667084.547484' x='222.240372' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X6</text><text y='667084.547484' x='239.340304' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y5</text><text y='667084.547484' x='257.579004' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X5</text><text y='667084.547484' x='274.56' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y4</text><text y='667084.547484' x='293.88' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X4</text></svg><h3>Figure 4-16.  PUNPCKHBW Instruction Operation Using 64-bit Operands</h3><p>31</p><p>0</p><p>255</p><p>255</p><p>31</p><p>0</p><table class='exception-table'><tr><td>X7</td><td>X6</td><td>X5</td><td>X4</td><td>X3</td><td>X2</td><td>X1</td><td>X0</td></tr></table><table class='exception-table'><tr><td>Y7</td><td>Y6</td><td>Y5</td><td>Y4</td><td>Y3</td><td>Y2</td><td>Y1</td><td>Y0</td></tr></table><p>SRC</p><p>255</p><p>0</p><table class='exception-table'><tr><td>Y7</td><td>X7</td><td>Y6</td><td>X6</td><td>Y3</td><td>X3</td><td>Y2</td><td>X2</td></tr></table><p>DEST</p><h3>Figure 4-17.  256-bit VPUNPCKHDQ Instruction Operation</h3><p>When the source data comes from a 64-bit memory operand, the full 64-bit operand is accessed from memory, but the instruction uses only the high-order 32 bits. When the source data comes from a 128-bit memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to a 16-byte boundary and normal segment checking will still be enforced.</p><p>The (V)PUNPCKHBW instruction interleaves the high-order bytes of the source and destination operands, the (V)PUNPCKHWD instruction interleaves the high-order words of the source and destination operands, the (V)PUNPCKHDQ instruction interleaves the high-order doubleword (or doublewords) of the source and destination operands, and the (V)PUNPCKHQDQ instruction interleaves the high-order quadwords of the source and destina-tion operands.</p><p>These instructions can be used to convert bytes to words, words to doublewords, doublewords to quadwords, and quadwords to double quadwords, respectively, by placing all 0s in the source operand. Here, if the source operand contains all 0s, the result (stored in the destination operand) contains zero extensions of the high-order data elements from the original value in the destination operand. For example, with the (V)PUNPCKHBW instruction the high-order bytes are zero extended (that is, unpacked into unsigned word integers), and with the (V)PUNPCKHWD instruction, the high-order words are zero extended (unpacked into unsigned doubleword integers).</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE versions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.</p><p>128-bit Legacy SSE versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded versions: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source operand and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html", "tooltip": "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destina-tion operand (first operand) and source operand (second operand) into the destination operand. Figure 4-16 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored."},
    "CVTDQ2PS": {"html": "<p>Converts four packed signed doubleword integers in the source operand (second operand) to four packed single-precision floating-point values in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding XMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operation is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "CVTDQ2PS.html", "tooltip": "Converts four packed signed doubleword integers in the source operand (second operand) to four packed single-precision floating-point values in the destination operand (first operand)."},
    "SHLD": {"html": "<p>The SHLD instruction is used for multi-precision shifts of 64 bits or more.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The instruction shifts the first operand (destination operand) to the left the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting with bit 0 of the destination operand).</p><p>The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or in the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode; only bits 0 through 4 of the count are used. This masks the count to a value between 0 and 31. If a count is greater than the operand size, the result is undefined.</p><p>If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "SHLD.html", "tooltip": "The SHLD instruction is used for multi-precision shifts of 64 bits or more."},
    "PMAXSD": {"html": "<p>Compares packed signed dword integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMAXSD.html", "tooltip": "Compares packed signed dword integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand."},
    "FSQRT": {"html": "<p>Computes the square root of the source value in the ST(0) register and stores the result in ST(0).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The following table shows the results obtained when taking the square root of various classes of numbers, assuming that neither overflow nor underflow occurs.</p><h3>Table 3-47.  FSQRT Results</h3><table><tr><th>SRC (ST(0))</th><th>DEST (ST(0))</th></tr><tr><td>− ∞</td><td>*</td></tr><tr><td>− F</td><td>*</td></tr><tr><td>− 0</td><td>− 0</td></tr><tr><td>+ 0</td><td>+ 0</td></tr><tr><td>+ F</td><td>+ F</td></tr><tr><td>+ ∞</td><td>+ ∞</td></tr><tr><td>NaN</td><td>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSQRT.html", "tooltip": "Computes the square root of the source value in the ST(0) register and stores the result in ST(0)."},
    "ADC": {"html": "<p>Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p><p>The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.</p><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "ADC.html", "tooltip": "Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format."},
    "DIVPD": {"html": "<p>Performs an SIMD divide of the two or four packed double-precision floating-point values in the first source operand by the two or four packed double-precision floating-point values in the second source operand. See Chapter 11 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a SIMD double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "DIVPD.html", "tooltip": "Performs an SIMD divide of the two or four packed double-precision floating-point values in the first source operand by the two or four packed double-precision floating-point values in the second source operand. See Chapter 11 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a SIMD double-precision floating-point operation."},
    "PCMPISTRI": {"html": "<p>The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to ECX.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Each string is represented by a single value.  The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data).  Each input byte/word is augmented with a valid/invalid tag.  A byte/word is considered valid only if it has a lower index than the least significant null byte/word.  (The least significant null byte/word is also considered invalid.)</p><p>The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).</p><p>Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-tion:</p><p>CFlag – Reset if IntRes2 is equal to zero, set otherwise</p><p>ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise</p><p>SFlag – Set if any byte/word of xmm1 is null, reset otherwise</p><p>OFlag –IntRes2[0]</p><p>AFlag – Reset</p><p>PFlag – Reset</p><p>Note: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PCMPISTRI.html", "tooltip": "The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte (see Section 4.1, 'Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to ECX."},
    "MOVNTDQ": {"html": "<p>Moves the packed integers in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register or YMM register, which is assumed to contain integer data (packed bytes, words, doublewords, or quad-words). The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see 'Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><p>Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTDQ instructions if multiple processors might use different memory types to read/write the destination memory locations.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instruc-tions will #UD.</p></span>", "url": "MOVNTDQ.html", "tooltip": "Moves the packed integers in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register or YMM register, which is assumed to contain integer data (packed bytes, words, doublewords, or quad-words). The destination operand is a 128-bit or 256-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version) or 32-byte (VEX.256 encoded version) boundary otherwise a general-protection exception (#GP) will be generated."},
    "MULPD": {"html": "<p>Performs a SIMD multiply of the two or four packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "MULPD.html", "tooltip": "Performs a SIMD multiply of the two or four packed double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed double-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 11-3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD double-precision floating-point operation."},
    "CLD": {"html": "<p>Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index regis-ters (ESI and/or EDI). Operation is the same in all modes.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'></span>", "url": "CLD.html", "tooltip": "Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index regis-ters (ESI and/or EDI). Operation is the same in all modes."},
    "PTEST": {"html": "<p>PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The first source register is specified by the ModR/M <em>reg</em> field.</p><p>128-bit versions: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.</p><p>VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "PTEST.html", "tooltip": "PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand."},
    "CVTPI2PD": {"html": "<p>Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. In addition, depending on the operand configuration:</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "CVTPI2PD.html", "tooltip": "Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand)."},
    "BOUND": {"html": "<p>BOUND determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory loca-tion that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the saved return instruction pointer points to the BOUND instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles to obtain the effective address of the array bounds.</p><p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "BOUND.html", "tooltip": "BOUND determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory loca-tion that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the saved return instruction pointer points to the BOUND instruction."},
    "SQRTSS": {"html": "<p>Computes the square root of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order double-words of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "SQRTSS.html", "tooltip": "Computes the square root of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order double-words of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation."},
    "FXRSTOR": {"html": "<p>Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with FXSAVE64/FXRSTOR64. Table 3-53 shows the layout of the legacy/compatibility mode state information in memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-56 shows the layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-57 shows the layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be in the same format as required by Table 3-53, Table 3-56, or Table 3-57. Referencing a state image saved with an FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.</p><p>The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.</p><p>If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM and MXCSR registers. This behavior is implementation dependent.</p><p>If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next occurrence of this unmasked exception will result in the exception being generated.</p><p>Bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1 in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.</p><p>Bytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511 in an FXSAVE state image.</p></span>", "url": "FXRSTOR.html", "tooltip": "Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with FXSAVE64/FXRSTOR64. Table 3-53 shows the layout of the legacy/compatibility mode state information in memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-56 shows the layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-57 shows the layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR)."},
    "ADDSUBPS": {"html": "<p>Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the corresponding single-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single-precision floating-point values from the second source operand from the corresponding single-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-4.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><svg width='555.3' viewBox='116.340000 19096.980000 370.200000 163.440000' height='245.16'><text y='19114.5580139' x='220.8683' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='116.4683674'>ADDSUBPS xmm1, xmm2/m128</text><text y='19135.0716139' x='436.5524' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.0009'>xmm2/</text><text y='19139.8710139' x='149.8803' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='19139.8710139' x='228.6136' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='19139.8710139' x='305.1167' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='19139.8710139' x='383.8399' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='19144.6719139' x='436.5524' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0087503'>m128</text><text y='19189.0736139' x='436.5524' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='32.3052114'>RESULT:</text><text y='19189.0780139' x='139.0' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='52.351054'>xmm1[127:96] +</text><text y='19189.0780139' x='206.8127' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='70.322637'>xmm1[95:64] - xmm2/</text><text y='19189.0780139' x='293.9662' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='48.307266'>xmm1[63:32] +</text><text y='19189.0780139' x='373.3094' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='42.437955'>xmm1[31:0] -</text><text y='19198.6740139' x='436.5524' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='19198.6784139' x='132.2499' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='66.293395'>xmm2/m128[127:96]</text><text y='19198.6784139' x='221.2736' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.430607'>m128[95:64]</text><text y='19198.6784139' x='287.2161' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='62.249607'>xmm2/m128[63:32]</text><text y='19198.6784139' x='365.6793' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='58.205819'>xmm2/m128[31:0]</text><text y='19221.9493139' x='149.8907' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='19221.9493139' x='228.62405239' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='19221.9493139' x='305.12692114' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='19221.9493139' x='383.84987314' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='19251.8077093' x='451.6066' style='font-size:6.000200pt' lengthAdjust='spacingAndGlyphs' textLength='26.3468782'>OM15992</text><rect y='19097.723' x='117.089' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='139.506' width='360.015'></rect><path style='stroke:black' d='M164.341000,19166.816000 L164.341000,19150.605000 '></path><path style='stroke:black' d='M240.844000,19166.816000 L240.844000,19150.605000 '></path><path style='stroke:black' d='M317.347000,19166.816000 L317.347000,19150.605000 '></path><path style='stroke:black' d='M393.850000,19166.816000 L393.850000,19150.605000 '></path><path style='stroke:black' d='M167.101000,19166.456000 L164.341000,19171.976000 L161.581000,19166.456000 L167.101000,19166.456000 '></path><path style='stroke:black' d='M243.604000,19166.456000 L240.844000,19171.976000 L238.084000,19166.456000 L243.604000,19166.456000 '></path><path style='stroke:black' d='M320.107000,19166.456000 L317.347000,19171.976000 L314.587000,19166.456000 L320.107000,19166.456000 '></path><path style='stroke:black' d='M396.610000,19166.456000 L393.850000,19171.976000 L391.090000,19166.456000 L396.610000,19166.456000 '></path><rect y='19097.723' x='117.089' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='139.506' width='360.015'></rect><rect y='19123.599' x='355.599' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19123.599' x='279.096' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19123.599' x='202.593' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19123.599' x='126.089' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19171.976' x='355.599' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='19171.976' x='279.096' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='19171.976' x='202.593' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='19171.976' x='126.089' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='19123.599' x='355.599' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19123.599' x='279.096' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19123.599' x='202.593' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19123.599' x='126.089' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='19171.976' x='355.599' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='19171.976' x='279.096' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='19171.976' x='202.593' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='19171.976' x='126.089' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect></svg><h3>Figure 3-4.  ADDSUBPS—Packed Single-FP Add/Subtract</h3></span>", "url": "ADDSUBPS.html", "tooltip": "Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the corresponding single-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single-precision floating-point values from the second source operand from the corresponding single-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand."},
    "MINSD": {"html": "<p>Compares the low double-precision floating-point values in the first source operand and the second source operand, and returns the minimum value to the low quadword of the destination operand. When the source operand is a memory operand, only the 64 bits are accessed. The high quadword of the destination operand is copied from the same bits in the first source operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "MINSD.html", "tooltip": "Compares the low double-precision floating-point values in the first source operand and the second source operand, and returns the minimum value to the low quadword of the destination operand. When the source operand is a memory operand, only the 64 bits are accessed. The high quadword of the destination operand is copied from the same bits in the first source operand."},
    "VFNMADD132PD": {"html": "<p>VFNMADD132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the two or four packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFNMADD213PD: Multiplies the two or four packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the two or four packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VFNMADD231PD: Multiplies the two or four packed double-precision floating-point values from the second source to the two or four packed double-precision floating-point values in the third source operand, adds the negated infi-nite precision intermediate result to the two or four packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a</p><p>XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFNMADD132PD:VFNMADD213PD:VFNMADD231PD.html", "tooltip": "VFNMADD132PD: Multiplies the two or four packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the two or four packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand)."},
    "FISTTP": {"html": "<p>FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The following table shows the results obtained when storing various classes of numbers in integer format.</p><h3>Table 3-38.  FISTTP Results</h3><table><tr><th>ST(0)</th><th>DEST</th></tr><tr><td>− ∞  or  Value Too Large for DEST Format</td><td>*</td></tr><tr><td>F ≤  − 1</td><td>− I</td></tr><tr><td>− 1 &lt; F &lt; + 1</td><td>0</td></tr><tr><td>F Š + 1</td><td>+ I</td></tr><tr><td>+ ∞  or Value Too Large for DEST Format</td><td>*</td></tr><tr><td>NaN</td><td>*</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>Ι</p><p>Means integer.</p><p>∗ Indicates floating-point invalid-operation (#IA) exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FISTTP.html", "tooltip": "FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations."},
    "FSTENV": {"html": "<p>Saves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, show the layout in memory of the stored environ-ment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.</p><p>These instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.</p><p>The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSTENV:FNSTENV.html", "tooltip": "Saves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, show the layout in memory of the stored environ-ment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used."},
    "FILD": {"html": "<p>Converts the signed-integer source operand into double extended-precision floating-point format and pushes the value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded without rounding errors. The sign of the source operand is preserved.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FILD.html", "tooltip": "Converts the signed-integer source operand into double extended-precision floating-point format and pushes the value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded without rounding errors. The sign of the source operand is preserved."},
    "PMAXUW": {"html": "<p>Compares packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PMAXUW.html", "tooltip": "Compares packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and returns the maximum for each packed value in the destination operand."},
    "DIVPS": {"html": "<p>Performs an SIMD divide of the four or eight packed single-precision floating-point values in the first source operand by the four or eight packed single-precision floating-point values in the second source operand. See Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a SIMD single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "DIVPS.html", "tooltip": "Performs an SIMD divide of the four or eight packed single-precision floating-point values in the first source operand by the four or eight packed single-precision floating-point values in the second source operand. See Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a SIMD single-precision floating-point operation."},
    "ORPS": {"html": "<p>Performs a bitwise logical OR of the four or eight packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the destination YMM register destination are zeroed.</p><p>VEX.256 Encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: If VORPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "ORPS.html", "tooltip": "Performs a bitwise logical OR of the four or eight packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand."},
    "ANDN": {"html": "<p>Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the second source operand). The result is stored in the first operand (destination operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p></span>", "url": "ANDN.html", "tooltip": "Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the second source operand). The result is stored in the first operand (destination operand)."},
    "HADDPS": {"html": "<p>Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores the result in the first dword of the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Adds single-precision floating-point values in the third and fourth dword of the destination operand and stores the result in the second dword of the destination operand.</p><p>Adds single-precision floating-point values in the first and second dword of the source operand and stores the result in the third dword of the destination operand.</p><p>Adds single-precision floating-point values in the third and fourth dword of the source operand and stores the result in the fourth dword of the destination operand.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>See Figure 3-17 for HADDPS; see Figure 3-18 for VHADDPS.</p><svg width='551.16' viewBox='118.260000 289179.000000 367.440000 236.970000' height='355.455'><text y='289197.682214' x='229.221' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='105.7959672'>HADDPS xmm1, xmm2/m128</text><text y='289218.195814' x='432.5998' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.0009'>xmm2/</text><text y='289222.996214' x='174.8588' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='289222.996214' x='245.1366' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='289222.996214' x='312.6394' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='289222.996214' x='382.3622' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='289227.796114' x='432.5998' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0087503'>m128</text><text y='289282.392014' x='432.5991' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='289282.392514' x='174.8588' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='289282.392514' x='245.1366' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='289282.392514' x='312.6394' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='289282.392514' x='382.3622' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='289341.243914' x='169.9286' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.008773'>xmm2/m128</text><text y='289341.243914' x='238.0063' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.008773'>xmm2/m128</text><text y='289346.001414' x='432.5998' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='32.3052114'>RESULT:</text><text y='289346.044214' x='301.4889' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='48.307266'>xmm1[95:64] +</text><text y='289346.044214' x='370.9518' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='44.263478'>xmm1[31:0] +</text><text y='289350.844314' x='163.948' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='52.351054'>[95:64] + xmm2/</text><text y='289350.844314' x='233.9865' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='48.307266'>[31:0] + xmm2/</text><text y='289355.601714' x='432.5998' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='289355.644614' x='302.5689' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='46.081728'>xmm1[127:96]</text><text y='289355.644614' x='372.0217' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='42.03794'>xmm1[63:32]</text><text y='289360.444614' x='167.7583' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='44.474395'>m128[127:96]</text><text y='289360.444614' x='237.7968' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.430607'>m128[63:32]</text><text y='289385.052714' x='175.414' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='289385.052714' x='245.14701489' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='289385.052714' x='308.1488' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='289385.052714' x='386.871752' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='289410.061009' x='454.6292' style='font-size:6.000200pt' lengthAdjust='spacingAndGlyphs' textLength='26.3468782'>OM15994</text><rect y='289179.723' x='118.986' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='216.009' width='361.14'></rect><path style='stroke:black' d='M257.367000,289233.725000 L257.367000,289253.976000 L147.863000,289253.976000 L147.863000,289252.319000 L146.519000,289250.976000 L144.862000,289250.976000 L143.205000,289250.976000 L141.862000,289252.319000 L141.862000,289253.976000 L133.612000,289253.976000 L133.612000,289314.728000 L189.864000,289314.728000 L189.864000,289320.548000 '></path><path style='stroke:black' d='M392.373000,289233.725000 L392.373000,289244.975000 L260.368000,289244.975000 L260.368000,289243.318000 L259.025000,289241.975000 L257.367000,289241.975000 L255.710000,289241.975000 L254.367000,289243.318000 L254.367000,289244.975000 L192.865000,289244.975000 L192.865000,289243.318000 L191.522000,289241.975000 L189.865000,289241.975000 L188.208000,289241.975000 L186.865000,289243.318000 L186.865000,289244.975000 L144.863000,289244.975000 L144.863000,289310.228000 L257.367000,289310.228000 L257.367000,289320.548000 '></path><path style='stroke:black' d='M189.864000,289233.725000 L189.864000,289253.976000 '></path><path style='stroke:black' d='M324.870000,289233.725000 L324.870000,289244.975000 '></path><path style='stroke:black' d='M257.367000,289305.728000 L257.367000,289293.118000 '></path><path style='stroke:black' d='M189.865000,289293.122000 L189.865000,289305.733000 L324.870000,289305.733000 L324.870000,289320.413000 '></path><path style='stroke:black' d='M324.870000,289293.122000 L324.870000,289301.232000 L392.373000,289301.232000 L392.373000,289320.413000 '></path><path style='stroke:black' d='M392.373000,289303.347000 L392.373000,289293.127000 '></path><path style='stroke:black' d='M326.910000,289320.413000 L324.870000,289324.493000 L322.830000,289320.413000 L326.910000,289320.413000 '></path><path style='stroke:black' d='M394.413000,289320.413000 L392.373000,289324.493000 L390.333000,289320.413000 L394.413000,289320.413000 '></path><path style='stroke:black' d='M191.904000,289320.549000 L189.864000,289324.629000 L187.824000,289320.549000 L191.904000,289320.549000 '></path><path style='stroke:black' d='M259.407000,289320.549000 L257.367000,289324.629000 L255.327000,289320.549000 L259.407000,289320.549000 '></path><rect y='289179.723' x='118.986' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='216.009' width='361.14'></rect><rect y='289206.724' x='291.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289266.121' x='291.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289206.724' x='223.616' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289266.121' x='223.616' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289206.724' x='358.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289266.121' x='358.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289206.724' x='154.988' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='289266.121' x='154.988' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='289324.492' x='291.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='289324.492' x='223.616' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='289324.492' x='358.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='289324.492' x='154.988' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='68.628'></rect><rect y='289206.724' x='291.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289266.121' x='291.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289206.724' x='223.616' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289266.121' x='223.616' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289206.724' x='358.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289266.121' x='358.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='67.503'></rect><rect y='289206.724' x='154.988' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='289266.121' x='154.988' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='68.628'></rect><rect y='289324.492' x='291.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='289324.492' x='223.616' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='289324.492' x='358.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='67.503'></rect><rect y='289324.492' x='154.988' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='47.1519999999' width='68.628'></rect></svg><h3>Figure 3-17.  HADDPS—Packed Single-FP Horizontal Add</h3><p>X7</p><p>X6</p><p>X5</p><p>X4</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>SRC1</p><p>Y7</p><p>Y6</p><p>Y5</p><p>Y4</p><p>Y3</p><p>Y2</p><p>Y1</p><p>Y0</p><p>SRC2</p><p>DEST</p><p>Y6+Y7</p><p>Y4+Y5</p><p>X6+X7</p><p>X4+X5</p><p>Y2+Y3</p><p>Y0+Y1</p><p>X2+X3</p><p>X0+X1</p><h3>Figure 3-18.  VHADDPS operation</h3><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "HADDPS.html", "tooltip": "Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores the result in the first dword of the destination operand."},
    "PSHUFB": {"html": "<p>PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>Legacy SSE version: Both operands can be MMX registers.</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The destination operand is the first operand, the first source operand is the second operand, the second source operand is the third operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: Bits (255:128) of the destination YMM register stores the 16-byte shuffle result of the upper 16 bytes of the first source operand, using the upper 16-bytes of the second source operand as control mask. The value of each index is for the high 128-bit lane is the least significant 4 bits of the respective shuffle control byte. The index value selects a source data element within each 128-bit lane.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PSHUFB.html", "tooltip": "PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},
    "VPBLENDD": {"html": "<p>Dword elements from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is '1', then the word is copied, else the word is unchanged.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "VPBLENDD.html", "tooltip": "Dword elements from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is '1', then the word is copied, else the word is unchanged."},
    "PSLLW": {"html": "<p>Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-13 gives an example of shifting words in a 64-bit operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='568.799985' viewBox='111.840000 640385.040010 379.199990 87.599990' height='131.399985'><text y='640403.267584' x='158.2199' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='30.975168'>Pre-Shift</text><text y='640411.607484' x='168.72' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='640423.045488' x='161.58' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='27.928392'>Shift Left</text><text y='640430.845388' x='160.92' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='28.5012'>with Zero</text><text y='640438.645488' x='160.3799' style='font-size:6.960000pt' lengthAdjust='spacingAndGlyphs' textLength='29.379552'>Extension</text><text y='640456.127884' x='153.3601' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='34.558986'>Post-Shift</text><text y='640464.107384' x='167.7' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='640395.6' x='192.84' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='640395.6' x='381.54' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='640395.6' x='255.72' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.88'></rect><rect y='640395.6' x='318.6' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='62.94'></rect><rect y='640448.58' x='192.24' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0600000001' width='62.94'></rect><path style='stroke:black' d='M192.600000,640395.360000 L192.600000,640413.600000 L193.080010,640413.600000 L193.080010,640395.360000 '></path><path style='stroke:black' d='M255.480000,640395.360000 L255.480000,640413.600000 L255.960000,640413.600000 L255.960000,640395.360000 '></path><path style='stroke:black' d='M318.360000,640395.360000 L318.360000,640413.600000 L318.839980,640413.600000 L318.839980,640395.360000 '></path><path style='stroke:black' d='M381.300000,640395.360000 L381.300000,640413.600000 L381.779980,640413.600000 L381.779980,640395.360000 '></path><path style='stroke:black' d='M192.840000,640395.360020 L192.840000,640395.840000 L255.960000,640395.840000 L255.960000,640395.360020 '></path><path style='stroke:black' d='M255.720000,640395.360020 L255.720000,640395.840000 L318.840000,640395.840000 L318.840000,640395.360020 '></path><path style='stroke:black' d='M318.600000,640395.360020 L318.600000,640395.840000 L381.780000,640395.840000 L381.780000,640395.360020 '></path><path style='stroke:black' d='M381.540000,640395.360020 L381.540000,640395.840000 L444.660000,640395.840000 L444.660000,640395.360020 '></path><path style='stroke:black' d='M255.480000,640395.600000 L255.480000,640413.840000 L255.960000,640413.840000 L255.960000,640395.600000 '></path><path style='stroke:black' d='M318.360000,640395.600000 L318.360000,640413.840000 L318.839980,640413.840000 L318.839980,640395.600000 '></path><path style='stroke:black' d='M381.300000,640395.600000 L381.300000,640413.840000 L381.779980,640413.840000 L381.779980,640395.600000 '></path><path style='stroke:black' d='M444.180000,640395.600000 L444.180000,640413.840000 L444.659980,640413.840000 L444.659980,640395.600000 '></path><path style='stroke:black' d='M192.600000,640413.360020 L192.600000,640413.840000 L255.720000,640413.840000 L255.720000,640413.360020 '></path><path style='stroke:black' d='M255.480000,640413.360020 L255.480000,640413.840000 L318.600000,640413.840000 L318.600000,640413.360020 '></path><path style='stroke:black' d='M318.360000,640413.360020 L318.360000,640413.840000 L381.540000,640413.840000 L381.540000,640413.360020 '></path><path style='stroke:black' d='M381.300000,640413.360020 L381.300000,640413.840000 L444.420000,640413.840000 L444.420000,640413.360020 '></path><path style='stroke:black' d='M236.520000,640413.780000 L236.520000,640428.720000 L237.000000,640428.720000 L237.000000,640413.780000 '></path><path style='stroke:black' d='M300.240000,640413.780000 L300.240000,640428.720000 L300.720010,640428.720000 L300.720010,640413.780000 '></path><path style='stroke:black' d='M418.680000,640413.840000 L418.680000,640428.780000 L419.159980,640428.780000 L419.159980,640413.840000 '></path><path style='stroke:black' d='M356.940000,640414.260000 L356.940000,640429.200000 L357.420010,640429.200000 L357.420010,640414.260000 '></path><path style='stroke:black' d='M210.780000,640428.239990 L210.780000,640428.720000 L236.760000,640428.720000 L236.760000,640428.239990 '></path><path style='stroke:black' d='M274.500000,640428.239990 L274.500000,640428.720000 L300.480000,640428.720000 L300.480000,640428.239990 '></path><path style='stroke:black' d='M392.940000,640428.299990 L392.940000,640428.780000 L418.920000,640428.780000 L418.920000,640428.299990 '></path><path style='stroke:black' d='M210.780000,640428.480000 L210.780000,640441.440000 L211.260000,640441.440000 L211.260000,640428.480000 '></path><path style='stroke:black' d='M274.500000,640428.480000 L274.500000,640441.380000 L274.980010,640441.380000 L274.980010,640428.480000 '></path><path style='stroke:black' d='M392.940000,640428.540000 L392.940000,640441.440000 L393.420010,640441.440000 L393.420010,640428.540000 '></path><path style='stroke:black' d='M331.260000,640428.719990 L331.260000,640429.200000 L357.180000,640429.200000 L357.180000,640428.719990 '></path><path style='stroke:black' d='M331.260000,640428.960000 L331.260000,640441.860000 L331.739980,640441.860000 L331.739980,640428.960000 '></path><path style='stroke:black' d='M274.560000,640441.740000 L276.120000,640441.140000 L277.080000,640440.780000 L276.780000,640441.800000 L275.220000,640447.200000 L274.740000,640448.880000 L274.260000,640447.200000 L272.700000,640441.800000 L272.400000,640440.780000 L273.360000,640441.140000 L273.660000,640441.500000 L275.220000,640446.900000 L274.260000,640447.200000 L274.260000,640446.900000 L275.820000,640441.500000 L276.780000,640441.800000 L276.480000,640442.100000 L274.920000,640442.700000 '></path><path style='stroke:black' d='M210.840000,640441.740000 L212.400000,640441.200000 L213.360000,640440.840000 L213.060000,640441.860000 L211.500000,640447.200000 L211.020000,640448.820000 L210.540000,640447.200000 L208.980000,640441.860000 L208.680000,640440.840000 L209.640000,640441.200000 L209.940000,640441.560000 L211.500000,640446.900000 L210.540000,640447.200000 L210.540000,640446.900000 L212.100000,640441.560000 L213.060000,640441.860000 L212.760000,640442.160000 L211.200000,640442.700000 '></path><path style='stroke:black' d='M393.000000,640441.800000 L394.560000,640441.200000 L395.520000,640440.840000 L395.220000,640441.860000 L393.660000,640447.260000 L393.180000,640449.000000 L392.700000,640447.260000 L391.200000,640441.860000 L390.900000,640440.840000 L391.860000,640441.200000 L392.160000,640441.560000 L393.660000,640446.960000 L392.700000,640447.260000 L392.700000,640446.960000 L394.260000,640441.560000 L395.220000,640441.860000 L394.920000,640442.160000 L393.360000,640442.760000 '></path><path style='stroke:black' d='M273.360000,640441.140000 L274.920000,640441.740000 L274.920000,640442.700000 L274.740000,640442.760000 L274.560000,640442.700000 L273.000000,640442.100000 '></path><path style='stroke:black' d='M274.500000,640441.140000 L274.500000,640442.220000 L274.980010,640442.220000 L274.980010,640441.140000 '></path><path style='stroke:black' d='M209.640000,640441.200000 L211.200000,640441.740000 L211.200000,640442.700000 L211.020000,640442.760000 L210.840000,640442.700000 L209.280000,640442.160000 '></path><path style='stroke:black' d='M210.780000,640441.200000 L210.780000,640442.220000 L211.260000,640442.220000 L211.260000,640441.200000 '></path><path style='stroke:black' d='M391.860000,640441.200000 L393.360000,640441.800000 L393.360000,640442.760000 L393.180000,640442.820000 L393.000000,640442.760000 L391.500000,640442.160000 '></path><path style='stroke:black' d='M392.940000,640441.200000 L392.940000,640442.280000 L393.420010,640442.280000 L393.420010,640441.200000 '></path><path style='stroke:black' d='M331.320000,640442.220000 L332.880000,640441.680000 L333.840000,640441.320000 L333.540000,640442.340000 L331.980000,640447.680000 L331.500000,640449.300000 L331.020000,640447.680000 L329.460000,640442.340000 L329.160000,640441.320000 L330.120000,640441.680000 L330.420000,640442.040000 L331.980000,640447.380000 L331.020000,640447.680000 L331.020000,640447.380000 L332.580000,640442.040000 L333.540000,640442.340000 L333.240000,640442.640000 L331.680000,640443.180000 '></path><path style='stroke:black' d='M274.740000,640442.220000 L276.300000,640441.620000 L274.740000,640447.020000 L273.180000,640441.620000 '></path><path style='stroke:black' d='M331.260000,640441.620000 L331.260000,640442.700000 L331.739980,640442.700000 L331.739980,640441.620000 '></path><path style='stroke:black' d='M211.020000,640442.220000 L212.580000,640441.680000 L211.020000,640447.020000 L209.460000,640441.680000 '></path><path style='stroke:black' d='M330.120000,640441.680000 L331.680000,640442.220000 L331.680000,640443.180000 L331.500000,640443.240000 L331.320000,640443.180000 L329.760000,640442.640000 '></path><path style='stroke:black' d='M393.180000,640442.280000 L394.740000,640441.680000 L393.180000,640447.080000 L391.680000,640441.680000 '></path><path style='stroke:black' d='M331.500000,640442.700000 L333.060000,640442.160000 L331.500000,640447.500000 L329.940000,640442.160000 '></path><text y='640407.347684' x='219.0598' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='640407.347484' x='406.08' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='640407.347684' x='282.775312' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='640407.347684' x='343.793584' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='640461.107384' x='197.0398' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.5835'>X3 &lt;&lt; COUNT</text></svg><svg width='377.3700225' viewBox='192.240005 640448.579995 251.580015 18.060015' height='27.0900224999'><rect y='640448.58' x='255.18' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0600000001' width='62.88'></rect><rect y='640448.58' x='318.06' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0600000001' width='62.88'></rect><rect y='640448.58' x='380.94' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0600000001' width='62.88'></rect><text y='640461.107384' x='260.8201' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.5832'>X2 &lt;&lt; COUNT</text><text y='640461.107384' x='324.0599' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='53.5834'>X1 &lt;&lt; COUNT</text><text y='640461.107184' x='384.6601' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='11.997132'>X0 &lt;&lt; COUNT</text></svg><h3>Figure 4-13.  PSLLW, PSLLD, and PSLLQ Instruction Operation Using 64-bit Operand</h3><p>The (V)PSLLW instruction shifts each of the words in the destination operand to the left by the number of bits spec-ified in the count operand; the (V)PSLLD instruction shifts each of the doublewords in the destination operand; and the (V)PSLLQ instruction shifts the quadword (or quadwords) in the destination operand.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The destination operand is an MMX technology register; the count operand can be either an MMX technology register or an 64-bit memory location.</p><p>128-bit Legacy SSE version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.</p><p>VEX.128 encoded version: The destination and first source operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register are zeroed. The count operand can be either an XMM register or a 128-bit memory loca-tion or an 8-bit immediate. If the count operand is a memory address, 128 bits are loaded but the upper 64 bits are ignored.</p><p>VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an XMM register or a 128-bit memory location or an 8-bit immediate.</p><p>Note: For shifts with an immediate count (VEX.128.66.0F 71-73 /6), VEX.vvvv encodes the destination register, and VEX.B + ModRM.r/m encodes the source register. VEX.L must be 0, otherwise instructions will #UD.</p></span>", "url": "PSLLW:PSLLD:PSLLQ.html", "tooltip": "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-13 gives an example of shifting words in a 64-bit operand."},
    "DAS": {"html": "<p>Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register. The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal borrow is detected, the CF and AF flags are set accordingly.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "DAS.html", "tooltip": "Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL register. The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal borrow is detected, the CF and AF flags are set accordingly."},
    "AAD": {"html": "<p>Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H. The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.</p><p>The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the 'Operation” section below), by setting the <em>imm8</em> byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 <em>imm8</em>).</p><p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "AAD.html", "tooltip": "Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value."},
    "MOVS": {"html": "<p>Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the assembly-code level, two forms of this instruction are allowed: the 'explicit-operands” form and the 'no-operands” form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct <strong>type</strong> (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct <strong>location</strong>. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.</p><p>The no-operands form provides 'short forms” of the byte, word, and doubleword versions of the MOVS instruc-tions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).</p><p>After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-</p><p>mented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.</p><h3>NOTE</h3><p>To improve performance, more recent processors support modifications to the processor’s operation during the string store operations initiated with MOVS and MOVSB. See Section 7.3.9.3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em> for additional information on fast-string operation.</p><p>The MOVS, MOVSB, MOVSW, and MOVSD instructions can be preceded by the REP prefix (see 'REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B</em>, for a description of the REP prefix) for block moves of ECX bytes, words, or doublewords.</p><p>In 64-bit mode, the instruction’s default address size is 64 bits, 32-bit address size is supported using the prefix 67H. The 64-bit addresses are specified by RSI and RDI; 32-bit address are specified by ESI and EDI. Use of the REX.W prefix promotes doubleword operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html", "tooltip": "Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden."},
    "VGATHERDPS": {"html": "<p>The instruction conditionally loads up to 4 or 8 single-precision floating-point values from memory addresses spec-ified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The mask operand (the third operand) specifies the conditional load operation from each memory address and the corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-fied by the most significant bit of each data element of the mask register. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The width of data element in the destination register and mask register are identical. The entire mask register will be set to zero by this instruction unless the instruction causes an exception.</p><p>Using qword indices, the instruction conditionally loads up to 2 or 4 single-precision floating-point values from the VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destination register are zero’ed with qword indices.</p><p>This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set).  When this happens, the destination register and the mask operand are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero.  If any traps or interrupts are pending from already gath-ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.</p><p>If the data size and index size are different, part of the destination register and part of the mask register do not correspond to any elements being gathered.  This instruction sets those parts to zero.  It may do this to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.</p><p>VEX.128 version: For dword indices, the instruction will gather four single-precision floating-point values.  For qword indices, the instruction will gather two values and zeroes the upper 64 bits of the destination.</p><p>VEX.256 version: For dword indices, the instruction will gather eight single-precision floating-point values.  For qword indices, the instruction will gather four values and zeroes the upper 128 bits of the destination.</p><p>Note that:</p></span>", "url": "VGATHERDPS:VGATHERQPS.html", "tooltip": "The instruction conditionally loads up to 4 or 8 single-precision floating-point values from memory addresses spec-ified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an array of indices relative to the base and a constant scale factor."},
    "XRSTORS": {"html": "<p>Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The format of the XSAVE area is detailed in Section 13.4, 'XSAVE Area,” of <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>.</p><p>Section 13.11, 'Operation of XRSTORS,” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em> provides a detailed description of the operation of the XRSTOR instruction. The following items provide a high-level outline:</p><p>for which RFBM[<em>i</em>] = 0.</p><p><em>i</em></p><p>Use of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protec-tion (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</p></span>", "url": "XRSTORS.html", "tooltip": "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0."},
    "PANDN": {"html": "<p>Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corre-sponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PANDN.html", "tooltip": "Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corre-sponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0."},
    "FPREM": {"html": "<p>Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or <strong>modulus</strong>), and stores the result in ST(0). The remainder represents the following value:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Remainder ← ST(0) − (Q ∗ ST(1))</p><p>Here, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)] toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is less than that of the modulus, unless a partial remainder was computed (as described below).</p><p>This instruction produces an exact result; the inexact-result exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur.</p><h3>Table 3-41.  FPREM Results</h3><table><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><th colspan='2'>ST(1)</th><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td><td colspan='2'></td></tr><tr><td colspan='2'></td><td colspan='2'></td><td colspan='2'>-∞</td><td colspan='2'>-F</td><td colspan='2'>-0</td><td colspan='2'>+0</td><td colspan='2'>+F</td><td colspan='2'>+∞</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>-∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><th colspan='2'>ST(0)</th><td colspan='2'>-F</td><td colspan='2'>ST(0)</td><td colspan='2'>-F or -0</td><td colspan='2'>**</td><td colspan='2'>**</td><td colspan='2'>-F or -0</td><td colspan='2'>ST(0)</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>-0</td><td colspan='2'>-0</td><td colspan='2'>-0</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>-0</td><td colspan='2'>-0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+0</td><td colspan='2'>+0</td><td colspan='2'>+0</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>+0</td><td colspan='2'>+0</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+F</td><td colspan='2'>ST(0)</td><td colspan='2'>+F or +0</td><td colspan='2'>**</td><td colspan='2'>**</td><td colspan='2'>+F or +0</td><td colspan='2'>ST(0)</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>+∞</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>*</td><td colspan='2'>NaN</td></tr><tr><td colspan='2'></td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td><td colspan='2'>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>** Indicates floating-point zero-divide (#Z) exception.</p><p>When the result is 0, its sign is the same as that of the dividend. When the modulus is ∞, the result is equal to the value in ST(0).</p><p>The FPREM instruction does not compute the remainder specified in IEEE Std 754. The IEEE specified remainder can be computed with the FPREM1 instruction. The FPREM instruction is provided for compatibility with the Intel 8087 and Intel287 math coprocessors.</p><p>The FPREM instruction gets its name 'partial remainder” because of the way it computes the remainder. This instruction arrives at a remainder through iterative subtraction. It can, however, reduce the exponent of ST(0) by no more than 63 in one execution of the instruction. If the instruction succeeds in producing a remainder that is less than the modulus, the operation is complete and the C2 flag in the FPU status word is cleared. Otherwise, C2 is set, and the result in ST(0) is called the <strong>partial remainder</strong>. The exponent of the partial remainder will be less than the exponent of the original dividend by at least 32. Software can re-execute the instruction (using the partial remainder in ST(0) as the dividend) until C2 is cleared. (Note that while executing such a remainder-computation loop, a higher-priority interrupting routine that needs the FPU can force a context switch in-between the instruc-tions in the loop.)</p><p>An important use of the FPREM instruction is to reduce the arguments of periodic functions. When reduction is complete, the instruction stores the three least-significant bits of the quotient in the C3, C1, and C0 flags of the FPU</p><p>status word. This information is important in argument reduction for the tangent function (using a modulus of π/4), because it locates the original angle in the correct one of eight sectors of the unit circle.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FPREM.html", "tooltip": "Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or <strong>modulus</strong>), and stores the result in ST(0). The remainder represents the following value:"},
    "MOVSLDUP": {"html": "<p>The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision elements in positions 0 and 2 are duplicated. When the register-register form of this operation is used, the same operation is performed but with data coming from the 128-bit source register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>See Figure 3-26.</p><svg width='555.3' viewBox='118.380000 441586.740000 370.200000 163.500000' height='245.25'><text y='441604.322114' x='222.4403' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='117.2123953'>MOVSLDUP xmm1, xmm2/m128</text><text y='441624.835714' x='438.574' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.0009'>xmm2/</text><text y='441629.635114' x='151.9024' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='441629.635114' x='230.6356' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='441629.635114' x='307.1387' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='441629.635114' x='385.8619' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='441634.436014' x='438.574' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0087503'>m128</text><text y='441674.042014' x='144.0621' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='46.081728'>xmm1[127:96]</text><text y='441674.042014' x='222.5153' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='42.03794'>xmm1[95:64]</text><text y='441674.042014' x='299.0184' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='42.03794'>xmm1[63:32]</text><text y='441674.042014' x='377.4815' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='37.994152'>xmm1[31:0]</text><text y='441678.837714' x='438.574' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='32.3052114'>RESULT:</text><text y='441683.642414' x='145.0425' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='44.059834'>xmm2/</text><text y='441683.642414' x='222.5255' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='42.03794'>xmm2/</text><text y='441683.642414' x='300.0083' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.016046'>xmm2/</text><text y='441683.642414' x='378.4619' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='35.972258'>xmm2/</text><text y='441688.438114' x='438.574' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='441693.242714' x='146.7924' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.430607'>m128[95:64]</text><text y='441693.242714' x='223.2957' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='40.430607'>m128[95:64]</text><text y='441693.242714' x='301.7581' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='36.386819'>m128[31:0]</text><text y='441693.242714' x='378.2619' style='font-size:7.273000pt' lengthAdjust='spacingAndGlyphs' textLength='36.386819'>m128[31:0]</text><text y='441711.713414' x='151.9128' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:96]</text><text y='441711.713414' x='230.64615239' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[95:64]</text><text y='441711.713414' x='307.14902114' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='24.4649174'>[63:32]</text><text y='441711.713414' x='385.87197314' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[31:0]</text><text y='441741.571909' x='453.6286' style='font-size:6.000200pt' lengthAdjust='spacingAndGlyphs' textLength='26.3468782'>OM15999</text><rect y='441587.487' x='119.111' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='139.506' width='360.015'></rect><rect y='441587.487' x='119.111' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='139.506' width='360.015'></rect><rect y='441613.363' x='281.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441613.363' x='204.615' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441613.363' x='128.111' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441613.363' x='357.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441661.74' x='281.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='441661.74' x='204.615' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='441661.74' x='128.111' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='441661.74' x='357.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='441613.363' x='281.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441613.363' x='204.615' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441613.363' x='128.111' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441613.363' x='357.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='76.503'></rect><rect y='441661.74' x='281.118' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='441661.74' x='204.615' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='441661.74' x='128.111' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect><rect y='441661.74' x='357.621' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='38.252' width='76.503'></rect></svg><h3>Figure 3-26.  MOVSLDUP—Move Packed Single-FP Low and Duplicate</h3><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p></span>", "url": "MOVSLDUP.html", "tooltip": "The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 16 bytes of data at memory location m128 are loaded and the single-precision elements in positions 0 and 2 are duplicated. When the register-register form of this operation is used, the same operation is performed but with data coming from the 128-bit source register."},
    "SGDT": {"html": "<p>Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in bytes 3-5, and byte 6 is zero-filled. If the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.</p><p>In IA-32e mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.</p><p>SGDT is useful only by operating-system software. However, it can be used in application programs without causing an exception to be generated. See 'LGDT/LIDT—Load Global/Interrupt Descriptor Table Register” in Chapter 3, <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em>, for information on loading the GDTR and IDTR.</p></span>", "url": "SGDT.html", "tooltip": "Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a memory location."},
    "MOVQ2DQ": {"html": "<p>Moves the quadword from the source operand (second operand) to the low quadword of the destination operand (first operand). The source operand is an MMX technology register and the destination operand is an XMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "MOVQ2DQ.html", "tooltip": "Moves the quadword from the source operand (second operand) to the low quadword of the destination operand (first operand). The source operand is an MMX technology register and the destination operand is an XMM register."},
    "FRNDINT": {"html": "<p>Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the source value is ∞, the value is not changed. If the source value is not an integral value, the floating-point inexact-result exception (#P) is generated.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FRNDINT.html", "tooltip": "Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0)."},
    "FSAVE": {"html": "<p>Stores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state; the FNSAVE instruction does not.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow the operating environment image.</p><p>The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE instruction in the instruction stream have been executed.</p><p>After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT instructions (see 'FINIT/FNINIT—Initialize Floating-Point Unit” in this chapter).</p><p>The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch, an exception handler needs to use the FPU, or an application program needs to pass a 'clean” FPU to a procedure.</p><p>The assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSAVE:FNSAVE.html", "tooltip": "Stores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state; the FNSAVE instruction does not."},
    "MINPD": {"html": "<p>Performs an SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, that SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p><p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p></span>", "url": "MINPD.html", "tooltip": "Performs an SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand."},
    "PCMPEQQ": {"html": "<p>Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand).  If a pair of data elements is equal, the corresponding data element in the desti-nation is set to all 1s; otherwise, it is set to 0s.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PCMPEQQ.html", "tooltip": "Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand).  If a pair of data elements is equal, the corresponding data element in the desti-nation is set to all 1s; otherwise, it is set to 0s."},
    "ADCX": {"html": "<p>Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state. Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).</p><p>This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.</p><p>In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to addi-tional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.</p><p>ADCX executes normally either inside or outside a transaction region.</p><p>Note: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in <em>Intel<sup>®</sup> 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 2A</em>.</p></span>", "url": "ADCX.html", "tooltip": "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands."},
    "CVTTPD2DQ": {"html": "<p>Converts two or four packed double-precision floating-point values in the source operand (second operand) to two or four packed signed doubleword integers in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When a conversion is inexact, a truncated (round toward zero) value is returned.If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operation is an XMM register. The upper bits (255:128) of the corresponding YMM register destination are zeroed.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p><svg width='445.4999775' viewBox='133.320005 163270.439980 296.999985 13.500030' height='20.250045'><rect y='163270.44' x='207.6' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.22'></rect><rect y='163270.44' x='281.82' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.28'></rect><text y='163278.5535' x='241.32' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X2</text><text y='163278.5535' x='315.66' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.12972555'>X1</text></svg><p>SRC</p><p>X3</p><p>X0</p><p>DEST</p><p>0</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><h3>Figure 3-14.  VCVTTPD2DQ (VEX.256 encoded version)</h3></span>", "url": "CVTTPD2DQ.html", "tooltip": "Converts two or four packed double-precision floating-point values in the source operand (second operand) to two or four packed signed doubleword integers in the destination operand (first operand)."},
    "FCOM": {"html": "<p>Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-31.  FCOM/FCOMP/FCOMPP Results</h3><table><tr><th>Condition</th><th>C3</th><th>C2</th><th>C0</th></tr><tr><td>ST(0) &gt; SRC</td><td>0</td><td>0</td><td>0</td></tr><tr><td>ST(0) &lt; SRC</td><td>0</td><td>0</td><td>1</td></tr><tr><td>ST(0) = SRC</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Unordered*</td><td>1</td><td>1</td><td>1</td></tr></table><p><strong>NOTES:</strong></p><p>*</p><p>Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</p><p>This instruction checks the class of the numbers being compared (see 'FXAM—Examine ModR/M” in this chapter). If either operand is a NaN or is in an unsupported format, an invalid-arithmetic-operand exception (#IA) is raised and, if the exception is masked, the condition flags are set to 'unordered.” If the invalid-arithmetic-operand excep-tion is unmasked, the condition code flags are not set.</p><p>The FCOMP instruction pops the register stack following the comparison operation and the FCOMPP instruction pops the register stack twice following the comparison operation. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.</p><p>The FCOM instructions perform the same operation as the FUCOM instructions. The only difference is how they handle QNaN operands. The FCOM instructions raise an invalid-arithmetic-operand exception (#IA) when either or both of the operands is a NaN value or is in an unsupported format. The FUCOM instructions perform the same operation as the FCOM instructions, except that they do not generate an invalid-arithmetic-operand exception for QNaNs.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FCOM:FCOMP:FCOMPP.html", "tooltip": "Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0."},
    "PMADDWD": {"html": "<p>Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-word results are then summed and stored in the destination operand. For example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-word results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words. (Figure 4-7 shows this operation when using 64-bit operands).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in a group are all 8000H. In this case, the result wraps around to 80000000H.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE version: The first source and destination operands are MMX registers. The second source operand is an MMX register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p><svg width='568.799985' viewBox='112.380000 558478.020010 379.199990 121.560000' height='182.34'><text y='558498.887584' x='202.0803' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='16.860144'>SRC</text><text y='558525.707484' x='202.0803' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><text y='558556.067484' x='143.8205' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='22.235472'>TEMP</text><text y='558581.027284' x='203.16' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='21.320964'>DEST</text><rect y='558488.58' x='240.78' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='558488.58' x='313.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='558488.58' x='349.92' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='558514.8' x='277.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='558514.8' x='313.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='558514.8' x='349.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.36'></rect><rect y='558514.8' x='240.72' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='558488.58' x='277.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='36.42'></rect><rect y='558544.62' x='169.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='558544.62' x='241.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='558544.62' x='385.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.0'></rect><rect y='558544.62' x='313.74' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.06'></rect><rect y='558572.7' x='241.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='72.3'></rect><rect y='558572.7' x='313.8' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='18.0' width='73.32'></rect><path style='stroke:black' d='M241.380000,558572.460000 L241.380000,558590.700000 L241.860010,558590.700000 L241.860010,558572.460000 '></path><path style='stroke:black' d='M313.560000,558572.460000 L313.560000,558590.700000 L314.040010,558590.700000 L314.040010,558572.460000 '></path><path style='stroke:black' d='M241.620000,558572.460020 L241.620000,558572.940000 L314.160000,558572.940000 L314.160000,558572.460020 '></path><path style='stroke:black' d='M313.800000,558572.460020 L313.800000,558572.940000 L387.360000,558572.940000 L387.360000,558572.460020 '></path><path style='stroke:black' d='M313.680000,558572.700000 L313.680000,558590.940000 L314.160010,558590.940000 L314.160010,558572.700000 '></path><path style='stroke:black' d='M386.880000,558572.700000 L386.880000,558590.940000 L387.360010,558590.940000 L387.360010,558572.700000 '></path><path style='stroke:black' d='M241.380000,558590.460020 L241.380000,558590.940000 L313.920000,558590.940000 L313.920000,558590.460020 '></path><path style='stroke:black' d='M313.560000,558590.460020 L313.560000,558590.940000 L387.120000,558590.940000 L387.120000,558590.460020 '></path><text y='558499.547484' x='252.3' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X3</text><text y='558499.547484' x='324.900444' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X1</text><text y='558499.547484' x='361.316376' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X0</text><text y='558526.847484' x='291.058032' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y2</text><text y='558526.847484' x='328.080444' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y1</text><text y='558526.847484' x='364.496376' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y0</text><text y='558526.847484' x='255.48' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>Y3</text><text y='558499.547484' x='287.878032' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='9.777096'>X2</text><text y='558555.287784' x='192.9599' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='28.020224'>X3 ∗ Y3</text><text y='558555.287784' x='266.106226' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='28.006618'>X2 ∗ Y2</text><text y='558555.287784' x='408.416776' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='28.016168'>X0 ∗ Y0</text><text y='558555.287784' x='339.418496' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='27.953948'>X1 ∗ Y1</text><text y='558584.447484' x='246.48' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='66.5293'>(X3∗Y3) + (X2∗Y2)</text><text y='558584.147484' x='318.3' style='font-size:7.980000pt' lengthAdjust='spacingAndGlyphs' textLength='66.556432'>(X1∗Y1) + (X0∗Y0)</text></svg><h3>Figure 4-7.  PMADDWD Execution Model Using 64-bit Operands</h3></span>", "url": "PMADDWD.html", "tooltip": "Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-word results are then summed and stored in the destination operand. For example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-word results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words. (Figure 4-7 shows this operation when using 64-bit operands)."},
    "MULSS": {"html": "<p>Multiplies the low single-precision floating-point value from the source operand (second operand) by the low single-precision floating-point value in the destination operand (first operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "MULSS.html", "tooltip": "Multiplies the low single-precision floating-point value from the source operand (second operand) by the low single-precision floating-point value in the destination operand (first operand), and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a scalar single-precision floating-point operation."},
    "PHSUBSW": {"html": "<p>(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>In 64-bit mode, use the REX prefix to access additional registers.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p><p>VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PHSUBSW.html", "tooltip": "(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated."},
    "PAUSE": {"html": "<p>Improves the performance of spin-wait loops. When executing a 'spin-wait loop,” processors will suffer a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>An additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a spin loop. A processor can execute a spin-wait loop extremely quickly, causing the processor to consume a lot of power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spin-wait loop greatly reduces the processor’s power consumption.</p><p>This instruction was introduced in the Pentium 4 processors, but is backward compatible with all IA-32 processors. In earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon processors implement the PAUSE instruction as a delay. The delay is finite and can be zero for some processors. This instruction does not change the architectural state of the processor (that is, it performs essentially a delaying no-op operation).</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "PAUSE.html", "tooltip": "Improves the performance of spin-wait loops. When executing a 'spin-wait loop,” processors will suffer a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops."},
    "CVTPS2PD": {"html": "<p>Converts two or four packed single-precision floating-point values in the source operand (second operand) to two or four packed double-precision floating-point values in the destination operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operation is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operation is a YMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operation is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>SRC</p><p>X3</p><p>X2</p><p>X1</p><p>X0</p><p>DEST</p><h3>Figure 3-13.  CVTPS2PD (VEX.256 encoded version)</h3></span>", "url": "CVTPS2PD.html", "tooltip": "Converts two or four packed single-precision floating-point values in the source operand (second operand) to two or four packed double-precision floating-point values in the destination operand (first operand)."},
    "RDPMC": {"html": "<p>The EAX register is loaded with the low-order 32 bits. The EDX register is loaded with the supported high-order bits of the counter. The number of high-order bits loaded into EDX is implementation specific on processors that do no support architectural performance monitoring. The width of fixed-function and general-purpose performance coun-ters on processors supporting architectural performance monitoring are reported by CPUID 0AH leaf. See below for the treatment of the EDX register for 'fast” reads.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The ECX register selects one of two type of performance counters, specifies the index relative to the base of each counter type, and selects 'fast” read mode if supported. The two counter types are :</p><p>ECX[29:0] specifies the index. The width of general-purpose performance counters are 40-bits for processors that do not support architectural performance monitoring counters.The width of special-purpose performance counters are implementation specific. The width of fixed-function performance counters and general-purpose performance counters on processor supporting architectural performance monitoring are reported by CPUID 0AH leaf.</p><p>Table 4-13 lists valid indices of the general-purpose and special-purpose performance counters according to the derived DisplayFamily_DisplayModel values of CPUID encoding for each processor family (see CPUID instruction in Chapter 3, 'Instruction Set Reference, A-M” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em>).</p><h3>Table 4-13.  Valid General and Special Purpose Performance Counter Index Range for RDPMC</h3><table><tr><th>Processor Family</th><th>DisplayFamily_DisplayModel/Other Signatures</th><th>Valid PMC Index Range</th><th>General-purpose Counters</th></tr><tr><td><p>P6</p><p>Pentium<em><sup>®</sup></em> 4, Intel<em><sup>®</sup></em> Xeon processors</p><p>Pentium 4, Intel Xeon processors</p><p>Pentium M processors</p><p>64-bit Intel Xeon processors with L3</p><p>Intel<em><sup>®</sup></em> Core™ Solo and Intel<em><sup>®</sup></em> Core™ Duo processors, Dual-core Intel<em><sup>®</sup></em> Xeon<em><sup>®</sup></em> processor LV</p></td><td><p>06H_01H, 06H_03H, 06H_05H, 06H_06H, 06H_07H, 06H_08H, 06H_0AH, 06H_0BH</p><p>0FH_00H, 0FH_01H, 0FH_02H</p><p>(0FH_03H, 0FH_04H, 0FH_06H) and (L3 is absent)</p><p>06H_09H, 06H_0DH</p><p>0FH_03H, 0FH_04H) and (L3 is present)</p><p>06H_0EH</p></td><td><p>0, 1</p><p>≥ 0 and ≤ 17</p><p>≥ 0 and ≤ 17</p><p>0, 1</p><p>≥ 0 and ≤ 25</p><p>0, 1</p></td><td><p>0, 1</p><p>≥ 0 and ≤ 17</p><p>≥ 0 and ≤ 17</p><p>0, 1</p><p>≥ 0 and ≤ 17</p><p>0, 1</p></td></tr></table><h3>Table 4-13.  Valid General and Special Purpose Performance Counter Index Range for RDPMC (Contd.)</h3><table><tr><th>Processor Family</th><th>DisplayFamily_DisplayModel/Other Signatures</th><th>Valid PMC Index Range</th><th>General-purpose Counters</th></tr><tr><td><p>Intel<em><sup>®</sup></em> Core™2 Duo processor, Intel Xeon processor 3000, 5100, 5300, 7300 Series - general-purpose PMC</p><p>Intel Xeon processors 7100 series with L3</p><p>Intel<em><sup>®</sup></em> Core™2 Duo processor family, Intel Xeon processor family - general-purpose PMC</p><p>Intel Xeon processors 7400 series</p><p>Intel<em><sup>®</sup></em> Atom™ processor family</p><p>Intel<em><sup>®</sup></em> Core™i7 processor, Intel Xeon processors 5500 series</p></td><td><p>06H_0FH</p><p>(0FH_06H) and (L3 is present)</p><p>06H_17H</p><p>(06H_1DH)</p><p>06H_1CH</p><p>06H_1AH, 06H_1EH, 06H_1FH, 06H_2EH</p></td><td><p>0, 1</p><p>≥ 0 and ≤ 25</p><p>0, 1</p><p>≥ 0 and ≤ 9</p><p>0, 1</p><p>0-3</p></td><td><p>0, 1</p><p>≥ 0 and ≤ 17</p><p>0, 1</p><p>0, 1</p><p>0, 1</p><p>0, 1, 2, 3</p></td></tr></table><p>The Pentium 4 and Intel Xeon processors also support 'fast” (32-bit) and 'slow” (40-bit) reads on the first 18 performance counters. Selected this option using ECX[31]. If bit 31 is set, RDPMC reads only the low 32 bits of the selected performance counter. If bit 31 is clear, all 40 bits are read. A 32-bit result is returned in EAX and EDX is set to 0. A 32-bit read executes faster on Pentium 4 processors and Intel Xeon processors than a full 40-bit read.</p><p>On 64-bit Intel Xeon processors with L3, performance counters with indices 18-25 are 32-bit counters. EDX is cleared after executing RDPMC for these counters. On Intel Xeon processor 7100 series with L3, performance coun-ters with indices 18-25 are also 32-bit counters.</p><p>In Intel Core 2 processor family, Intel Xeon processor 3000, 5100, 5300 and 7400 series, the fixed-function perfor-mance counters are 40-bits wide; they can be accessed by RDMPC with ECX between from 4000_0000H and 4000_0002H.</p><p>On Intel Xeon processor 7400 series, there are eight 32-bit special-purpose counters addressable with indices 2-9, ECX[30]=0.</p><p>When in protected or virtual 8086 mode, the performance-monitoring counters enabled (PCE) flag in register CR4 restricts the use of the RDPMC instruction as follows. When the PCE flag is set, the RDPMC instruction can be executed at any privilege level; when the flag is clear, the instruction can only be executed at privilege level 0. (When in real-address mode, the RDPMC instruction is always enabled.)</p><p>The performance-monitoring counters can also be read with the RDMSR instruction, when executing at privilege level 0.</p><p>The performance-monitoring counters are event counters that can be programmed to count events such as the number of instructions decoded, number of interrupts received, or number of cache loads. Chapter 19, 'Perfor-mance Monitoring Events,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B</em>, lists the events that can be counted for various processors in the Intel 64 and IA-32 architecture families.</p><p>The RDPMC instruction is not a serializing instruction; that is, it does not imply that all the events caused by the preceding instructions have been completed or that events caused by subsequent instructions have not begun. If an exact event count is desired, software must insert a serializing instruction (such as the CPUID instruction) before and/or after the RDPMC instruction.</p><p>In the Pentium 4 and Intel Xeon processors, performing back-to-back fast reads are not guaranteed to be mono-tonic. To guarantee monotonicity on back-to-back reads, a serializing instruction must be placed between the two RDPMC instructions.</p><p>The RDPMC instruction can execute in 16-bit addressing mode or virtual-8086 mode; however, the full contents of the ECX register are used to select the counter, and the event count is stored in the full EAX and EDX registers. The RDPMC instruction was introduced into the IA-32 Architecture in the Pentium Pro processor and the Pentium processor with MMX technology. The earlier Pentium processors have performance-monitoring counters, but they must be read with the RDMSR instruction.</p></span>", "url": "RDPMC.html", "tooltip": "The EAX register is loaded with the low-order 32 bits. The EDX register is loaded with the supported high-order bits of the counter. The number of high-order bits loaded into EDX is implementation specific on processors that do no support architectural performance monitoring. The width of fixed-function and general-purpose performance coun-ters on processors supporting architectural performance monitoring are reported by CPUID 0AH leaf. See below for the treatment of the EDX register for 'fast” reads."},
    "DEC": {"html": "<p>Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p><p>In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.</p><p>See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "DEC.html", "tooltip": "Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)"},
    "MWAIT": {"html": "<p>MWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state. There are two principal targeted usages: address-range monitor and advanced power management. Both usages of MWAIT require the use of the MONITOR instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MWAIT may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MWAIT clears the CPUID feature flag and causes execution to generate an invalid-opcode excep-tion.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p><p>ECX specifies optional extensions for the MWAIT instruction. EAX may contain hints such as the preferred opti-mized state the processor should enter. The first processors to implement MWAIT supported only the zero value for EAX and ECX. Later processors allowed setting ECX[0] to enable masked interrupts as break events for MWAIT (see below). Software can use the CPUID instruction to determine the extensions and hints supported by the processor.</p></span>", "url": "MWAIT.html", "tooltip": "MWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state. There are two principal targeted usages: address-range monitor and advanced power management. Both usages of MWAIT require the use of the MONITOR instruction."},
    "PMULDQ": {"html": "<p>Multiplies the first source operand by the second source operand and stores the result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>For PMULDQ and VPMULDQ (VEX.128 encoded version), the second source operand is two packed signed double-word integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. The first source operand is two packed signed doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed signed quadword integers stored in an XMM register. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation.</p><p>For VPMULDQ (VEX.256 encoded version), the second source operand is four packed signed doubleword integers stored in the first (low), third, fifth and seventh doublewords of an YMM register or a 256-bit memory location. The first source operand is four packed signed doubleword integers stored in the first, third, fifth and seventh double-words of an XMM register. The destination contains four packed signed quadword integers stored in an YMM register. For 256-bit memory operands, 256 bits are fetched from memory, but only the first, third, fifth and seventh doublewords are used in the computation.</p><p>When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).</p><p>128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-tion register remain unchanged.</p><p>VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.</p><p>VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.</p></span>", "url": "PMULDQ.html", "tooltip": "Multiplies the first source operand by the second source operand and stores the result in the destination operand."},
    "UD2": {"html": "<p>Generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an invalid opcode exception. The opcode for this instruction is reserved for this purpose.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Other than raising the invalid opcode exception, this instruction has no effect on processor state or memory.</p><p>Even though it is the execution of the UD2 instruction that causes the invalid opcode exception, the instruction pointer saved by delivery of the exception references the UD2 instruction (and not the following instruction).</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "UD2.html", "tooltip": "Generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an invalid opcode exception. The opcode for this instruction is reserved for this purpose."},
    "VBROADCAST": {"html": "<p>Load floating point values from the source operand (second operand) and broadcast to all elements of the destina-tion operand (first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VBROADCASTSD and VBROADCASTF128 are only supported as 256-bit wide versions. VBROADCASTSS is supported in both 128-bit and 256-bit wide versions.</p><p>Memory and register source operand syntax support of 256-bit instructions depend on the processor’s enumeration of the following conditions with respect to CPUID.1:ECX.AVX[bit 28] and CPUID.(EAX=07H, ECX=0H):EBX.AVX2[bit 5]:</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. An attempt to execute VBROADCASTSD or VBROADCASTF128 encoded with VEX.L= 0 will cause an #UD exception. Attempts to execute any VBROADCAST* instruction with VEX.W = 1 will cause #UD.</p><svg width='568.799985' viewBox='112.380000 805536.000010 379.199990 109.380000' height='164.07'><text y='805562.7735' x='383.28' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='14.6085'>m32</text><text y='805632.0135' x='141.96' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='19.9395'>DEST</text><rect y='805623.9' x='347.28' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.08'></rect><rect y='805623.9' x='198.78' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.08'></rect><rect y='805552.98' x='421.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805623.9' x='421.5' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805623.9' x='384.36' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805623.9' x='273.0' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805623.9' x='310.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805623.9' x='235.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805623.9' x='161.64' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805552.98001' x='421.500005' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><path style='stroke:black' d='M438.600000,805567.440000 L438.180000,805565.520000 L195.240000,805619.220000 L195.660000,805621.140000 '></path><path style='stroke:black' d='M438.600000,805567.440000 L438.120000,805565.520000 L235.500000,805618.560000 L235.980000,805620.480000 '></path><path style='stroke:black' d='M438.660000,805567.440000 L438.060000,805565.520000 L268.980000,805617.840000 L269.580000,805619.760000 '></path><path style='stroke:black' d='M438.720000,805567.440000 L438.000000,805565.580000 L309.000000,805616.640000 L309.720000,805618.500000 '></path><path style='stroke:black' d='M438.840000,805567.380000 L437.940000,805565.640000 L342.000000,805615.140000 L342.900000,805616.880000 '></path><path style='stroke:black' d='M438.960000,805567.260000 L437.760000,805565.700000 L377.220000,805612.500000 L378.420000,805614.060000 '></path><path style='stroke:black' d='M439.200000,805567.020000 L437.520000,805565.940000 L409.800000,805608.840000 L411.480000,805609.920000 '></path><path style='stroke:black' d='M439.980000,805566.480000 L438.000000,805566.480000 L437.580000,805606.560000 L439.560000,805606.560000 '></path><path style='stroke:black' d='M438.540000,805607.580000 L438.780000,805607.580000 L438.960000,805607.520000 L439.080000,805607.400000 L439.260000,805607.280000 L439.380000,805607.160000 L439.500000,805606.980000 L439.560000,805606.800000 L439.560000,805606.380000 L439.500000,805606.200000 L439.380000,805606.020000 L439.140000,805605.780000 L438.960000,805605.660000 L438.780000,805605.600000 L438.360000,805605.600000 L438.000000,805605.720000 L437.880000,805605.840000 L437.640000,805606.200000 L437.580000,805606.380000 L437.580000,805606.800000 L437.640000,805606.980000 L437.700000,805607.160000 L437.820000,805607.280000 L438.180000,805607.520000 L438.360000,805607.580000 L438.540000,805607.580000 '></path><path style='stroke:black' d='M438.540000,805606.620000 L442.860000,805606.620000 L443.520000,805606.680000 L443.340000,805607.280000 L438.900000,805622.220000 L438.420000,805623.900000 L437.940000,805622.220000 L433.800000,805607.220000 L433.620000,805606.560000 L434.280000,805606.560000 L434.760000,805606.920000 L438.900000,805621.920000 L437.940000,805622.220000 L437.940000,805621.920000 L442.380000,805606.980000 L443.340000,805607.280000 L442.860000,805607.640000 L438.540000,805607.640000 '></path><path style='stroke:black' d='M434.280000,805606.560000 L438.540000,805606.620000 L438.540000,805607.640000 L434.280000,805607.580000 '></path><path style='stroke:black' d='M410.640000,805609.380000 L414.240000,805611.660000 L414.780000,805612.080000 L414.300000,805612.500000 L402.540000,805622.760000 L401.220000,805623.900000 L401.760000,805622.220000 L406.320000,805607.340000 L406.500000,805606.680000 L407.040000,805607.040000 L407.280000,805607.640000 L402.720000,805622.520000 L401.760000,805622.220000 L401.880000,805621.980000 L413.640000,805611.720000 L414.300000,805612.500000 L413.700000,805612.560000 L410.100000,805610.280000 '></path><path style='stroke:black' d='M407.040000,805607.040000 L410.640000,805609.380000 L410.100000,805610.280000 L406.500000,805607.940000 '></path><path style='stroke:black' d='M438.540000,805607.100000 L442.860000,805607.100000 L438.420000,805622.040000 L434.280000,805607.040000 '></path><path style='stroke:black' d='M410.400000,805609.800000 L414.000000,805612.080000 L402.240000,805622.340000 L406.800000,805607.460000 '></path><path style='stroke:black' d='M410.100000,805610.220000 L410.460000,805610.340000 L410.880000,805610.340000 L411.060000,805610.280000 L411.240000,805610.160000 L411.480000,805609.920000 L411.600000,805609.740000 L411.660000,805609.500000 L411.660000,805609.140000 L411.600000,805608.960000 L411.480000,805608.780000 L411.360000,805608.660000 L411.000000,805608.420000 L410.118000,805608.045000 L409.276000,805609.190000 L409.860000,805609.920000 L409.980000,805610.040000 L410.100000,805610.220000 '></path><path style='stroke:black' d='M377.820000,805613.280000 L380.400000,805616.700000 L380.760000,805617.240000 L380.220000,805617.480000 L365.760000,805623.240000 L364.080000,805623.900000 L365.160000,805622.460000 L374.400000,805609.980000 L374.820000,805609.380000 L375.180000,805609.920000 L375.180000,805610.520000 L365.940000,805623.060000 L365.160000,805622.460000 L365.400000,805622.280000 L379.860000,805616.520000 L380.220000,805617.480000 L379.620000,805617.300000 L377.040000,805613.940000 '></path><path style='stroke:black' d='M375.180000,805609.920000 L377.820000,805613.280000 L377.040000,805613.940000 L374.400000,805610.580000 '></path><path style='stroke:black' d='M377.460000,805613.580000 L380.040000,805617.000000 L365.580000,805622.760000 L374.820000,805610.220000 '></path><path style='stroke:black' d='M342.360000,805615.920000 L344.340000,805619.760000 L344.640000,805620.360000 L343.980000,805620.480000 L328.680000,805623.540000 L326.940000,805623.900000 L328.260000,805622.700000 L339.600000,805612.020000 L340.080000,805611.600000 L340.380000,805612.140000 L340.260000,805612.740000 L328.920000,805623.420000 L328.260000,805622.700000 L328.500000,805622.580000 L343.800000,805619.520000 L343.980000,805620.480000 L343.440000,805620.240000 L341.460000,805616.400000 '></path><path style='stroke:black' d='M340.380000,805612.140000 L342.360000,805615.920000 L341.460000,805616.400000 L339.480000,805612.620000 '></path><path style='stroke:black' d='M377.040000,805613.940000 L377.160000,805614.060000 L377.340000,805614.180000 L378.122000,805614.574000 L379.211000,805613.842000 L378.720000,805612.860000 L378.600000,805612.680000 L378.480000,805612.560000 L378.300000,805612.440000 L377.940000,805612.320000 L377.580000,805612.320000 L377.400000,805612.380000 L377.220000,805612.500000 L376.926000,805612.840000 L376.815000,805612.896000 L376.860000,805613.340000 L376.860000,805613.580000 L376.920000,805613.760000 L377.040000,805613.940000 '></path><path style='stroke:black' d='M341.940000,805616.160000 L343.920000,805620.000000 L328.620000,805623.060000 L339.960000,805612.380000 '></path><path style='stroke:black' d='M309.300000,805617.540000 L310.860000,805621.500000 L311.100000,805622.100000 L310.440000,805622.220000 L294.960000,805623.780000 L293.220000,805623.900000 L294.600000,805622.880000 L306.960000,805613.340000 L307.500000,805612.920000 L307.740000,805613.520000 L307.620000,805614.120000 L295.260000,805623.660000 L294.600000,805622.880000 L294.900000,805622.760000 L310.380000,805621.200000 L310.440000,805622.220000 L309.960000,805621.860000 L308.400000,805617.900000 '></path><path style='stroke:black' d='M307.740000,805613.520000 L309.300000,805617.540000 L308.400000,805617.900000 L306.840000,805613.880000 '></path><path style='stroke:black' d='M308.880000,805617.720000 L310.440000,805621.680000 L294.960000,805623.240000 L307.320000,805613.700000 '></path><path style='stroke:black' d='M269.280000,805618.800000 L270.540000,805622.880000 L270.720000,805623.480000 L270.000000,805623.540000 L254.520000,805623.900000 L252.720000,805623.900000 L254.220000,805622.940000 L267.240000,805614.420000 L267.780000,805614.060000 L268.020000,805614.720000 L267.780000,805615.260000 L254.760000,805623.780000 L254.220000,805622.940000 L254.520000,805622.880000 L270.060000,805622.520000 L270.000000,805623.540000 L269.520000,805623.180000 L268.260000,805619.100000 '></path><path style='stroke:black' d='M235.740000,805619.520000 L236.820000,805623.660000 L237.000000,805624.320000 L236.280000,805624.260000 L220.680000,805623.960000 L218.940000,805623.900000 L220.440000,805623.000000 L233.880000,805615.080000 L234.480000,805614.720000 L234.660000,805615.380000 L234.420000,805615.920000 L220.980000,805623.840000 L220.440000,805623.000000 L220.740000,805622.940000 L236.340000,805623.300000 L236.280000,805624.260000 L235.800000,805623.900000 L234.720000,805619.760000 '></path><path style='stroke:black' d='M268.020000,805614.720000 L269.280000,805618.800000 L268.260000,805619.100000 L267.000000,805615.020000 '></path><path style='stroke:black' d='M268.800000,805618.920000 L270.060000,805623.000000 L254.520000,805623.360000 L267.540000,805614.840000 '></path><path style='stroke:black' d='M341.520000,805616.400000 L341.640000,805616.580000 L341.760000,805616.700000 L342.574000,805617.346000 L343.528000,805616.647000 L343.380000,805615.680000 L343.260000,805615.500000 L343.200000,805615.320000 L343.020000,805615.200000 L342.900000,805615.080000 L342.540000,805614.960000 L342.300000,805614.960000 L341.940000,805615.080000 L341.555000,805615.311000 L341.525000,805615.465000 L341.400000,805615.860000 L341.400000,805616.040000 L341.520000,805616.400000 '></path><path style='stroke:black' d='M195.420000,805620.120000 L196.320000,805624.320000 L196.380000,805624.980000 L195.780000,805624.920000 L180.240000,805623.960000 L178.500000,805623.900000 L180.000000,805623.060000 L193.680000,805615.620000 L194.280000,805615.320000 L194.460000,805615.920000 L194.220000,805616.460000 L180.540000,805623.900000 L180.000000,805623.060000 L180.300000,805623.000000 L195.840000,805623.960000 L195.780000,805624.920000 L195.300000,805624.560000 L194.400000,805620.360000 '></path><path style='stroke:black' d='M234.660000,805615.380000 L235.740000,805619.520000 L234.720000,805619.760000 L233.640000,805615.620000 '></path><path style='stroke:black' d='M235.260000,805619.640000 L236.340000,805623.780000 L220.740000,805623.420000 L234.180000,805615.500000 '></path><path style='stroke:black' d='M194.460000,805615.920000 L195.420000,805620.120000 L194.400000,805620.360000 L193.440000,805616.160000 '></path><path style='stroke:black' d='M194.940000,805620.240000 L195.840000,805624.440000 L180.300000,805623.480000 L193.980000,805616.040000 '></path><path style='stroke:black' d='M308.400000,805617.900000 L308.520000,805618.080000 L308.640000,805618.200000 L309.280000,805618.928000 L310.559000,805618.317000 L310.320000,805617.360000 L310.200000,805617.000000 L310.080000,805616.820000 L309.720000,805616.580000 L309.540000,805616.520000 L309.180000,805616.520000 L309.000000,805616.580000 L308.493000,805616.944000 L308.576000,805616.741000 L308.400000,805617.300000 L308.340000,805617.480000 L308.340000,805617.720000 L308.400000,805617.900000 '></path><path style='stroke:black' d='M268.320000,805619.040000 L268.500000,805619.400000 L269.147000,805620.128000 L270.328000,805619.676000 L270.300000,805618.680000 L270.240000,805618.500000 L270.180000,805618.260000 L269.562000,805617.416000 L268.290000,805617.795000 L268.320000,805618.680000 L268.320000,805619.040000 '></path><path style='stroke:black' d='M234.780000,805619.760000 L234.840000,805619.940000 L234.960000,805620.120000 L235.592000,805620.823000 L236.796000,805620.466000 L236.760000,805619.460000 L236.700000,805619.280000 L236.640000,805619.040000 L236.520000,805618.920000 L236.400000,805618.740000 L236.280000,805618.620000 L235.920000,805618.500000 L235.680000,805618.500000 L235.320000,805618.620000 L235.140000,805618.740000 L234.900000,805618.980000 L234.780000,805619.160000 L234.780000,805619.340000 L234.720000,805619.580000 L234.780000,805619.760000 '></path><path style='stroke:black' d='M194.400000,805620.360000 L194.460000,805620.540000 L194.580000,805620.720000 L195.087000,805621.532000 L196.477000,805621.110000 L196.380000,805620.120000 L196.380000,805619.940000 L196.320000,805619.760000 L195.902000,805618.841000 L194.744000,805618.973000 L194.400000,805619.940000 L194.400000,805620.360000 '></path><path style='stroke:black' d='M161.400000,805623.660000 L161.400000,805637.400000 L161.880000,805637.400000 L161.880000,805623.660000 '></path><path style='stroke:black' d='M198.540000,805623.660000 L198.540000,805637.400000 L199.020010,805637.400000 L199.020010,805623.660000 '></path><path style='stroke:black' d='M235.620000,805623.660000 L235.620000,805637.400000 L236.100000,805637.400000 L236.100000,805623.660000 '></path><path style='stroke:black' d='M272.760000,805623.660000 L272.760000,805637.400000 L273.239980,805637.400000 L273.239980,805623.660000 '></path><path style='stroke:black' d='M309.900000,805623.660000 L309.900000,805637.400000 L310.380010,805637.400000 L310.380010,805623.660000 '></path><path style='stroke:black' d='M347.040000,805623.660000 L347.040000,805637.400000 L347.519980,805637.400000 L347.519980,805623.660000 '></path><path style='stroke:black' d='M384.120000,805623.660000 L384.120000,805637.400000 L384.600010,805637.400000 L384.600010,805623.660000 '></path><path style='stroke:black' d='M421.260000,805623.660000 L421.260000,805637.400000 L421.740010,805637.400000 L421.740010,805623.660000 '></path><path style='stroke:black' d='M161.640000,805623.660020 L161.640000,805624.140000 L199.020000,805624.140000 L199.020000,805623.660020 '></path><path style='stroke:black' d='M198.780000,805623.660020 L198.780000,805624.140000 L236.100000,805624.140000 L236.100000,805623.660020 '></path><path style='stroke:black' d='M235.860000,805623.660020 L235.860000,805624.140000 L273.240000,805624.140000 L273.240000,805623.660020 '></path><path style='stroke:black' d='M273.000000,805623.660020 L273.000000,805624.140000 L310.380000,805624.140000 L310.380000,805623.660020 '></path><path style='stroke:black' d='M310.140000,805623.660020 L310.140000,805624.140000 L347.520000,805624.140000 L347.520000,805623.660020 '></path><path style='stroke:black' d='M347.280000,805623.660020 L347.280000,805624.140000 L384.600000,805624.140000 L384.600000,805623.660020 '></path><path style='stroke:black' d='M384.360000,805623.660020 L384.360000,805624.140000 L421.740000,805624.140000 L421.740000,805623.660020 '></path><path style='stroke:black' d='M421.500000,805623.660020 L421.500000,805624.140000 L458.880000,805624.140000 L458.880000,805623.660020 '></path><path style='stroke:black' d='M198.540000,805623.900000 L198.540000,805637.640000 L199.020010,805637.640000 L199.020010,805623.900000 '></path><path style='stroke:black' d='M235.620000,805623.900000 L235.620000,805637.640000 L236.100000,805637.640000 L236.100000,805623.900000 '></path><path style='stroke:black' d='M272.760000,805623.900000 L272.760000,805637.640000 L273.239980,805637.640000 L273.239980,805623.900000 '></path><path style='stroke:black' d='M309.900000,805623.900000 L309.900000,805637.640000 L310.380010,805637.640000 L310.380010,805623.900000 '></path><path style='stroke:black' d='M347.040000,805623.900000 L347.040000,805637.640000 L347.519980,805637.640000 L347.519980,805623.900000 '></path><path style='stroke:black' d='M384.120000,805623.900000 L384.120000,805637.640000 L384.600010,805637.640000 L384.600010,805623.900000 '></path><path style='stroke:black' d='M421.260000,805623.900000 L421.260000,805637.640000 L421.740010,805637.640000 L421.740010,805623.900000 '></path><path style='stroke:black' d='M458.400000,805623.900000 L458.400000,805637.640000 L458.880010,805637.640000 L458.880010,805623.900000 '></path><path style='stroke:black' d='M161.400000,805637.159960 L161.400000,805637.640000 L198.780000,805637.640000 L198.780000,805637.159960 '></path><path style='stroke:black' d='M198.540000,805637.159960 L198.540000,805637.640000 L235.860000,805637.640000 L235.860000,805637.159960 '></path><path style='stroke:black' d='M235.620000,805637.159960 L235.620000,805637.640000 L273.000000,805637.640000 L273.000000,805637.159960 '></path><path style='stroke:black' d='M272.760000,805637.159960 L272.760000,805637.640000 L310.140000,805637.640000 L310.140000,805637.159960 '></path><path style='stroke:black' d='M309.900000,805637.159960 L309.900000,805637.640000 L347.280000,805637.640000 L347.280000,805637.159960 '></path><path style='stroke:black' d='M347.040000,805637.159960 L347.040000,805637.640000 L384.360000,805637.640000 L384.360000,805637.159960 '></path><path style='stroke:black' d='M384.120000,805637.159960 L384.120000,805637.640000 L421.500000,805637.640000 L421.500000,805637.159960 '></path><path style='stroke:black' d='M421.260000,805637.159960 L421.260000,805637.640000 L458.640000,805637.640000 L458.640000,805637.159960 '></path><text y='805633.6335' x='360.78' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.07002675'>X0</text><text y='805633.6335' x='212.28' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.07002675'>X0</text><text y='805561.1535' x='432.6' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text><text y='805633.6335' x='435.0' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.12972555'>X0</text><text y='805633.6335' x='397.92' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.1305547'>X0</text><text y='805633.6335' x='286.5' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.1305547'>X0</text><text y='805633.6335' x='323.7' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.07002675'>X0</text><text y='805633.6335' x='249.42' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.1305547'>X0</text><text y='805633.6335' x='175.2' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.07002675'>X0</text></svg><h3>Figure 4-27.  VBROADCASTSS Operation (VEX.256 encoded version)</h3><svg width='568.799985' viewBox='112.380000 805708.380010 379.199990 143.579985' height='215.3699775'><text y='805752.2535' x='368.82' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='14.5485'>m32</text><text y='805821.4935' x='127.44' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='20.004'>DEST</text><rect y='805742.46' x='407.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.08'></rect><rect y='805813.38' x='407.04' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.08'></rect><rect y='805813.38' x='258.54' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.08'></rect><rect y='805742.46001' x='407.03999' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.080015'></rect><rect y='805813.38' x='332.76' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805813.38' x='369.9' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805813.38' x='295.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805813.38' x='184.26' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805813.38' x='147.12' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><rect y='805813.38' x='221.4' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='37.14'></rect><path style='stroke:black' d='M424.380000,805756.860000 L423.480000,805755.120000 L327.480000,805804.620000 L328.380000,805806.360000 '></path><path style='stroke:black' d='M424.500000,805756.740000 L423.300000,805755.180000 L362.700000,805801.980000 L363.900000,805803.540000 '></path><path style='stroke:black' d='M424.740000,805756.500000 L423.060000,805755.420000 L395.340000,805798.260000 L397.020000,805799.340000 '></path><path style='stroke:black' d='M425.460000,805755.960000 L423.480000,805755.960000 L423.120000,805796.040000 L425.100000,805796.040000 '></path><path style='stroke:black' d='M424.020000,805797.060000 L424.260000,805797.060000 L424.440000,805797.000000 L425.365000,805796.519000 L425.200000,805795.250000 L424.260000,805795.080000 L423.840000,805795.080000 L422.857000,805795.310000 L422.796000,805796.537000 L423.660000,805797.000000 L423.840000,805797.060000 L424.020000,805797.060000 '></path><path style='stroke:black' d='M424.080000,805796.100000 L428.340000,805796.100000 L429.000000,805796.160000 L428.820000,805796.760000 L424.380000,805811.700000 L423.900000,805813.380000 L423.420000,805811.700000 L419.280000,805796.700000 L419.100000,805796.040000 L419.760000,805796.040000 L420.240000,805796.400000 L424.380000,805811.400000 L423.420000,805811.700000 L423.420000,805811.400000 L427.860000,805796.460000 L428.820000,805796.760000 L428.340000,805797.120000 L424.080000,805797.120000 '></path><path style='stroke:black' d='M419.760000,805796.040000 L424.080000,805796.100000 L424.080000,805797.120000 L419.760000,805797.060000 '></path><path style='stroke:black' d='M396.120000,805798.800000 L399.720000,805801.140000 L400.260000,805801.560000 L399.780000,805801.980000 L388.020000,805812.240000 L386.700000,805813.380000 L387.240000,805811.700000 L391.800000,805796.820000 L391.980000,805796.160000 L392.520000,805796.520000 L392.760000,805797.120000 L388.200000,805812.000000 L387.240000,805811.700000 L387.360000,805811.460000 L399.120000,805801.200000 L399.780000,805801.980000 L399.180000,805802.040000 L395.580000,805799.700000 '></path><path style='stroke:black' d='M392.520000,805796.520000 L396.120000,805798.800000 L395.580000,805799.700000 L391.980000,805797.420000 '></path><path style='stroke:black' d='M424.080000,805796.580000 L428.340000,805796.580000 L423.900000,805811.520000 L419.760000,805796.520000 '></path><path style='stroke:black' d='M395.880000,805799.220000 L399.480000,805801.560000 L387.720000,805811.820000 L392.280000,805796.940000 '></path><path style='stroke:black' d='M395.640000,805799.640000 L395.820000,805799.760000 L396.000000,805799.820000 L396.360000,805799.820000 L396.540000,805799.760000 L396.900000,805799.520000 L397.020000,805799.400000 L397.080000,805799.220000 L397.196000,805798.904000 L397.154000,805798.562000 L397.020000,805798.260000 L396.840000,805798.140000 L396.720000,805797.960000 L396.540000,805797.900000 L395.612000,805797.517000 L394.746000,805798.642000 L395.340000,805799.400000 L395.460000,805799.520000 L395.640000,805799.640000 '></path><path style='stroke:black' d='M363.300000,805802.760000 L365.940000,805806.180000 L366.360000,805806.720000 L365.760000,805806.960000 L351.240000,805812.720000 L349.560000,805813.380000 L350.640000,805811.940000 L359.880000,805799.460000 L360.300000,805798.860000 L360.660000,805799.400000 L360.660000,805800.000000 L351.420000,805812.540000 L350.640000,805811.940000 L350.880000,805811.760000 L365.400000,805806.000000 L365.760000,805806.960000 L365.160000,805806.780000 L362.520000,805803.420000 '></path><path style='stroke:black' d='M360.660000,805799.400000 L363.300000,805802.760000 L362.520000,805803.420000 L359.880000,805800.060000 '></path><path style='stroke:black' d='M362.940000,805803.060000 L365.580000,805806.480000 L351.060000,805812.240000 L360.300000,805799.700000 '></path><path style='stroke:black' d='M327.840000,805805.400000 L329.820000,805809.240000 L330.120000,805809.840000 L329.460000,805809.960000 L314.160000,805813.020000 L312.420000,805813.380000 L313.740000,805812.180000 L325.140000,805801.500000 L325.620000,805801.080000 L325.920000,805801.620000 L325.800000,805802.220000 L314.400000,805812.900000 L313.740000,805812.180000 L313.980000,805812.060000 L329.280000,805809.000000 L329.460000,805809.960000 L328.920000,805809.720000 L326.940000,805805.880000 '></path><path style='stroke:black' d='M325.920000,805801.620000 L327.840000,805805.400000 L326.940000,805805.880000 L325.020000,805802.100000 '></path><path style='stroke:black' d='M362.520000,805803.360000 L362.820000,805803.660000 L363.180000,805803.780000 L363.420000,805803.780000 L363.780000,805803.660000 L363.960000,805803.540000 L364.080000,805803.420000 L364.345000,805803.054000 L364.325000,805802.950000 L364.320000,805802.520000 L364.200000,805802.340000 L364.140000,805802.160000 L363.960000,805802.040000 L363.840000,805801.920000 L363.660000,805801.800000 L363.060000,805801.800000 L362.880000,805801.860000 L362.700000,805801.980000 L362.580000,805802.100000 L362.460000,805802.280000 L362.340000,805802.640000 L362.340000,805803.060000 L362.400000,805803.240000 L362.520000,805803.360000 '></path><path style='stroke:black' d='M327.420000,805805.640000 L329.400000,805809.480000 L314.100000,805812.540000 L325.500000,805801.860000 '></path><path style='stroke:black' d='M327.000000,805805.880000 L327.120000,805806.060000 L327.240000,805806.180000 L327.420000,805806.300000 L327.780000,805806.420000 L328.140000,805806.420000 L328.380000,805806.300000 L328.500000,805806.180000 L329.099000,805805.820000 L328.718000,805805.750000 L328.920000,805805.340000 L328.800000,805804.980000 L328.680000,805804.800000 L327.949000,805804.036000 L326.861000,805804.547000 L326.880000,805805.520000 L326.940000,805805.700000 L327.000000,805805.880000 '></path><path style='stroke:black' d='M147.120000,805813.139990 L147.120000,805813.620000 L184.500000,805813.620000 L184.500000,805813.139990 '></path><path style='stroke:black' d='M184.260000,805813.139990 L184.260000,805813.620000 L221.640000,805813.620000 L221.640000,805813.139990 '></path><path style='stroke:black' d='M221.400000,805813.139990 L221.400000,805813.620000 L258.780000,805813.620000 L258.780000,805813.139990 '></path><path style='stroke:black' d='M258.540000,805813.139990 L258.540000,805813.620000 L295.860000,805813.620000 L295.860000,805813.139990 '></path><path style='stroke:black' d='M295.620000,805813.139990 L295.620000,805813.620000 L333.000000,805813.620000 L333.000000,805813.139990 '></path><path style='stroke:black' d='M332.760000,805813.139990 L332.760000,805813.620000 L370.140000,805813.620000 L370.140000,805813.139990 '></path><path style='stroke:black' d='M369.900000,805813.139990 L369.900000,805813.620000 L407.280000,805813.620000 L407.280000,805813.139990 '></path><path style='stroke:black' d='M407.040000,805813.139990 L407.040000,805813.620000 L444.360000,805813.620000 L444.360000,805813.139990 '></path><path style='stroke:black' d='M146.880000,805813.140000 L146.880000,805826.880000 L147.360010,805826.880000 L147.360010,805813.140000 '></path><path style='stroke:black' d='M184.020000,805813.140000 L184.020000,805826.880000 L184.499980,805826.880000 L184.499980,805813.140000 '></path><path style='stroke:black' d='M221.160000,805813.140000 L221.160000,805826.880000 L221.640010,805826.880000 L221.640010,805813.140000 '></path><path style='stroke:black' d='M258.300000,805813.140000 L258.300000,805826.880000 L258.780010,805826.880000 L258.780010,805813.140000 '></path><path style='stroke:black' d='M295.380000,805813.140000 L295.380000,805826.880000 L295.860010,805826.880000 L295.860010,805813.140000 '></path><path style='stroke:black' d='M332.520000,805813.140000 L332.520000,805826.880000 L333.000010,805826.880000 L333.000010,805813.140000 '></path><path style='stroke:black' d='M369.660000,805813.140000 L369.660000,805826.880000 L370.140010,805826.880000 L370.140010,805813.140000 '></path><path style='stroke:black' d='M406.800000,805813.140000 L406.800000,805826.880000 L407.279980,805826.880000 L407.279980,805813.140000 '></path><path style='stroke:black' d='M184.020000,805813.380000 L184.020000,805827.120000 L184.499980,805827.120000 L184.499980,805813.380000 '></path><path style='stroke:black' d='M221.160000,805813.380000 L221.160000,805827.120000 L221.640010,805827.120000 L221.640010,805813.380000 '></path><path style='stroke:black' d='M258.300000,805813.380000 L258.300000,805827.120000 L258.780010,805827.120000 L258.780010,805813.380000 '></path><path style='stroke:black' d='M295.380000,805813.380000 L295.380000,805827.120000 L295.860010,805827.120000 L295.860010,805813.380000 '></path><path style='stroke:black' d='M332.520000,805813.380000 L332.520000,805827.120000 L333.000010,805827.120000 L333.000010,805813.380000 '></path><path style='stroke:black' d='M369.660000,805813.380000 L369.660000,805827.120000 L370.140010,805827.120000 L370.140010,805813.380000 '></path><path style='stroke:black' d='M406.800000,805813.380000 L406.800000,805827.120000 L407.279980,805827.120000 L407.279980,805813.380000 '></path><path style='stroke:black' d='M443.880000,805813.380000 L443.880000,805827.120000 L444.360010,805827.120000 L444.360010,805813.380000 '></path><path style='stroke:black' d='M146.880000,805826.639990 L146.880000,805827.120000 L184.260000,805827.120000 L184.260000,805826.639990 '></path><path style='stroke:black' d='M184.020000,805826.639990 L184.020000,805827.120000 L221.400000,805827.120000 L221.400000,805826.639990 '></path><path style='stroke:black' d='M221.160000,805826.639990 L221.160000,805827.120000 L258.540000,805827.120000 L258.540000,805826.639990 '></path><path style='stroke:black' d='M258.300000,805826.639990 L258.300000,805827.120000 L295.620000,805827.120000 L295.620000,805826.639990 '></path><path style='stroke:black' d='M295.380000,805826.639990 L295.380000,805827.120000 L332.760000,805827.120000 L332.760000,805826.639990 '></path><path style='stroke:black' d='M332.520000,805826.639990 L332.520000,805827.120000 L369.900000,805827.120000 L369.900000,805826.639990 '></path><path style='stroke:black' d='M369.660000,805826.639990 L369.660000,805827.120000 L407.040000,805827.120000 L407.040000,805826.639990 '></path><path style='stroke:black' d='M406.800000,805826.639990 L406.800000,805827.120000 L444.120000,805827.120000 L444.120000,805826.639990 '></path><text y='805750.6335' x='418.08' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text><text y='805823.1135' x='420.54' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.1305547'>X0</text><text y='805823.1135' x='272.04' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='4.610074'>0</text><text y='805823.1135' x='346.26' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.07002675'>X0</text><text y='805823.1135' x='383.46' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.07002675'>X0</text><text y='805823.1135' x='309.18' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='10.1305547'>X0</text><text y='805823.1135' x='197.76' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='4.610074'>0</text><text y='805823.1135' x='160.68' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='4.610074'>0</text><text y='805823.1135' x='234.96' style='font-size:8.291500pt' lengthAdjust='spacingAndGlyphs' textLength='4.610074'>0</text></svg><h3>Figure 4-28.  VBROADCASTSS Operation (128-bit version)</h3><svg width='568.799985' viewBox='112.380000 805907.940010 379.199990 144.599985' height='216.8999775'><text y='805950.3134' x='328.5' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='14.6085'>m64</text><text y='806021.1734' x='123.18' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='20.004'>DEST</text><rect y='805942.14' x='365.64' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.22'></rect><rect y='806013.06' x='365.64' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.22'></rect><rect y='806013.06' x='217.14' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.22'></rect><rect y='806013.06' x='291.36' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.28'></rect><rect y='806013.06' x='142.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='74.28'></rect><path style='stroke:black' d='M365.640000,805941.899990 L365.640000,805942.380000 L440.100000,805942.380000 L440.100000,805941.899990 '></path><path style='stroke:black' d='M365.400000,805941.900000 L365.400000,805955.640000 L365.880010,805955.640000 L365.880010,805941.900000 '></path><path style='stroke:black' d='M439.620000,805942.140000 L439.620000,805955.880000 L440.099980,805955.880000 L440.099980,805942.140000 '></path><path style='stroke:black' d='M403.020000,805956.600000 L402.540000,805954.680000 L193.140000,806007.840000 L193.620000,806009.760000 '></path><path style='stroke:black' d='M403.140000,805956.600000 L402.420000,805954.740000 L270.060000,806005.920000 L270.780000,806007.780000 '></path><path style='stroke:black' d='M403.380000,805956.420000 L402.180000,805954.860000 L341.580000,806001.660000 L342.780000,806003.220000 '></path><path style='stroke:black' d='M365.400000,805955.400020 L365.400000,805955.880000 L439.860000,805955.880000 L439.860000,805955.400020 '></path><path style='stroke:black' d='M401.820000,805955.640000 L401.820000,805995.720000 L403.800000,805995.720000 L403.800000,805955.640000 '></path><path style='stroke:black' d='M402.780000,805996.740000 L402.960000,805996.740000 L403.140000,805996.680000 L403.500000,805996.440000 L403.620000,805996.320000 L403.680000,805996.140000 L403.740000,805995.960000 L403.740000,805995.540000 L403.564000,805994.981000 L403.646000,805995.184000 L403.140000,805994.820000 L402.960000,805994.760000 L402.540000,805994.760000 L401.584000,805995.083000 L401.448000,805996.178000 L402.360000,805996.680000 L402.540000,805996.740000 L402.780000,805996.740000 '></path><path style='stroke:black' d='M402.780000,805995.780000 L407.700000,805995.780000 L407.520000,805996.440000 L403.260000,806011.440000 L402.780000,806013.120000 L402.300000,806011.440000 L397.980000,805996.440000 L397.800000,805995.780000 L398.460000,805995.780000 L398.940000,805996.140000 L403.260000,806011.140000 L402.300000,806011.440000 L402.300000,806011.140000 L406.560000,805996.140000 L407.520000,805996.440000 L407.040000,805996.800000 L402.780000,805996.800000 '></path><path style='stroke:black' d='M398.460000,805995.780000 L398.460000,805996.800000 L402.780000,805996.800000 L402.780000,805995.780000 '></path><path style='stroke:black' d='M402.780000,805996.260000 L407.040000,805996.260000 L402.780000,806011.260000 L398.460000,805996.260000 '></path><path style='stroke:black' d='M342.180000,806002.500000 L344.820000,806005.860000 L345.180000,806006.400000 L344.640000,806006.640000 L330.120000,806012.400000 L328.440000,806013.060000 L329.520000,806011.620000 L338.760000,805999.140000 L339.180000,805998.540000 L339.540000,805999.080000 L339.540000,805999.680000 L330.300000,806012.220000 L329.520000,806011.620000 L329.760000,806011.440000 L344.280000,806005.680000 L344.640000,806006.640000 L344.040000,806006.460000 L341.400000,806003.160000 '></path><path style='stroke:black' d='M339.540000,805999.080000 L342.180000,806002.500000 L341.400000,806003.160000 L338.760000,805999.740000 '></path><path style='stroke:black' d='M341.820000,806002.800000 L344.460000,806006.160000 L329.940000,806011.920000 L339.180000,805999.380000 '></path><path style='stroke:black' d='M341.400000,806003.100000 L341.580000,806003.220000 L341.700000,806003.340000 L342.642000,806003.813000 L343.523000,806002.901000 L343.080000,806002.020000 L343.020000,806001.840000 L342.840000,806001.720000 L342.046000,806001.044000 L341.058000,806001.780000 L341.220000,806002.740000 L341.280000,806002.920000 L341.400000,806003.100000 '></path><path style='stroke:black' d='M270.360000,806006.820000 L271.920000,806010.840000 L272.100000,806011.500000 L271.500000,806011.560000 L255.960000,806012.940000 L254.220000,806013.060000 L255.600000,806012.040000 L268.020000,806002.620000 L268.620000,806002.200000 L268.800000,806002.800000 L268.680000,806003.400000 L256.260000,806012.820000 L255.600000,806012.040000 L255.900000,806011.920000 L271.440000,806010.540000 L271.500000,806011.560000 L271.020000,806011.200000 L269.460000,806007.180000 '></path><path style='stroke:black' d='M268.800000,806002.800000 L270.360000,806006.820000 L269.460000,806007.180000 L267.900000,806003.160000 '></path><path style='stroke:black' d='M269.940000,806007.000000 L271.500000,806011.020000 L255.960000,806012.400000 L268.380000,806002.980000 '></path><path style='stroke:black' d='M193.380000,806008.800000 L194.460000,806012.940000 L194.520000,806013.600000 L193.920000,806013.540000 L178.320000,806013.060000 L176.580000,806013.060000 L178.080000,806012.160000 L191.580000,806004.300000 L192.180000,806003.940000 L192.360000,806004.600000 L192.120000,806005.140000 L178.620000,806013.000000 L178.080000,806012.160000 L178.380000,806012.100000 L193.980000,806012.580000 L193.920000,806013.540000 L193.440000,806013.180000 L192.360000,806009.040000 '></path><path style='stroke:black' d='M192.360000,806004.600000 L193.380000,806008.800000 L192.360000,806009.040000 L191.340000,806004.840000 '></path><path style='stroke:black' d='M192.900000,806008.920000 L193.980000,806013.060000 L178.380000,806012.580000 L191.880000,806004.720000 '></path><path style='stroke:black' d='M269.460000,806007.180000 L269.580000,806007.360000 L269.820000,806007.600000 L270.000000,806007.720000 L270.180000,806007.780000 L270.540000,806007.780000 L270.780000,806007.720000 L270.960000,806007.660000 L271.080000,806007.540000 L271.200000,806007.360000 L271.320000,806007.240000 L271.380000,806007.060000 L271.380000,806006.640000 L271.260000,806006.280000 L270.678000,806005.442000 L269.409000,806005.826000 L269.400000,806006.760000 L269.400000,806007.000000 L269.460000,806007.180000 '></path><path style='stroke:black' d='M192.420000,806009.040000 L192.480000,806009.220000 L192.600000,806009.400000 L193.202000,806010.140000 L194.450000,806009.733000 L194.400000,806008.740000 L194.400000,806008.560000 L194.280000,806008.380000 L193.969000,806007.423000 L192.563000,806007.705000 L192.420000,806008.620000 L192.420000,806009.040000 '></path><path style='stroke:black' d='M142.620000,806012.820000 L142.620000,806026.560000 L143.100000,806026.560000 L143.100000,806012.820000 '></path><path style='stroke:black' d='M142.860000,806012.820000 L142.860000,806013.300000 L217.380000,806013.300000 L217.380000,806012.820000 '></path><path style='stroke:black' d='M216.900000,806012.820000 L216.900000,806026.560000 L217.380000,806026.560000 L217.380000,806012.820000 '></path><path style='stroke:black' d='M217.140000,806012.820000 L217.140000,806013.300000 L291.600000,806013.300000 L291.600000,806012.820000 '></path><path style='stroke:black' d='M291.120000,806012.820000 L291.120000,806026.560000 L291.600010,806026.560000 L291.600010,806012.820000 '></path><path style='stroke:black' d='M291.360000,806012.820000 L291.360000,806013.300000 L365.880000,806013.300000 L365.880000,806012.820000 '></path><path style='stroke:black' d='M365.400000,806012.820000 L365.400000,806026.560000 L365.880010,806026.560000 L365.880010,806012.820000 '></path><path style='stroke:black' d='M365.640000,806012.820000 L365.640000,806013.300000 L440.100000,806013.300000 L440.100000,806012.820000 '></path><path style='stroke:black' d='M216.900000,806013.060000 L216.900000,806026.800000 L217.380000,806026.800000 L217.380000,806013.060000 '></path><path style='stroke:black' d='M291.120000,806013.060000 L291.120000,806026.800000 L291.600010,806026.800000 L291.600010,806013.060000 '></path><path style='stroke:black' d='M365.400000,806013.060000 L365.400000,806026.800000 L365.880010,806026.800000 L365.880010,806013.060000 '></path><path style='stroke:black' d='M439.620000,806013.060000 L439.620000,806026.800000 L440.099980,806026.800000 L440.099980,806013.060000 '></path><path style='stroke:black' d='M142.620000,806026.320000 L142.620000,806026.800000 L217.140000,806026.800000 L217.140000,806026.320000 '></path><path style='stroke:black' d='M216.900000,806026.320000 L216.900000,806026.800000 L291.360000,806026.800000 L291.360000,806026.320000 '></path><path style='stroke:black' d='M291.120000,806026.320000 L291.120000,806026.800000 L365.640000,806026.800000 L365.640000,806026.320000 '></path><path style='stroke:black' d='M365.400000,806026.320000 L365.400000,806026.800000 L439.860000,806026.800000 L439.860000,806026.320000 '></path><text y='805951.9335' x='396.0' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.21'>X0</text><text y='806022.7935' x='396.0' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.21'>X0</text><text y='806022.7935' x='247.5' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.21'>X0</text><text y='806022.7935' x='321.78' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text><text y='806022.7935' x='173.28' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text></svg><h3>Figure 4-29.  VBROADCASTSD Operation</h3><svg width='568.799985' viewBox='111.840000 806328.000010 379.199990 144.960000' height='217.44'><text y='806368.6335' x='270.72' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='18.726'>m128</text><text y='806439.4935' x='126.18' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='20.004'>DEST</text><rect y='806360.46' x='294.36' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='148.5'></rect><rect y='806431.38' x='294.36' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='148.5'></rect><rect y='806431.38' x='145.86' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='13.5' width='148.5'></rect><path style='stroke:black' d='M294.120000,806360.220000 L294.120000,806373.960000 L294.600010,806373.960000 L294.600010,806360.220000 '></path><path style='stroke:black' d='M294.360000,806360.220020 L294.360000,806360.700000 L443.100000,806360.700000 L443.100000,806360.220020 '></path><path style='stroke:black' d='M442.620000,806360.460000 L442.620000,806374.200000 L443.099980,806374.200000 L443.099980,806360.460000 '></path><path style='stroke:black' d='M362.220000,806374.920000 L361.500000,806373.060000 L229.140000,806424.240000 L229.860000,806426.100000 '></path><path style='stroke:black' d='M294.120000,806373.720020 L294.120000,806374.200000 L442.860000,806374.200000 L442.860000,806373.720020 '></path><path style='stroke:black' d='M360.900000,806373.960000 L360.900000,806414.040000 L362.880000,806414.040000 L362.880000,806373.960000 '></path><path style='stroke:black' d='M361.860000,806415.060000 L362.040000,806415.060000 L362.280000,806415.000000 L362.400000,806414.880000 L362.580000,806414.760000 L362.700000,806414.640000 L362.820000,806414.280000 L362.880000,806414.040000 L362.820000,806413.860000 L362.667000,806413.438000 L362.732000,806413.351000 L362.280000,806413.140000 L362.040000,806413.080000 L361.680000,806413.080000 L361.320000,806413.200000 L361.140000,806413.320000 L361.020000,806413.500000 L360.840000,806414.040000 L360.964000,806414.421000 L360.916000,806414.686000 L361.320000,806414.880000 L361.500000,806415.000000 L361.680000,806415.060000 L361.860000,806415.060000 '></path><path style='stroke:black' d='M361.860000,806414.100000 L366.840000,806414.100000 L366.660000,806414.760000 L362.340000,806429.700000 L361.860000,806431.380000 L361.380000,806429.700000 L357.060000,806414.760000 L356.880000,806414.100000 L357.540000,806414.100000 L358.020000,806414.460000 L362.340000,806429.400000 L361.380000,806429.700000 L361.380000,806429.400000 L365.700000,806414.460000 L366.660000,806414.760000 L366.180000,806415.120000 L361.860000,806415.120000 '></path><path style='stroke:black' d='M357.540000,806414.100000 L357.540000,806415.120000 L361.860000,806415.120000 L361.860000,806414.100000 '></path><path style='stroke:black' d='M361.860000,806414.580000 L366.180000,806414.580000 L361.860000,806429.520000 L357.540000,806414.580000 '></path><path style='stroke:black' d='M229.440000,806425.140000 L231.000000,806429.100000 L231.240000,806429.700000 L230.580000,806429.820000 L215.040000,806431.260000 L213.300000,806431.380000 L214.680000,806430.360000 L227.100000,806420.940000 L227.700000,806420.520000 L227.880000,806421.120000 L227.760000,806421.720000 L215.340000,806431.140000 L214.680000,806430.360000 L214.980000,806430.240000 L230.520000,806428.800000 L230.580000,806429.820000 L230.100000,806429.460000 L228.540000,806425.500000 '></path><path style='stroke:black' d='M227.880000,806421.120000 L229.440000,806425.140000 L228.540000,806425.500000 L226.980000,806421.480000 '></path><path style='stroke:black' d='M229.020000,806425.320000 L230.580000,806429.280000 L215.040000,806430.720000 L227.460000,806421.300000 '></path><path style='stroke:black' d='M228.540000,806425.500000 L228.660000,806425.680000 L228.780000,806425.800000 L229.418000,806426.528000 L230.701000,806425.915000 L230.460000,806424.960000 L230.460000,806424.780000 L230.220000,806424.420000 L230.100000,806424.300000 L229.920000,806424.180000 L229.740000,806424.120000 L229.320000,806424.120000 L229.140000,806424.180000 L228.633000,806424.544000 L228.716000,806424.341000 L228.540000,806424.900000 L228.480000,806425.080000 L228.540000,806425.260000 L228.540000,806425.500000 '></path><text y='806370.2535' x='355.14' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text><text y='806441.1135' x='355.14' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text><text y='806441.1135' x='206.64' style='font-size:7.500000pt' lengthAdjust='spacingAndGlyphs' textLength='9.15'>X0</text></svg><h3>Figure 4-30.  VBROADCASTF128 Operation</h3></span>", "url": "VBROADCAST.html", "tooltip": "Load floating point values from the source operand (second operand) and broadcast to all elements of the destina-tion operand (first operand)."},
    "FICOM": {"html": "<p>Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below). The integer value is converted to double extended-precision floating-point format before the comparison is made.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><h3>Table 3-36.  FICOM/FICOMP Results</h3><table><tr><th>Condition</th><th>C3</th><th>C2</th><th>C0</th></tr><tr><td>ST(0) &gt; SRC</td><td>0</td><td>0</td><td>0</td></tr><tr><td>ST(0) &lt; SRC</td><td>0</td><td>0</td><td>1</td></tr><tr><td>ST(0) = SRC</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Unordered</td><td>1</td><td>1</td><td>1</td></tr></table><p>These instructions perform an 'unordered comparison.” An unordered comparison also checks the class of the numbers being compared (see 'FXAM—Examine ModR/M” in this chapter). If either operand is a NaN or is in an undefined format, the condition flags are set to 'unordered.”</p><p>The sign of zero is ignored, so that –0.0 ← +0.0.</p><p>The FICOMP instructions pop the register stack following the comparison. To pop the register stack, the processor marks the ST(0) register empty and increments the stack pointer (TOP) by 1.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FICOM:FICOMP.html", "tooltip": "Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below). The integer value is converted to double extended-precision floating-point format before the comparison is made."},
    "RSQRTPS": {"html": "<p>Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single-preci-sion floating-point values in the source operand (second operand) and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The relative error for this approximation is:</p><p>|Relative Error| ≤ 1.5 ∗ 2<sup>−12</sup></p><p>The RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "RSQRTPS.html", "tooltip": "Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single-preci-sion floating-point values in the source operand (second operand) and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation."},
    "MONITOR": {"html": "<p>The MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by MWAIT.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The content of EAX is an effective address (in 64-bit mode, RAX is used). By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used.</p><p>ECX and EDX are also used. They communicate other information to MONITOR. ECX specifies optional extensions. EDX specifies optional hints; it does not change the architectural behavior of the instruction. For the Pentium 4 processor (family 15, model 3), no extensions or hints are defined. Undefined hints in EDX are ignored by the processor; undefined extensions in ECX raises a general protection fault.</p><p>The address range must use memory of the write-back type. Only write-back memory will correctly trigger the monitoring hardware. Additional information on determining what address range to use in order to prevent false wake-ups is described in Chapter 8, 'Multiple-Processor Management” of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>.</p><p>The MONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, MONITOR sets the A-bit but not the D-bit in page tables.</p><p>CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MONITOR may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MONITOR clears the CPUID feature flag and causes execution to generate an invalid-opcode excep-tion.</p><p>The instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "MONITOR.html", "tooltip": "The MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by MWAIT."},
    "MOVDDUP": {"html": "<p>The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 8 bytes of data at memory location m64 are loaded. When the register-register form of this operation is used, the lower half of the 128-bit source register is duplicated and copied into the 128-bit destination register. See Figure 3-24.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><svg width='550.17' viewBox='117.060000 405902.640000 366.780000 152.400000' height='228.6'><text y='405920.170114' x='220.8613' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='108.7560782'>MOVDDUP xmm1, xmm2/m64</text><text y='405945.483114' x='423.3145' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='39.5614835'>xmm2/m64</text><text y='405945.483614' x='337.3015' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[63:0]</text><text y='405989.059914' x='423.3145' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='32.3052114'>RESULT:</text><text y='405993.860614' x='139.2831' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='128.0608021'>xmm1[127:64]        xmm2/m64[63:0]</text><text y='405993.860614' x='287.7295' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='119.1644685'>xmm1[63:0]        xmm2/m64[63:0]</text><text y='405998.660314' x='423.3145' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='21.7768166'>xmm1</text><text y='406017.511414' x='188.8553' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='28.9130842'>[127:64]</text><text y='406017.511414' x='337.31126689' style='font-size:8.000300pt' lengthAdjust='spacingAndGlyphs' textLength='20.0167506'>[63:0]</text><text y='406046.419809' x='452.7704' style='font-size:6.000200pt' lengthAdjust='spacingAndGlyphs' textLength='26.3468782'>OM15997</text><rect y='405903.336' x='117.802' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='126.005' width='360.015'></rect><rect y='405903.336' x='117.802' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='126.005' width='360.015'></rect><rect y='405929.212' x='275.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='405977.589' x='131.303' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='405977.589' x='275.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='405929.212' x='275.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='405977.589' x='131.303' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect><rect y='405977.589' x='275.309' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='27.001' width='144.006'></rect></svg><h3>Figure 3-24.  MOVDDUP—Move One Double-FP and Duplicate</h3><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p></span>", "url": "MOVDDUP.html", "tooltip": "The linear address corresponds to the address of the least-significant byte of the referenced memory data. When a memory address is indicated, the 8 bytes of data at memory location m64 are loaded. When the register-register form of this operation is used, the lower half of the 128-bit source register is duplicated and copied into the 128-bit destination register. See Figure 3-24."},
    "IMUL": {"html": "<p>Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p><p>The CF and OF flags are set when the signed integer value of the intermediate product differs from the sign extended operand-size-truncated product, otherwise the CF and OF flags are cleared.</p><p>The three forms of the IMUL instruction are similar in that the length of the product is calculated to twice the length of the operands. With the one-operand form, the product is stored exactly in the destination. With the two- and three- operand forms, however, the result is truncated to the length of the destination before it is stored in the destination register. Because of this truncation, the CF or OF flag should be tested to ensure that no significant bits are lost.</p><p>The two- and three-operand forms may also be used with unsigned operands because the lower half of the product is the same regardless if the operands are signed or unsigned. The CF and OF flags, however, cannot be used to determine if the upper half of the result is non-zero.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. Use of REX.W modifies the three forms of the instruction as follows.</p></span>", "url": "IMUL.html", "tooltip": "Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands."},
    "PREFETCHh": {"html": "<p>Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by a locality hint:</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>— Pentium III processor—1st- or 2nd-level cache.</p><p>— Pentium 4 and Intel Xeon processors—2nd-level cache.</p><p>— Pentium III processor—2nd-level cache.</p><p>— Pentium 4 and Intel Xeon processors—2nd-level cache.</p><p>— Pentium III processor—2nd-level cache.</p><p>— Pentium 4 and Intel Xeon processors—2nd-level cache.</p><p>— Pentium III processor—1st-level cache</p><p>— Pentium 4 and Intel Xeon processors—2nd-level cache</p><p>The source operand is a byte memory location. (The locality hints are encoded into the machine level instruction using bits 3 through 5 of the ModR/M byte.)</p><p>If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement occurs. Prefetches from uncacheable or WC memory are ignored.</p><p>The PREFETCH<em>h</em> instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor in anticipation of future use.</p><p>The implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes.</p><p>It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A PREFETCH<em>h</em> instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCH<em>h</em> instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCH<em>h</em> instruction is also</p><p>unordered with respect to CLFLUSH instructions, other PREFETCH<em>h </em>instructions, or any other general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "PREFETCHh.html", "tooltip": "Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by a locality hint:"},
    "CVTSI2SS": {"html": "<p>Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the source operand (second operand) to a single-precision floating-point value in the destination operand (first operand). The source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Legacy SSE instructions: In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. Use of the REX.W prefix promotes the instruction to 64-bit operands. See the summary chart at the beginning of this section for encoding data and limits.</p><p>128-bit Legacy SSE version: The destination and first source operand are the same. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "CVTSI2SS.html", "tooltip": "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the source operand (second operand) to a single-precision floating-point value in the destination operand (first operand). The source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register."},
    "FSINCOS": {"html": "<p>Computes both the sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand must be given in radians and must be within the range −2<sup>63</sup> to +2<sup>63</sup>. The following table shows the results obtained when taking the sine and cosine of various classes of numbers, assuming that underflow does not occur.</p><h3>Table 3-46.  FSINCOS Results</h3><p><strong>SRC</strong></p><p><strong>DEST</strong></p><table><tr><td></td><td></td><td></td></tr><tr><th>ST(0)</th><th>ST(1) Cosine</th><th>ST(0) Sine</th></tr><tr><td>− ∞</td><td>*</td><td>*</td></tr><tr><td>− F</td><td>− 1 to + 1</td><td>− 1 to + 1</td></tr><tr><td>− 0</td><td>+ 1</td><td>− 0</td></tr><tr><td>+ 0</td><td>+ 1</td><td>+ 0</td></tr><tr><td>+ F</td><td>− 1 to + 1</td><td>− 1 to + 1</td></tr><tr><td>+ ∞</td><td>*</td><td>*</td></tr><tr><td>NaN</td><td>NaN</td><td>NaN</td></tr></table><p><strong>NOTES:</strong></p><p>F Means finite floating-point value.</p><p>*</p><p>Indicates floating-point invalid-arithmetic-operand (#IA) exception.</p><p>If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range − 2<sup>63</sup> to +2<sup>63</sup> can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π or by using the FPREM instruction with a divisor of 2π. See the section titled 'Pi” in Chapter 8 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for a discussion of the proper value to use for π in performing such reductions.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "FSINCOS.html", "tooltip": "Computes both the sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.)"},
    "LEAVE": {"html": "<p>Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure’s stack frame.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling procedure.</p><p>See 'Procedure Calls for Block-Structured Languages” in Chapter 7 of the <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>, for detailed information on the use of the ENTER and LEAVE instructions.</p><p>In 64-bit mode, the instruction’s default operation size is 64 bits; 32-bit operation cannot be encoded. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "LEAVE.html", "tooltip": "Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure’s stack frame."},
    "CMPSS": {"html": "<p>Compares the low single-precision floating-point values in the source operand (second operand) and the destina-tion operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed. The comparison result is a double-word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 64-bit memory location. The comparison pred-icate operand is an 8-bit immediate, bits 2:0 of the immediate define the type of comparison to be performed (see Table 3-7). Bits 7:3 of the immediate is reserved. Bits (VLMAX-1:32) of the corresponding YMM destination register remain unchanged.</p><p>The unordered relationship is true when at least one of the two source operands being compared is a NaN; the ordered relationship is true when neither source operand is a NaN</p><p>A subsequent computational instruction that uses the mask result in the destination operand as an input operand will not generate a fault, since a mask of all 0s corresponds to a floating-point value of +0.0 and a mask of all 1s corresponds to a QNaN.</p><p>Note that processors with 'CPUID.1H:ECX.AVX =0” do not implement the 'greater-than”, 'greater-than-or-equal”, 'not-greater than”, and 'not-greater-than-or-equal relations” predicates. These comparisons can be made either by using the inverse relationship (that is, use the 'not-less-than-or-equal” to make a 'greater-than” comparison) or by using software emulation. When using software emulation, the program must swap the operands (copying registers when necessary to protect the data that will now be in the destination operand), and then perform the compare using a different predicate. The predicate to be used for these emulations is listed in Table 3-7 under the heading Emulation.</p><p>Compilers and assemblers may implement the following two-operand pseudo-ops in addition to the three-operand CMPSS instruction, for processors with 'CPUID.1H:ECX.AVX =0”. See Table 3-15. Compiler should treat reserved Imm8 values as illegal syntax.</p><h3>Table 3-15.  Pseudo-Ops and CMPSS</h3><table><tr><th>Pseudo-Op</th><th>CMPSS Implementation</th></tr><tr><td>CMPEQSS <em>xmm1, xmm2</em></td><td>CMPSS<em> xmm1, xmm2, 0</em></td></tr><tr><td>CMPLTSS <em>xmm1, xmm2</em></td><td>CMPSS <em>xmm1, xmm2, 1</em></td></tr><tr><td>CMPLESS <em>xmm1, xmm2</em></td><td>CMPSS <em>xmm1, xmm2, 2</em></td></tr><tr><td>CMPUNORDSS<em> xmm1, xmm2</em></td><td>CMPSS <em>xmm1, xmm2, 3</em></td></tr><tr><td>CMPNEQSS<em> xmm1, xmm2</em></td><td>CMPSS <em>xmm1, xmm2, 4</em></td></tr><tr><td>CMPNLTSS <em>xmm1, xmm2</em></td><td>CMPSS <em>xmm1, xmm2, 5</em></td></tr><tr><td>CMPNLESS<em> xmm1, xmm2</em></td><td>CMPSS <em>xmm1, xmm2, 6</em></td></tr><tr><td>CMPORDSS <em>xmm1, xmm2</em></td><td>CMPSS <em>xmm1, xmm2, 7</em></td></tr></table><p>The greater-than relations not implemented in the processor require more than one instruction to emulate in soft-ware and therefore should not be implemented as pseudo-ops. (For these, the programmer should reverse the operands of the corresponding less than relations and use move instructions to ensure that the mask is moved to the correct destination register and that the source operand is left intact.)</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p><strong>Enhanced Comparison Predicate for VEX-Encoded VCMPSD</strong></p><p>VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 32-bit memory location. Bits (VLMAX-1:128) of the destina-tion YMM register are zeroed. The comparison predicate operand is an 8-bit immediate:</p><p>Processors with 'CPUID.1H:ECX.AVX =1” implement the full complement of 32 predicates shown in Table 3-9, soft-ware emulation is no longer needed. Compilers and assemblers may implement the following three-operand pseudo-ops in addition to the four-operand VCMPSS instruction. See Table 3-16, where the notations of reg1 reg2, and reg3 represent either XMM registers or YMM registers. Compiler should treat reserved Imm8 values as illegal syntax. Alternately, intrinsics can map the pseudo-ops to pre-defined constants to support a simpler intrinsic inter-face.</p><h3>Table 3-16.  Pseudo-Op and VCMPSS Implementation</h3><p>:</p><table><tr><th>Pseudo-Op</th><th>CMPSS Implementation</th></tr><tr><td>VCMPEQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 0</em></td></tr><tr><td>VCMPLTSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 1</em></td></tr><tr><td>VCMPLESS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 2</em></td></tr><tr><td>VCMPUNORDSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 3</em></td></tr><tr><td>VCMPNEQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 4</em></td></tr><tr><td>VCMPNLTSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 5</em></td></tr><tr><td>VCMPNLESS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 6</em></td></tr><tr><td>VCMPORDSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 7</em></td></tr><tr><td>VCMPEQ_UQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 8</em></td></tr><tr><td>VCMPNGESS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 9</em></td></tr><tr><td>VCMPNGTSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 0AH</em></td></tr><tr><td>VCMPFALSESS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 0BH</em></td></tr><tr><td>VCMPNEQ_OQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 0CH</em></td></tr><tr><td>VCMPGESS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 0DH</em></td></tr><tr><td>VCMPGTSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 0EH</em></td></tr></table><h3>Table 3-16.  Pseudo-Op and VCMPSS Implementation (Contd.)</h3><table><tr><th>Pseudo-Op</th><th>CMPSS Implementation</th></tr><tr><td>VCMPTRUESS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 0FH</em></td></tr><tr><td>VCMPEQ_OSSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 10H</em></td></tr><tr><td>VCMPLT_OQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 11H</em></td></tr><tr><td>VCMPLE_OQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 12H</em></td></tr><tr><td>VCMPUNORD_SSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 13H</em></td></tr><tr><td>VCMPNEQ_USSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 14H</em></td></tr><tr><td>VCMPNLT_UQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 15H</em></td></tr><tr><td>VCMPNLE_UQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 16H</em></td></tr><tr><td>VCMPORD_SSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 17H</em></td></tr><tr><td>VCMPEQ_USSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 18H</em></td></tr><tr><td>VCMPNGE_UQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 19H</em></td></tr><tr><td>VCMPNGT_UQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 1AH</em></td></tr><tr><td>VCMPFALSE_OSSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 1BH</em></td></tr><tr><td>VCMPNEQ_OSSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 1CH</em></td></tr><tr><td>VCMPGE_OQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 1DH</em></td></tr><tr><td>VCMPGT_OQSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 1EH</em></td></tr><tr><td>VCMPTRUE_USSS r<em>eg1, reg2, reg3</em></td><td>VCMPSS r<em>eg1, reg2, reg3, 1FH</em></td></tr></table></span>", "url": "CMPSS.html", "tooltip": "Compares the low single-precision floating-point values in the source operand (second operand) and the destina-tion operand (first operand) and returns the results of the comparison to the destination operand. The comparison predicate operand (third operand) specifies the type of comparison performed. The comparison result is a double-word mask of all 1s (comparison true) or all 0s (comparison false). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "CMP": {"html": "<p>Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The condition codes used by the J<em>cc</em>, CMOV<em>cc</em>, and SET<em>cc</em> instructions are based on the results of a CMP instruction. Appendix B, 'EFLAGS Condition Codes,” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, shows the relationship of the status flags and the condition codes.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "CMP.html", "tooltip": "Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand."},
    "XSAVEOPT": {"html": "<p>Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The format of the XSAVE area is detailed in Section 13.4, 'XSAVE Area,” of <em>Intel® 64 and IA-32 Architectures Soft-ware Developer’s Manual, Volume 1</em>.</p><p>Section 13.8, 'Operation of XSAVEOPT,” of <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em> provides a detailed description of the operation of the XSAVEOPT instruction. The following items provide a high-level outline:</p><p>Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) will result in a general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</p></span>", "url": "XSAVEOPT.html", "tooltip": "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0."},
    "JMP": {"html": "<p>Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>This instruction can be used to execute four different types of jumps:</p><p>A task switch can only be executed in protected mode (see Chapter 7, in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for information on performing task switches with the JMP instruction).</p><p><strong>Near and Short Jumps. </strong>When executing a near jump, the processor jumps to the address (within the current code segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current</p><p>value of the instruction pointer in the EIP register). A near jump to a relative offset of 8-bits (<em>rel8</em>) is referred to as a short jump. The CS register is not changed on near and short jumps.</p><p>An absolute offset is specified indirectly in a general-purpose register or a memory location (<em>r/m16</em> or <em>r/m32</em>). The operand-size attribute determines the size of the target operand (16 or 32 bits). Absolute offsets are loaded directly into the EIP register. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.</p><p>A relative offset (<em>rel8, rel16</em>, or <em>rel32</em>) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed 8-, 16-, or 32-bit immediate value. This value is added to the value in the EIP register. (Here, the EIP register contains the address of the instruction following the JMP instruction). When using relative offsets, the opcode (for short vs. near jumps) and the operand-size attribute (for near relative jumps) determines the size of the target operand (8, 16, or 32 bits).</p><p><strong>Far Jumps in Real-Address or Virtual-8086 Mode.</strong> When executing a far jump in real-address or virtual-8086 mode, the processor jumps to the code segment and offset specified with the target operand. Here the target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). With the pointer method, the segment and address of the called procedure is encoded in the instruction, using a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address imme-diate. With the indirect method, the target operand specifies a memory location that contains a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) far address. The far address is loaded directly into the CS and EIP registers. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared.</p><p><strong>Far Jumps in Protected Mode.</strong> When the processor is operating in protected mode, the JMP instruction can be used to perform the following three types of far jumps:</p><p>(The JMP instruction cannot be used to perform inter-privilege-level far jumps.)</p><p>In protected mode, the processor always uses the segment selector part of the far address to access the corre-sponding descriptor in the GDT or LDT. The descriptor type (code segment, call gate, task gate, or TSS) and access rights determine the type of jump to be performed.</p><p>If the selected descriptor is for a code segment, a far jump to a code segment at the same privilege level is performed. (If the selected code segment is at a different privilege level and the code segment is non-conforming, a general-protection exception is generated.) A far jump to the same privilege level in protected mode is very similar to one carried out in real-address or virtual-8086 mode. The target operand specifies an absolute far address either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>). The operand-size attribute determines the size of the offset (16 or 32 bits) in the far address. The new code segment selector and its descriptor are loaded into CS register, and the offset from the instruction is loaded into the EIP register. Note that a call gate (described in the next paragraph) can also be used to perform far call to a code segment at the same privilege level. Using this mechanism provides an extra level of indirection and is the preferred method of making jumps between 16-bit and 32-bit code segments.</p><p>When executing a far jump through a call gate, the segment selector specified by the target operand identifies the call gate. (The offset part of the target operand is ignored.) The processor then jumps to the code segment speci-fied in the call gate descriptor and begins executing the instruction at the offset specified in the call gate. No stack switch occurs. Here again, the target operand can specify the far address of the call gate either directly with a pointer (<em>ptr16:16</em> or <em>ptr16:32</em>) or indirectly with a memory location (<em>m16:16</em> or <em>m16:32</em>).</p><p>Executing a task switch with the JMP instruction is somewhat similar to executing a jump through a call gate. Here the target operand specifies the segment selector of the task gate for the task being switched to (and the offset part of the target operand is ignored). The task gate in turn points to the TSS for the task, which contains the segment selectors for the task’s code and stack segments. The TSS also contains the EIP value for the next instruc-tion that was to be executed before the task was suspended. This instruction pointer value is loaded into the EIP register so that the task begins executing again at this next instruction.</p><p>The JMP instruction can also specify the segment selector of the TSS directly, which eliminates the indirection of the task gate. See Chapter 7 in <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A</em>, for detailed information on the mechanics of a task switch.</p><p>Note that when you execute at task switch with a JMP instruction, the nested task flag (NT) is not set in the EFLAGS register and the new TSS’s previous task link field is not loaded with the old task’s TSS selector. A return to the previous task can thus not be carried out by executing the IRET instruction. Switching tasks with the JMP instruc-tion differs in this regard from the CALL instruction which does set the NT flag and save the previous task link infor-mation, allowing a return to the calling task with an IRET instruction.</p><p><strong>In 64-Bit Mode </strong>— The instruction’s operation size is fixed at 64 bits. If a selector points to a gate, then RIP equals the 64-bit displacement taken from gate; else RIP equals the zero-extended offset from the far pointer referenced in the instruction.</p><p>See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "JMP.html", "tooltip": "Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location."},
    "RCPPS": {"html": "<p>Performs a SIMD computation of the approximate reciprocals of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The relative error for this approximation is:</p><p>|Relative Error| ≤ 1.5 ∗ 2<sup>−12</sup></p><p>The RCPPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2<sup>125</sup>| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2<sup>126</sup>| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "RCPPS.html", "tooltip": "Performs a SIMD computation of the approximate reciprocals of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an illustration of a SIMD single-precision floating-point operation."},
    "VERR": {"html": "<p>Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>To set the ZF flag, the following conditions must be met:</p><p>The validation performed is the same as is performed when a segment selector is loaded into the DS, ES, FS, or GS register, and the indicated access (read or write) is performed. The segment selector's value cannot result in a protection exception, enabling the software to anticipate possible segment access problems.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode. The operand size is fixed at 16 bits.</p></span>", "url": "VERR:VERW.html", "tooltip": "Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments."},
    "VFMADD132SD": {"html": "<p>Performs a SIMD multiply-add computation on the low packed double-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand, adds the infinite precision inter-mediate result to the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VFMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand, adds the infinite precision inter-mediate result to the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VFMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 64-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMADD132SD:VFMADD213SD:VFMADD231SD.html", "tooltip": "Performs a SIMD multiply-add computation on the low packed double-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "MFENCE": {"html": "<p>Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.<sup>1</sup> The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, speculative reads, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The MFENCE instruction provides a performance-efficient way of ensuring load and store ordering between routines that produce weakly-ordered results and routines that consume that data.</p><p>Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the MFENCE instruction; data can be brought into the caches specula-tively just before, during, or after the execution of an MFENCE instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p><p>Specification of the instruction's opcode above indicates a ModR/M byte of F0. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, MFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 0-7.</p></span>", "url": "MFENCE.html", "tooltip": "Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.<sup>1</sup> The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream."},
    "RCL": {"html": "<p>Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. In legacy and compatibility mode, the processor restricts the count to a number between 0 and 31 by masking all the bits in the count operand except the 5 least-significant bits.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.</p><p>The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the orig-inal value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.</p><p>The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.</p></span>", "url": "RCL:RCR:ROL:ROR.html", "tooltip": "Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. In legacy and compatibility mode, the processor restricts the count to a number between 0 and 31 by masking all the bits in the count operand except the 5 least-significant bits."},
    "SARX": {"html": "<p>Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit) while shifting.</p><p>The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit loca-tions).</p><p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p><p>If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.</p><p>SARX,SHRX, and SHLX instructions do not update flags.</p></span>", "url": "SARX:SHLX:SHRX.html", "tooltip": "Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand)."},
    "LOOP": {"html": "<p>Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.</p><p>The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-tion pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.</p><p>Some forms of the loop instruction (LOOP<em>cc</em>) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (<em>cc</em>) is associated with each instruc-tion to indicate the condition being tested for. Here, the LOOP<em>cc</em> instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.</p></span>", "url": "LOOP:LOOPcc.html", "tooltip": "Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix."},
    "LTR": {"html": "<p>Loads the source operand into the segment selector field of the task register. The source operand (a general-purpose register or a memory location) contains a segment selector that points to a task state segment (TSS). After the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The LTR instruction is provided for use in operating-system software; it should not be used in application programs. It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish the first task to be executed.</p><p>The operand-size attribute has no effect on this instruction.</p><p>In 64-bit mode, the operand size is still fixed at 16 bits. The instruction references a 16-byte descriptor to load the 64-bit base.</p></span>", "url": "LTR.html", "tooltip": "Loads the source operand into the segment selector field of the task register. The source operand (a general-purpose register or a memory location) contains a segment selector that points to a task state segment (TSS). After the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur."},
    "MOVMSKPD": {"html": "<p>Extracts the sign bits from the packed double-precision floating-point values in the source operand (second operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.</p><p>128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.</p><p>VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "MOVMSKPD.html", "tooltip": "Extracts the sign bits from the packed double-precision floating-point values in the source operand (second operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination."},
    "XACQUIRE": {"html": "<p>The XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction and the XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The XACQUIRE prefix hint can only be used with the following instructions (these instructions are also referred to as XACQUIRE-enabled when used with the XACQUIRE prefix):</p><p>The XRELEASE prefix hint can only be used with the following instructions (also referred to as XRELEASE-enabled when used with the XRELEASE prefix):</p><p>The lock variables must satisfy the guidelines described in <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, Section 15.3.3, for elision to be successful, otherwise an HLE abort may be signaled.</p><p>If an encoded byte sequence that meets XACQUIRE/XRELEASE requirements includes both prefixes, then the HLE semantic is determined by the prefix byte that is placed closest to the instruction opcode. For example, an F3F2C6 will not be treated as a XRELEASE-enabled instruction since the F2H (XACQUIRE) is closest to the instruction opcode C6. Similarly, an F2F3F0 prefixed instruction will be treated as a XRELEASE-enabled instruction since F3H (XRELEASE) is closest to the instruction opcode.</p><p><strong>Intel 64 and IA-32 Compatibility</strong></p><p>The effect of the XACQUIRE/XRELEASE prefix hint is the same in non-64-bit modes and in 64-bit mode.</p><p>For instructions that do not support the XACQUIRE hint, the presence of the F2H  prefix behaves the same way as prior hardware, according to</p><p>For instructions that do not support the XRELEASE hint, the presence of the F3H prefix behaves the same way as in prior hardware, according to</p></span>", "url": "XACQUIRE:XRELEASE.html", "tooltip": "The XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction and the XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction."},
    "PAND": {"html": "<p>Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.</p><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PAND.html", "tooltip": "Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0."},
    "INT n": {"html": "<p>The INT <em>n</em> instruction generates a call to the interrupt or exception handler specified with the destination operand (see the section titled 'Interrupts and Exceptions” in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The INT <em>n</em> instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)</p><p>The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a breakpoint, including other one byte instructions, without over-writing other code). To further support its function as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts as follows:</p><p>Note that the 'normal” 2-byte opcode for INT 3 (CD03) does not have these special features. Intel and Microsoft assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct numeric code definition or by self-modifying code.</p><p>The action of the INT <em>n</em> instruction (including the INTO and INT 3 instructions) is similar to that of a far call made with the CALL instruction. The primary difference is that with the INT <em>n</em> instruction, the EFLAGS register is pushed onto the stack before the return address. (The return address is a far address consisting of the current values of the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the EFLAGS information and return address from the stack.</p><p>The vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure. In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate, or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in real-address mode, the IDT is called the <strong>interrupt vector table</strong>, and its pointers are called interrupt vectors.)</p><p>The following decision table indicates which action in the lower portion of the table is taken given the conditions in the upper portion of the table. Each Y in the lower section of the decision table represents a procedure defined in the 'Operation” section for this instruction (except #GP).</p><h3>Table 3-61.  Decision Table</h3><table><tr><th>PE</th><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></table><h3>Table 3-61.  Decision Table (Contd.)</h3><table><tr><th>VM</th><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>0</td><td>1</td><td>1</td></tr><tr><th>IOPL</th><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>&lt;3</td><td>=3</td></tr><tr><th>DPL/CPL RELATIONSHIP</th><td>–</td><td>DPL&lt; CPL</td><td>–</td><td>DPL&gt; CPL</td><td>DPL= CPL or C</td><td>DPL&lt; CPL &amp; NC</td><td>–</td><td>–</td></tr><tr><th>INTERRUPT TYPE</th><td>–</td><td>S/W</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><th>GATE TYPE</th><td>–</td><td>–</td><td>Task</td><td>Trap or Interrupt</td><td>Trap or Interrupt</td><td>Trap or Interrupt</td><td>Trap or Interrupt</td><td>Trap or Interrupt</td></tr><tr><th>REAL-ADDRESS-MODE</th><td>Y</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><th>PROTECTED-MODE</th><td></td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><th>TRAP-OR-INTERRUPT-GATE</th><td></td><td></td><td></td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><th>INTER-PRIVILEGE-LEVEL-INTERRUPT</th><td></td><td></td><td></td><td></td><td></td><td>Y</td><td></td><td></td></tr><tr><th>INTRA-PRIVILEGE-LEVEL-INTERRUPT</th><td></td><td></td><td></td><td></td><td>Y</td><td></td><td></td><td></td></tr><tr><th>INTERRUPT-FROM-VIRTUAL-8086-MODE</th><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>Y</td></tr><tr><th>TASK-GATE</th><td></td><td></td><td>Y</td><td></td><td></td><td></td><td></td><td></td></tr><tr><th>#GP</th><td></td><td>Y</td><td></td><td>Y</td><td></td><td></td><td>Y</td><td></td></tr></table><p><strong>NOTES:</strong></p><p>−</p><p>Don't Care.</p><p>Y</p><p>Yes, action taken.</p><p>Blank</p><p>Action not taken.</p><p>When the processor is executing in virtual-8086 mode, the IOPL determines the action of the INT n instruction. If the IOPL is less than 3, the processor generates a #GP(selector) exception; if the IOPL is 3, the processor executes a protected mode interrupt to privilege level 0. The interrupt gate's DPL must be set to 3 and the target CPL of the interrupt handler procedure must be 0 to execute the protected mode interrupt to privilege level 0.</p><p>The interrupt descriptor table register (IDTR) specifies the base linear address and limit of the IDT. The initial base address value of the IDTR after the processor is powered up or reset is 0.</p></span>", "url": "INT n:INTO:INT 3.html", "tooltip": "The INT <em>n</em> instruction generates a call to the interrupt or exception handler specified with the destination operand (see the section titled 'Interrupts and Exceptions” in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are reserved by Intel for system use. Some of these vectors are used for internally generated exceptions."},
    "DIVSD": {"html": "<p>Divides the low double-precision floating-point value in the first source operand by the low double-precision floating-point value in the second source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination hyperons are XMM registers. The high quadword of the destination operand is copied from the high quadword of the first source operand. See Chapter 11 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a scalar double-precision floating-point operation.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "DIVSD.html", "tooltip": "Divides the low double-precision floating-point value in the first source operand by the low double-precision floating-point value in the second source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination hyperons are XMM registers. The high quadword of the destination operand is copied from the high quadword of the first source operand. See Chapter 11 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a scalar double-precision floating-point operation."},
    "VFMADD132PS": {"html": "<p>Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMADD132PS: Multiplies the four or eight packed single-precision floating-point values from the first source operand to the four or eight packed single-precision floating-point values in the third source operand, adds the infi-nite precision intermediate result to the four or eight packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFMADD213PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the first source operand, adds the infi-nite precision intermediate result to the four or eight packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VFMADD231PS: Multiplies the four or eight packed single-precision floating-point values from the second source operand to the four or eight packed single-precision floating-point values in the third source operand, adds the infi-nite precision intermediate result to the four or eight packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four or eight packed single-precision floating-point values to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.</p><p>VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the 'Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1”.</p></span>", "url": "VFMADD132PS:VFMADD213PS:VFMADD231PS.html", "tooltip": "Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "LMSW": {"html": "<p>Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back to real-address mode.</p><p>The LMSW instruction is provided for use in operating-system software; it should not be used in application programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.</p><p>This instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to run on the Pentium 4, Intel Xeon, P6 family, Pentium, Intel486, and Intel386 processors should use the MOV (control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.</p><p>This instruction is a serializing instruction.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode. Note that the operand size is fixed at 16 bits.</p><p>See 'Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the <em>Intel® 64 and IA-32 Archi-tectures Software Developer’s Manual, Volume 3C</em>, for more information about the behavior of this instruction in VMX non-root operation.</p></span>", "url": "LMSW.html", "tooltip": "Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction."},
    "VPERMD": {"html": "<p>Use the index values in each dword element of the first source operand (the second operand) to select a dword element in the second source operand (the third operand), the resultant dword value from the second source operand is copied to the destination operand (the first operand) in the corresponding position of the index element. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>An attempt to execute VPERMD encoded with VEX.L= 0 will cause an #UD exception.</p></span>", "url": "VPERMD.html", "tooltip": "Use the index values in each dword element of the first source operand (the second operand) to select a dword element in the second source operand (the third operand), the resultant dword value from the second source operand is copied to the destination operand (the first operand) in the corresponding position of the index element. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand."},
    "INSERTPS": {"html": "<p>(register source form)</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Select a single precision floating-point element from second source as indicated by Count_S bits of the immediate operand and insert it into the first source at the location indicated by the Count_D bits of the immediate operand. Store in the destination and zero out destination elements based on the ZMask bits of the immediate operand.</p><p>(memory source form)</p><p>Load a floating-point element from a 32-bit memory location and insert it into the first source at the location indi-cated by the Count_D bits of the immediate operand. Store in the destination and zero out destination elements based on the ZMask bits of the immediate operand.</p><p>128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version. The destination and first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>If VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.</p></span>", "url": "INSERTPS.html", "tooltip": "(register source form)"},
    "LOCK": {"html": "<p>Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the processor has exclusive use of any shared memory while the signal is asserted.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Note that, in later Intel 64 and IA-32 processors (including the Pentium 4, Intel Xeon, and P6 family processors), locking may occur without the LOCK# signal being asserted. See the 'IA-32 Architecture Compatibility” section below.</p><p>The LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of the LOCK prefix.</p><p>The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory location in shared memory environment.</p><p>The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.</p><p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p></span>", "url": "LOCK.html", "tooltip": "Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the processor has exclusive use of any shared memory while the signal is asserted."},
    "MOVD": {"html": "<p>Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>When the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.</p><p>In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to addi-tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p></span>", "url": "MOVD:MOVQ.html", "tooltip": "Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations."},
    "STOS": {"html": "<p>In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>At the assembly-code level, two forms of the instruction are allowed: the 'explicit-operands” form and the 'no-operands” form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct <strong>type</strong> (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct <strong>location</strong>. The location is always specified by the ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.</p><p>The no-operands form provides 'short forms” of the byte, word, doubleword, and quadword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword from EAX).</p><p>After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).</p><h3>NOTE</h3><p>To improve performance, more recent processors support modifications to the processor’s operation during the string store operations initiated with STOS and STOSB. See Section 7.3.9.3 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em> for additional information on fast-string operation.</p><p>In 64-bit mode, the default address size is 64 bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The promoted no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant) store a quadword from the RAX register into the destination addressed by RDI or EDI. See the summary chart at the beginning of this section for encoding data and limits.</p><p>The STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See 'REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.</p></span>", "url": "STOS:STOSB:STOSW:STOSD:STOSQ.html", "tooltip": "In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix."},
    "VFMADD132SS": {"html": "<p>Performs a SIMD multiply-add computation on packed single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>VFMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the infinite precision interme-diate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VFMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the infinite precision interme-diate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VFMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the infinite precision inter-mediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).</p><p>VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 32-bit memory location and encoded in rm_field. The upper bits ([VLMAX-1:128]) of the YMM destination register are zeroed.</p><p>Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column. See also Section 14.5.1, 'FMA Instruction Operand Order and Arithmetic Behavior” in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p></span>", "url": "VFMADD132SS:VFMADD213SS:VFMADD231SS.html", "tooltip": "Performs a SIMD multiply-add computation on packed single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location."},
    "XGETBV": {"html": "<p>Reads the contents of the extended control register (XCR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the XCR and the EAX register is loaded with the low-order 32 bits. (On proces-sors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the XCR being read, the values returned to EDX:EAX in unimplemented bit loca-tions are undefined.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>XCR0 is supported on any processor that supports the XGETBV instruction. If CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit 2] = 1, executing XGETBV with ECX = 1 returns in EDX:EAX the logical-AND of XCR0 and the current value of the XINUSE state-component bitmap. This allows software to discover the state of the init optimization used by XSAVEOPT and XSAVES. See Chapter 13, 'Managing State Using the XSAVE Feature Set‚” in <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>.</p><p>Use of any other value for ECX results in a general-protection (#GP) exception.</p></span>", "url": "XGETBV.html", "tooltip": "Reads the contents of the extended control register (XCR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the XCR and the EAX register is loaded with the low-order 32 bits. (On proces-sors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the XCR being read, the values returned to EDX:EAX in unimplemented bit loca-tions are undefined."},
    "COMISD": {"html": "<p>Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unor-dered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unor-dered result is returned if either source operand is a NaN (QNaN or SNaN).The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory location.</p><p>The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid oper-ation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid numeric exception only if a source operand is an SNaN.</p><p>The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.</p><p>In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</p><p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p></span>", "url": "COMISD.html", "tooltip": "Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unor-dered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unor-dered result is returned if either source operand is a NaN (QNaN or SNaN).The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."},
    "ADDSD": {"html": "<p>Adds the low double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the double-precision floating-point result in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register. See Chapter 11 in the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for an overview of a scalar double-precision floating-point operation.</p><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: Bits (VLMAX-1:64) of the corresponding YMM destination register remain unchanged.</p><p>VEX.128 encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (VLMAX-1:128) of the destination YMM register are zeroed.</p></span>", "url": "ADDSD.html", "tooltip": "Adds the low double-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the double-precision floating-point result in the destination operand."},
    "ADDPS": {"html": "<p>Performs a SIMD add of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p><p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified. See Chapter 10 in the <em>Intel® 64 and IA-32 Architectures Software Devel-oper’s Manual, Volume 1</em>, for an overview of SIMD single-precision floating-point operation.</p><p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p></span>", "url": "ADDPS.html", "tooltip": "Performs a SIMD add of the four packed single-precision floating-point values from the source operand (second operand) and the destination operand (first operand), and stores the packed single-precision floating-point results in the destination operand."},
    "VCVTPH2PS": {"html": "<p>Converts four/eight packed half precision (16-bits) floating-point values in the low-order 64/128 bits of an XMM/YMM register or 64/128-bit memory location to four/eight packed single-precision floating-point values and writes the converted values into the destination XMM/YMM register.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>If case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it 0. No denormal exception is reported on MXCSR.</p><p>128-bit version: The source operand is a XMM register or 64-bit memory location. The destination operand is a XMM register. The upper bits (VLMAX-1:128) of the corresponding destination YMM register are zeroed.</p><p>256-bit version: The source operand is a XMM register or 128-bit memory location. The destination operand is a YMM register.</p><p> The diagram below illustrates how data is converted from four packed half precision (in 64 bits) to four single precision (in 128 bits) FP values. Note: VEX.vvvv is reserved (must be 1111b).</p><svg width='594.089985' viewBox='103.440000 808295.999995 396.059990 129.840000' height='194.76'><text y='808320.081671' x='194.2797' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='41.63642114'>VCVTPH2PS xmm1, xmm2/mem64,  imm8</text><text y='808329.442171' x='114.6608' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='68.36796516'>127                              96</text><text y='808329.442171' x='194.2803' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='67.9473277'>95                                64</text><text y='808329.442171' x='273.8998' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='33.10530496'>63           48</text><text y='808329.442171' x='313.6798' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='33.16549156'>47           32</text><text y='808329.442171' x='353.52' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='33.10530496'>31           16</text><text y='808329.442171' x='393.3' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='32.7448541'>15             0</text><text y='808338.801871' x='443.039' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='41.8865299'>xmm2/mem64</text><text y='808338.802171' x='285.06' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.83847052'>VH3</text><text y='808338.802171' x='324.9' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.83847052'>VH2</text><text y='808338.802171' x='364.68' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.83847052'>VH1</text><text y='808338.802171' x='404.46' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.89865712'>VH0</text><text y='808371.502171' x='359.28' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='21.767487'>convert</text><text y='808371.502171' x='399.12' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='21.7073004'>convert</text><text y='808380.862171' x='140.4' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='21.7073004'>convert</text><text y='808380.862171' x='219.96' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='21.76481204'>convert</text><text y='808404.261971' x='114.6608' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='68.36796516'>127                              96</text><text y='808404.261971' x='194.2803' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='67.9473277'>95                                64</text><text y='808404.261971' x='273.8998' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='67.9473277'>63                                32</text><text y='808404.261971' x='353.5193' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='67.52669024'>31                                  0</text><text y='808413.622071' x='145.8' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.83847052'>VS3</text><text y='808413.622071' x='225.36' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.83847052'>VS2</text><text y='808413.622071' x='304.98' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.83847052'>VS1</text><text y='808413.622071' x='384.6' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='12.83847052'>VS0</text><text y='808413.622171' x='443.039' style='font-size:6.687400pt' lengthAdjust='spacingAndGlyphs' textLength='17.8185773'>xmm1</text><rect y='808374.78' x='217.62' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.29999999993' width='28.32'></rect><rect y='808374.78' x='138.0' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.29999999993' width='28.32'></rect><rect y='808365.42' x='396.72' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='28.32'></rect><rect y='808365.42' x='356.88' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='28.38'></rect><rect y='808332.661008' x='311.3883122' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='39.7784346'></rect><rect y='808332.661008' x='351.1667468' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='39.7784346'></rect><rect y='808332.66' x='311.4' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='39.78'></rect><rect y='808332.66' x='351.18' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='39.78'></rect><rect y='808332.661008' x='390.9451814' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='39.8384182'></rect><rect y='808332.661008' x='271.549894' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='39.8384182'></rect><rect y='808332.66' x='390.96' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='39.84'></rect><rect y='808332.66' x='271.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='39.84'></rect><rect y='808332.661008' x='191.9930248' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='79.5568692'></rect><rect y='808407.48089' x='191.9930248' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='79.5568692'></rect><rect y='808332.66' x='192.0' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='79.56'></rect><rect y='808407.48' x='192.0' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='79.56'></rect><rect y='808332.661008' x='112.376172' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='79.6168528'></rect><rect y='808407.48089' x='351.1667468' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='79.6168528'></rect><rect y='808407.48089' x='271.549894' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='79.6168528'></rect><rect y='808407.48089' x='112.376172' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35997864499' width='79.6168528'></rect><rect y='808332.66' x='112.38' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='79.62'></rect><rect y='808407.48' x='351.18' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='79.62'></rect><rect y='808407.48' x='271.56' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='79.62'></rect><rect y='808407.48' x='112.38' style='fill:rgba(0,0,0,0);stroke:rgb(0,0,0);stroke-width:1pt;' height='9.35999999999' width='79.62'></rect></svg><h3>Figure 4-31.  VCVTPH2PS (128-bit Version)</h3></span>", "url": "VCVTPH2PS.html", "tooltip": "Converts four/eight packed half precision (16-bits) floating-point values in the low-order 64/128 bits of an XMM/YMM register or 64/128-bit memory location to four/eight packed single-precision floating-point values and writes the converted values into the destination XMM/YMM register."},
    "PACKUSDW": {"html": "<p>Converts packed signed doubleword integers into packed unsigned word integers using unsigned saturation to handle overflow conditions.  If the signed doubleword value is beyond the range of an unsigned word (that is, greater than FFFFH or less than 0000H), the saturated unsigned word integer value of FFFFH or 0000H, respec-tively, is stored in the destination.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or a 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM register destination are unmodified.</p><p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are zeroed.</p><p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p><p>Note: VEX.L must be 0, otherwise the instruction will #UD.</p></span>", "url": "PACKUSDW.html", "tooltip": "Converts packed signed doubleword integers into packed unsigned word integers using unsigned saturation to handle overflow conditions.  If the signed doubleword value is beyond the range of an unsigned word (that is, greater than FFFFH or less than 0000H), the saturated unsigned word integer value of FFFFH or 0000H, respec-tively, is stored in the destination."},
    "RET": {"html": "<p>Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.</p><p>The RET instruction can be used to execute three different types of returns:</p><p>The inter-privilege-level return type can only be executed in protected mode. See the section titled 'Calling Proce-dures Using Call and RET” in Chapter 6 of the <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1</em>, for detailed information on near, far, and inter-privilege-level returns.</p><p>When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.</p><p>When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP register, then pops the segment selector from the top of the stack into the CS register. The processor then begins program execution in the new code segment at the new instruction pointer.</p><p>The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the processor examines the privilege levels and access rights of the code and stack segments being returned to deter-mine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are loaded from the stack.</p><p>If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand must be used with the RET instruction to release the parameters on the return. Here, the parameters are released both from the called procedure’s stack and the calling procedure’s stack (that is, the stack being returned to).</p><p>In 64-bit mode, the default operation size of this instruction is the stack-address size, i.e. 64 bits. This applies to near returns, not far returns; the default operation size of far returns is 32 bits.</p></span>", "url": "RET.html", "tooltip": "Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction."},
    "AAM": {"html": "<p>Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain the correct 2-digit unpacked (base 10) BCD result.</p><a href='#' data-toggle='collapse' data-target='#more' onclick='$(this).remove();'>View more...</a><span id='more' class='collapse'><p>The generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked digits of any number base (see the 'Operation” section below). Here, the <em>imm8</em> byte is set to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the instruction must be hand coded in machine code (D4 <em>imm8</em>).</p><p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p></span>", "url": "AAM.html", "tooltip": "Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain the correct 2-digit unpacked (base 10) BCD result."}
};

function getAsmOpcode(opcode) {
    if (!opcode) return;
    return tokens[opcode.toUpperCase()];
}

module.exports = {
    getAsmOpcode: getAsmOpcode
}
